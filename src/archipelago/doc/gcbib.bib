%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                              %
%    	       %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%                 %
%    	       %                                             %                 %
%    	       %        GARBAGE COLLECTION BIBLIOGRAPHY      %                 %
%    	       %                                             %                 %
%    	       %        (c) 1996-2003, Richard E. Jones      %                 %
%    	       %                                             %                 %
%    	       %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%                 %
%                                                                              %
%                                                                              %
% This bibliography may be freely used for non-commercial purposes.            %
% It may also be freely distributed provided that this notice is included.     %
% The bibliography is available in BibTeX, PostScript and HTML forms from      %
%	http://www.cs.ukc.ac.uk/people/staff/rej/gcbib/gcbib.html              %
% I would be most grateful to receive additions, corrections and URLs of       %
% electronically available papers.                                             %
%                                                                              %
% Richard Jones                                                                %
%                                                                              %
% Computing Laboratory                                                         %
% University of Kent at Canterbury          Telephone: 01227 764000 ext.7943   %
% Canterbury,                                          01227 827943 (direct)   %
% CT2 7NF, U.K.				          FAX: 01227 762811            %
%                                                                              %
% Copyright Richard Jones 1996-2000                                            %
%                                                                              %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




% JOURNAL ABBREVIATIONS

@string{ActInf = "Acta Informatica"}
@string{CACM = "Communications of the {ACM}"}
@string{CompJ = "Computer Journal"}
@string{Dobbs = "Dr. Dobb's Journal"}
@string{IPL = "Information Processing Letters"}
@string{IEEETransComp = "IEEE Transactions on Computers"}
@string{IEEETransSWE = "IEEE Transactions on Software Engineering"}
@string{ISJ = "{IBM} Systems Journal"}
@string{JACM = "Journal of the ACM"}
@string{JFP = "Journal of Functional Programming"}
@string{JSS = "Journal of Systems and Software"}
@string{LNCS = "Lecture Notes in Computer Science"}
@string{LSC = "Lisp and Symbolic Computation"}
@string{MK = "Morgan Kaufman"}
@string{SPE = "Software Practice and Experience"}
@string{SIGPLAN = "ACM SIGPLAN Notices"}
@string{TECS = "ACM Transactions on Embedded Computer Systems"}
@string{TOPLAS = "ACM Transactions on Programming Languages and Systems"}
@string{TransCompSys = "ACM Transactions on Computer Systems"}
@string{TransSWE = "ACM Transactions on Software Engineering"}

% PUBLISHER + ADDRESS ABBREVIATIONS

@string{ACM = "ACM Press"}
@string{AP = "Academic Press"}
@string{AW = "Addison-Wesley"}
@string{BCS = "British Computer Society"}
@string{CUP = "Cambridge University Press"}
@string{ENH = "Elsevier-North Holland"}
@string{ES = "Elsevier Science Publishers"}
@string{IBM = "IBM Corp."}
@string{IEEE = "IEEE Press"}
@string{PH = "Prentice-Hall"}
@string{MGH = "McGraw-Hill"}
@string{NH = "North Holland"}
@string{MIT = "MIT Press"}
@string{SV = "Springer-Verlag"}
@string{UA = "USENIX Association"}
@string{Wiley = "Wiley"}


% INSTITUTION ABBREVIATIONS

@string{CMU = "Carnegie Mellon University"}
@string{CORNELL = "Cornell University"}
@string{DECSRC = "DEC Systems Research Center, Palo Alto, CA"}
@string{DECWRL = "DEC Western Research Laboratory, Palo Alto, CA"}
@string{DIKU = "Department of Computer Science (DIKU), University of Copenhagen"}
@string{INRIA = "Institut National de la Recherche en Informatique et Automatique"}
@string{Lund = "Lund University, Sweden"}
@string{MITAI = "MIT AI Laboratory"}
@string{MITLCS = "MIT Laboratory for Computer Science"}
@string{PARC = "Xerox PARC, Palo Alto, CA"}
@string{PRINCETON = "Department of Computer Science, Princeton University"}
@string{RICE = "Rice University"}
@string{UCB = "University of California, Berkeley"}
@string{UKC = "Computing Laboratory, The University of Kent at Canterbury"}
@string{UCSC = "University of California, Santa Cruz"}


% REFERENCES

@inproceedings{abdu92,
title = "Distributed Garbage Collection",
author = "Saleh E. Abdullahi and Eliot E. Miranda and Graem A. Ringwood",
address = "University of London, UK",
crossref = "IWMM92",
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/dgcsurvey.ps",
}

@inproceedings{abdu92a,
author = "Saleh E. Abdullah",
title = {Managing Computer Memory: Dynamic Allocation and Deallocation Strategies},
booktitle = {Proceedings of Second Conference on Information Technology and its Applications},
address = {Leicester},
month = dec,
pages = {25--40},
year = 1992
}

@article{abdu93,
author = "Saleh E. Abdullah and E.J.A. Edemenang",
title = {A Comparative Study of Dynamic Memory Management Techniques},
journal = {Advances in Modelling and Analysis},
volume = 15,
number = 2,
publisher = {ASME Press},
pages = {17-31},
year = 1993
}

@inproceedings{abdu94,
author = "Saleh E. Abdullah",
title = {Recycling Garbage},
booktitle = {Proceedings of Third Conference on Information Technology and its Applications},
address = {Leicester},
month = apr,
pages = {192--197},
year = 1994
}

@phdthesis{abdu95,
author = {Saleh E. Abdullahi},
title = {Empirical Studies of Distributed Garbage Collection},
school = {Queen Mary and Westfield College},
URL = {http://www.dcs.qmw.ac.uk/~gar/yakubu.thesis.ps.gz},
month = dec,
year = 1995
}

@techreport{abdu96,
author = {Saleh E. Abdullahi and Graem A. Ringwood},
title = {Empirical Studies of Distributed Garbage Collection: Parts I, II and III},
institution = {Queen Mary and Westfield College, University of London},
year = 1996
}

@techreport{abdu96a,
title = {Garbage collecting the {I}nternet},
author = {Saleh E. Abdullahi and Graem A. Ringwood},
institution = {Queen Mary and Westfield College, University of London},
year = {1996?},
note = {Draft version of \cite{abdu98}}
}

@article{abdu98,
title = {Garbage collecting the {I}nternet: a survey of distributed garbage collection},
author = {Saleh E. Abdullahi and Graem A. Ringwood},
journal = {ACM Computing Surveys},
volume = 30,
number = 3,
month = sep, 
pages = {330--373},
year = 1998,
URL = {http://www.acm.org/pubs/citations/journals/surveys/1998-30-3/p330-abdullahi/},
abstract = {Internet programming languages such as Java present new
challenges to garbage-collection design. The spectrum of
garbage-collection schema for linked structures distributed over a
network are reviewed here. Distributed garbage collectors are
classified first because they evolved from single-address-space
collectors. This taxonomy is used as a framework to explore
distribution issues: locality of action, communication overhead and
indeterministic communication latency.}
}

@inbook{abel96,
title = {Structure and Interpretation of Computer Programs},
author = {Harold Abelson and Gerald Jay Sussman and Julie Susman},
chapter = 5,
year = 1996,
publisher = MIT,
edition = {Second}
}

@inproceedings{abra87,
author = "Santosh Abraham and J. Patel",
title = "Parallel Garbage Collection on a Virtual Memory System",
booktitle = "International Conference on Parallel Processing and Applications",
editor = "E. Chiricozzi and A. D'Amato",
year = 1987,
month = sep,
address = "L'Aquila, Italy",
publisher = ENH,
pages = {243--246},
note = "Also technical report CSRD 620,
University of Illinois at Urbana-Champaign,
Center for Supercomputing Research and Development",
comment = "snapshot-at-the-beginning write barrier"
}

@article{abra67,
title = "Storage Allocation in a Certain Iterative Process",
author = "John Abramowich",
journal = CACM,
publisher = ACM,
volume = 10,
number = 6,
month = jun,
year = 1967,
pages = "368--370"
}

@inproceedings{abua04,
author = {Diab Abuaiadh and Yoav Ossia and Erez Petrank and and Uri Silbershtein},
title = {An Efficient Parallel Heap Compaction Algorithm},
crossref = {OOPSLA04},
URL = {http://www.cs.technion.ac.il/~erez/Papers/parallel-compaction.ps}
}


@inproceedings{acce86,
author = "M. Accetta and R. Baron and W. Bolosky and D. Golub and R. Rashid 
and A. Tevanian and M. Young",
title = "Mach: A New Kernel Foundation for {U}nix Development",
booktitle = "Proceedings of Usenix Summer Conference",
publisher = UA,
year = 1986,
month = jul
}


@inproceedings{adit94,
author = "Shail Aditya and Christine Flood and James Hicks",
title = "Garbage Collection for Strongly-Typed Languages Using Run-time Type Reconstruction",
pages = "12--23",
crossref = "PLDI94",
URL = "http://csg-www.lcs.mit.edu:8001/mcrctr/gc-lfp/gc-lfp.ps.Z",
abstract = "Garbage collectors perform two functions: live-object detection and
dead-object reclamation. In this paper, we present a new technique for
live-object detection based on run-time type reconstruction for a
strongly-typed, polymorphic language. This scheme uses compile-time type
information together with the run-time tree of activation frames to determine
the exact type of every object participating in the computation.  These
reconstructed types are then used to identify and traverse the live heap objects
during garbage collection. 

We describe an implementation of our scheme for the Id parallel programming
language compiled for the *T multiprocessor architecture. We present simulation
studies that compare the performance of type-reconstructing garbage collection
with conservative garbage collection and compiler-directed storage
reclamation."
}

@mastersthesis{adji96,
title = {Mesure et caract\'{e}risation d'applications r\'{e}parties},
author = {C\'{e}dric Adjih},
school = {Universit\'{e} Paris Sud},
URL = "http://www-sor.inria.fr/SOR/docs/MCAR\%3Adea96.html",
year = 1996,
abstract = "This article studies the memory behaviour of a number of
benchmark applications, with respect to the main difficulties of a
garbage collector for a distributed shared memory system. The main
variables measured are:  amount of garbage; locality of pointers; size
and locality of cycles (both reachable and garbage); in-degrees and
out-degrees."
}

@inproceedings{adl98,
title = {Fast Effective Code Generation in a {J}ust-{I}n-{T}ime {J}ava Compiler},
author = {Ali-Reza Adl-Tabatai and Michal Cierniak and Guei-Yuan Leuh and
Vihesh M. Parikh and James M. Stichnoth},
crossref = {PLDI98}
}

@techreport{aert81,
author = "J. P. H. Aerts",
title = "Implementing {SASL} Without Garbage Collection",
institution = "Eindhoven University of Technology",
type = "EUT Report",
number = "81--WSK--05",
year = "1981"}


@phdthesis{agar87,
author = "Anant Agarwal",
title = "Analysis of Cache Performance for Operating Systems and Multiprogramming",
school = "Stanford University",
address = "Palo Alto, CA",
note = "Available as Technical Report CSL-TR-87-332",
month = may,
year = 1987
}

@article{agar88,
author = "Agarwal, Anant and Mark Horowitz and John Hennessy",
title = "Cache Performance of Operating Systems and Multiprogramming Workloads",
journal = TransCompSys,
publisher = ACM,
volume = 6,
number = 4,
pages = "393--431",
month = Nov,
year = 1988 
}

@inproceedings{agga02,
title = {Software Caching \emph{vs.} Prefetching},
author = {Aneesh Aggarwal},
crossref = {ISMM02},
pages = {157--162}
}

@inproceedings{ages97,
author = {Ole Agesen and David Detlefs},
title = {Finding References in {J}ava Stacks},
crossref = "OOPSLA97-gc",
URL = {ftp://ftp.dcs.gla.ac.uk/pub/drastic/gc/detlefs.ps}
}

@inproceedings{ages98,
author = {Ole Agesen and David Detlefs and J. Eliot B. Moss},
title = {Garbage Collection and Local Variable Type-Precision and Liveness
in {J}ava {V}irtual {M}achines},
pages = {269--279},
crossref = {PLDI98}
}


@techreport{ages98a,
author = {Ole Agesen},
title = {{GC} Points in a Threaded Environment},
institution = {Sun Microsystems Laboratories},
address = {Palo Alto, CA},
number = {SMLI TR-98-70},
year = 1998,
URL = {http://research.sun.com/research/techrep/1998/smli_tr-98-70.pdf},
abstract = {Many garbage-collected systems, including most that involve
a stop-the-world phase, restrict GC to so-called GC points. In
single-threaded environments, GC points carry no overhead: when a GC
must be done, the single thread is already at a GC point. In
multi-threaded environments, however, only the thread that triggers the
GC by failing an allocation will be at a GC point. Other threads must
be rolled forward to their next GC point before the GC can take place.
We compare, in the context of a high-performance Java" virtual machine,
two approaches to advancing threads to a GC point, polling and code
patching, while keeping all other factors constant. Code patching
outperforms polling by an average of 4.7\% and sometimes by as much as
11.2\%, while costing only slightly more compiled code space. Put
differently, since most programs spend less than 1/5 of the time in GC,
a 4.7\% bottom-line speedup amounts to more than a 20\% reduction in
the GC-related costs. Patching is, however, more difficult to implement.}
}

@article{ages99,
author = {Ole Agesen},
title = {Space and Time-Efficient Hashing of Garbage-Collected Objects},
journal = {Theory and Practice of Object Systems},
volume = 5,
number = 2, 
pages = {119--124},
year = 1999,
URL = {http://www.sunlabs.com/research/java-topics/pubs/99-tapos.ps}
}

@inproceedings{ages00,
author = {Ole Agesen and Alex Garthwaite},
title = {Efficient Object Sampling Via Weak References},
crossref = {ISMM2000},
abstract = {
The performance of automatic memory management may be improved if he
policies used in allocating and collecting objects had knowledge of the
lifetimes of objects. To date, approaches to the pretenuring of objects in
older generations have relied on profile-driven feedback gathered from
trace runs. This feedback has been used to specialize allocation sites in a
program. These approaches suffer from a number of limitations. We
propose an alternative that through efficient sampling of objects allows for
on-line adaption of allocation sites to improve the efficiency of the memory
system. In doing so, we make use of a facility already present in many
collectors such as those found in Java(TM) virtual machines: weak
references. By judiciously tracking a subset of allocated objects with weak
references, we are able to gather the necessary statistics to make better
object-placement decisions. 
}
}

@inproceedings{aggo90,
author = "A. Aggoun and N. Beldiceanu",
title = "Time Stamps Techniques for the Trailed Data in Constraint Logic 
Programming Systems",
booktitle = {S\'{e}minaire de Programmation Logique de Tr\'{e}gastel, CNET, 
France},
pages = "487--509",
year = 1990,
}


@book{agha86,
author = "G. Agha",
title = "Actors: A Model of Concurrent Computation in Distributed Systems",
publisher = MIT,
year = 1986
}

@book{aho86,
author = "Alfred V. Aho and Ravi Sethi and Jeffrey D. Ullman",
title = "Compilers: Principles, Techniques and Tools",
publisher = AW,
year = 1986
}

@book{aho88,
author = "Alfred V. Aho and Brian W. Kernighan and Peter J. Weinberger",
title = "The {AWK} Programming Language",
publisher = AW,
year = 1988
}

@techreport{aike95,
title = {Better Static Memory Management: Improving Region-Based Analysis of Higher-Order Languages},
author = {Alex Aiken and Manuel F\"{a}hndrich and Raph Levien},
institution = {University of California at Berkeley},
URL = {http://www.cs.berkeley.edu/~aiken/ftp/region.ps},
year = 1995
}

@inproceedings{aike95a,
title = {Better Static Memory Management: Improving Region-Based Analysis of Higher-Order Languages},
author = {Alex Aiken and Manuel F\"{a}hndrich and Raph Levien},
pages = {174--185},
crossref = {PLDI95}
}


@incollection{ait91,
author = {Hassan A\"{i}t-Kaci},
title = "The {WAM}: A (Real) Tutorial",
booktitle = "Warren's {A}bstract {M}achine: A Tutorial Reconstruction",
publisher = MIT,
note = "Also Technical report 5, DEC Paris Research Laboratory, 1990",
year = 1991,
comment = "environment protection",
}

@manual{AIX,
title = "Subroutines Overview",
key = "AIX",
edition = "{G}eneral {P}rogramming {C}oncepts, {AIX} version 3.2",
organisation = IBM,
year = "version 3.2"
}



@article{akyu95,
author = {Sedat Aky\"{u}rek and Kenneth Salem},
title = "Adaptive Block Rearrangement",
journal = TransCompSys,
publisher = ACM,
volume = 13,
number = 2,
month = may,
year = 1995,
pages =	"95--121"
}

@article{alla91,
title = "Real-Time Programming in {C}ommon {L}isp",
author = "J. R. Allard and L. B. Hawkinson",
address = "Gensym Corp., 125 Cambridge Park Drive, Cambridge, Ma., 02140",
journal = CACM,
publisher = ACM,
year = 1991,
volume = 34,
number = 9,
pages = "64--69"
}


@article{alli89, 
title = "Circular Programs and Self-Referential Structures",
author = "L. Allison",
institution = "Monash University, Department of Computer Science, Clayton, Vic 3168, Australia",
journal = SPE,
publisher = Wiley,
year = 1989,
volume = 19,
number = 2,
pages = "99--109"
}

@phdthesis{alme80,
author = "Almes, Guy T.",
title = "Garbage collection in an Object-Oriented System",
publisher = "Carnegie-Mellon University, Department of Computer Science",
year = 1980,
school = CMU
}

@incollection{alme83,
author = "Guy Almes and A. Borning and E. Messinger",
title = "Implementing a {S}malltalk-80 System on the {I}ntel 432",
crossref = "Smalltalk-BHWA",
pages = "175--187",
}

@inproceedings{alon87,
author = {Noga Alon and Amnon Barak and Udi Mander},
title = {On disseminating information reliably without broadcasting},
booktitle = {Seventh International Conference on Distributed Computing Systems ICDCS97},
address = {Berlin},
editors = {R. Popescu-Zeletin and G. Lehann and K.H. Kim},
month = sep, 
year = 1987,
publisher = IEEE,
ISBN = {0-8186-0801-3}
}


@inproceedings{alon90,
title = "Advisor for Flexible Working Sets",
author = "R. Alonso and Andrew W. Appel",
booktitle = "Proceedings of the 1990 {ACM} {S}igmetrics Conference on 
Measurement and Modeling of Computer Systems",
address = "Boulder, CO",
month = may,
pages = "153--162",
year = 1990,
abstract = {The traditional model of virtual memory working sets does not
account for programs that can adjust their working sets on demand.  
Examples of such programs are garbage-collected systems and databases
with block cache buffers.  We present a memory-use model of such systems,
and propose a method that may be used by virtual memory managers to advise
programs on how to adjust their working sets.  Our method tries to minimize
memory contention and ensure better overall system response time.  We have
implemented a memory 'advice server' that runs as a non-privileged process
under Berkeley Unix.  User processes may ask this server for advice about
working set sizes, so as to take maximum advantage of memory resources.
Our implementation is quite simple, and has negligible overhead, and
experimental results show that it results in sizable performance improvements.}
}

@inproceedings{alpe99,
title = "Implementing {J}alape\~{n}o in {J}ava",
author = "Bowen Alpern and C R Attanasio and Anthony Cocchi and Derek Lieber and Stephen Smith and Ton Ngo and John J Barton and Susan Flynn Hummel and Janice C Shepherd and Mark Mergen",
booktitle = "Proceedings of the {ACM} Conference on Object-Oriented Systems, Languages and Applications",
address = "Denver, CO",
volume = "34(10)",
month = oct,
year = 1999,
pages = {314--324},
URL = {http://www.acm.org/pubs/articles/proceedings/oops/320384/p314-alpern/p314-alpern.pdf}
}

@article{alpe00,
Author = {Bowen Alpern and Dick Attanasio and John J. Barton and M.  G. 
Burke and Perry Cheng and J.-D. Choi and Anthony Cocchi 
and Stephen J. Fink and David Grove and Michael Hind and Susan Flynn Hummel and
D. Lieber and V. Litvinov and Mark Mergen and Ton Ngo and 
J. R. Russell and Vivek Sarkar and Manuel J. Serrano and Janice Shepherd 
and S. Smith and V. C. Sreedhar and H.  Srinivasan and J. Whaley },
title =   {The {J}alape\~{n}o Virtual Machine},
journal =   ISJ,
year =   2000,
volume =  39,
number =  1,
month =  feb, 
URL = {http://www.research.ibm.com/journal/sj/391/alpern.pdf}
}

@inproceedings{alpe02,
title = {Experiences Porting the {J}ikes {RVM} to {L}inux/{IA}32},
author = {Bowen Alpern and Maria Butrico and Anthony Cocchi and Julian Dolby and Stephen Fink and David Grove and Ton Ngo},
crossref = {JVM02},
URL = {http://www.research.ibm.com/people/d/dgrove/papers/jvm01.pdf},
abstract = {This paper describes our experiences in porting the Jikes
Research Virtual Machine from its first platform, AIX/PowerPC, to its
second, Linux/IA32. We discuss the main issues in realizing both an
initial functional port, and then tuning efforts to achieve competitive
performance. The paper presents software engineering issues in building
a portable runtime system and compilers, as well as specific
optimizations to improve performance on IA32. }
}

@inproceedings{amam83,
title = "List Processing with a Data Flow Machine",
author = "M. Amamiya and R. Hasegawa and H. Mikami",
booktitle = "Proceedings of RIMS Symposia on Software Science and Engineering, 
1980--1982",
address = "Kyoto",
series = LNCS,
volume = 147,
publisher = SV,
pages = "165--190",
year = "1983",
abstract = {This paper discussed some issues in list processing within the
context of a data flow control environment, and from the viewpoint of
parallelism.  The basic philosophy behind the data flow machine architecture
presented in this paper is that highly parallel execution can be achieved by
data flow control concept, both at the primitive operation level and at the
function activation level.  The mechanism of partial execution for each
function was shown through some examples including an Lisp interpreter
implementation, to be effective for exploitation of the parallelism in list
processing.  The lenient cons mechanism was shown through analysis of two
programs, to be effective for maximally exploiting parallelism.  A garbage
collection mechanism based on the referenced count method was also 
described.}
}

@techreport{amsa94,
author = "Laurent Amsaleg and Michael Franklin and Olivier Gruber",
title = "Efficient Incremental Garbage Collection for Workstation/Server
Database Systems",
institution = "University of Maryland",
number = "CS--TR--3370",
month = nov,
year = 1994,
URL = "ftp://ftp.cs.umd.edu/pub/papers/papers/ncstrl.umcp/CS-TR-3370",
abstract = " We describe an efficient server-based algorithm for garbage
collecting object-oriented databases in a workstation/server environment.
The algorithm is incremental and runs concurrently with client
transactions, however, it does not hold any locks on data and does not
require callbacks to clients. It is fault tolerant, but performs very
little logging. The algorithm has been designed to be integrated into
existing OODB systems, and therefore it works with standard
implementation techniques such as two-phase locking and
write-ahead-logging. In addition, it supports client-server performance
optimizations such as client caching and flexible management of client
buffers. We describe an implementation of the algorithm in the EXODUS
storage manager and present results from an initial performance study of
the implementation. These results demonstrate that the introduction of
the garbage collector adds minimal overhead to client operations.",
note = "Also University of Maryland Institute for Advanced Computer Studies
report UMIACS-TR-94-121"
}

@inproceedings{amsa95,
author = "Laurent Amsaleg and Michael Franklin and Olivier Gruber",
title = "Efficient Incremental Garbage Collection for Client--Server Object Database Systems",
booktitle = "Twenty-first International Conference on Very Large Databases (VLDB95)",
address = "Zurich, Switzerland",
month = sep,
year = 1995,
URL = {http://www.cs.umd.edu/users/franklin/papers/vldbgc.ps.gz}
}

@inproceedings{amsa95a,
author = "Laurent Amsaleg and Paulo Ferreira and Michael Franklin and Marc Shapiro",
title = "Evaluating Garbage Collectors for Large Persistent Stores",
booktitle = "OOPSLA'95 Workshop on Object Database Behavior, Benchmarks, and Performance",
address = "Austin, TX",
month = oct,
year = 1995,
URL = "http://www-sor.inria.fr/SOR/docs/EGCLPS_oopsla95ws.html"
}

@article{amst00,
author = {Jonathan Amsterdam},
title = {Use Object Pools to Sidestep Garbage Collection},
journal = {Java Report},
month = sep,
year = 2000,
pages = {120-119 (really)},
comment = {Articles like this are a good indication of how much work there
is to be done educating developers and `Java training and consulting firms'.}
}

@inproceedings{ande87,
author = "Wayne Anderson and William Galway and Robert Kessler and Herbert 
melenk and Winfried Neun",
title = "The Implementation and Optimisation of {P}ortable {S}tandard 
{L}isp for the {C}ray",
booktitle = "20th Annual Hawaii International Conference on Science Systems",
year = 1987,
month = jan
}

@manual{ANSI-C,
title = "{A}merican {N}ational {S}tandard for {I}nformation {S}ystems: 
{P}rogramming Language {C}",
key = "ANSI-C",
organization = "American National Standards Institute",
number = "X3.159--1989",
month = dec,
year = 1989
}

@manual{ANSI-C++,
title = "{D}raft {P}roposed {I}nternational {S}tandard for {I}nformation 
{S}Systems:
{P}rogramming Language {C++}",
key = "ANSI-C++",
organization = "ANSI document X3J16/95--0087, ISO document WG21/N0618",
month = apr,
year = 1995
}
% key = "ANSI-C++, 1993",
% organization = "ANSI document X3J16/93--0010, ISO document WG21/N0218",
% month = jan,
% year = 1993

@inproceedings{ande91,
author = "Thomas E. Anderson and Henry M. Levy and Brian N. Bershad
and Edward D. Lazowska",
title = "The Interaction of Architecture and Operating Systems Design",
crossref = "ASPLOS91",
pages = "108--120",
}


@mastersthesis{andr86,
author = "Andre, David L.",
title = "Paging in {L}isp Programs",
school = "University of Maryland",
address = "College Park, Maryland",
year = 1986
}

@inproceedings{andr02,
title = {Memory Management Through Machine Learning: To Collect or Not to Collect?},
author = {Eva Andreasson and Frank Hoffmann and Olof Lindholm},
crossref = {JVM02},
URL = {http://www.usenix.org/events/jvm02/andreasson.html}
}

@article{appe87,
title = "Garbage Collection can be Faster than Stack Allocation",
author = "Andrew W. Appel",
address = PRINCETON,
journal = IPL,
publisher = NH,
year = 1987,
volume = 25,
number = 4,
pages = "275--279",
URL = "http://www.cs.princeton.edu/fac/~appel/papers/45.ps",
abstract = {An old and simple algorithm for garbage collection gives very good
results when the physical memory is much larger than the number of 
reachable cells. 
In fact, the overhead associated with allocating and collecting cells
from the heap can be reduced to less than one instruction per cell by
increasing the size of physical memory.  Special hardware, intricate 
garbage-collection algorithms, and fancy compiler analysis become unnecessary.},
comment = {A rebuttal of this argument can be found in \cite{mill94}.}
}


@article{appe88,
title = "Real-Time Concurrent Collection on Stock Multiprocessors",
author = "Andrew W. Appel and John R. Ellis and Kai Li",
address = PRINCETON  # " and Digital Equipment Corp, Systems Research Center, Palo Alto, CA",
journal = Sigplan,
publisher = ACM,
year = 1988,
volume = 23,
number = 7,
pages = "11--20",
comment = "Not ``real'' real-time, but a very cool algorithm. (Paul Wilson)
Augustsson recommends this one.
Uses VM access protection as a coarse approximation of Baker's write barrier.
Mutator is not allowed to see any page that might contain a pointer to
fromspace.
Pointers in scanned area of tospace are guaranteed to point into tospace.
Ant pointers from fromspace to tospace must be in the unscanned area (gray).
When mutator accesses a protected page, a trap handler scans the whole
page,fixing up pointers.
Fails to provide meaningful real-time guarantees in the general case,
but is concurrent and greatly reduces the cost of the read barrier."
}


@techreport{appe88a,
author = "Andrew W. Appel and Aage Bendiksen",
title = "Vectorized Garbage Collection",
institution = princeton,
number = "CS-TR-169-88",
year = 1988,
month = jul,
comment = "Can get useful speedup by vectorising GC operations"
}


@techreport{appe88b,
author = "Andrew W. Appel",
title = "Allocation without Locking",
institution = princeton,
number = "CS-TR-182-88",
year = 1988,
month = sep
}

@techreport{appe88c,
author = "Appel, Andrew W. and Duba, Bruce F. and MacQueen, David B.",
title = "Profiling in the Presence of Optimization and Garbage Collection",
year = 1988,
institution = princeton,
number = "CS-TR-197-88",
month = Nov
}


@techreport{appe88d,
author = "Appel, Andrew W. and Hanson, David R.",
title = "Copying Garbage Collection in the Presence of Ambiguous References",
institution = princeton,
year = 1988,
number = "CS-TR-162-88"
}

@article{appe89,
title = "Simple Generational Garbage Collection and Fast Allocation",
author = "Andrew W. Appel",
institution = princeton,
journal = SPE,
publisher = Wiley,
year = 1989,
volume = 19,
number = 2,
pages = "171--183",
URL = "http://www.cs.princeton.edu/fac/~appel/papers/143.ps",
abstract = {Generational garbage collection algorithms achieve efficiency
because newer records point to older records; the only way an older record 
can point to a newer record is by a store operation to a previously created 
record, and such operations are rare in many languages.  A garbage collector
that concentrates just on recently allocated records can take advantage of this 
fact.  Such a garbage collector can be so efficient that the allocation of
records costs more than their disposal.  A scheme for quick record allocation 
attacks this bottleneck.  Many garbage-collected environments do not know when 
to ask the operating system for more memory.  A robust heuristic solves this 
problem.  This paper presents a simple, efficient, low-overhead version of 
generational garbage collection with fast allocation, suitable for
implementation in a Unix environment.}
}


@article{appe89a,
title = "Allocation Without Locking",
author = "Andrew W. Appel",
institution = princeton,
journal = SPE,
publisher = Wiley,
year = 1989,
volume = 19,
number = 7,
note = "Short Communication",
abstract = "...This paper shows how allocation can run extremely quickly
even in a multi-thread environment: open-coded, without locking",
}


@article{appe89b,
title = "Runtime Tags Aren't Necessary",
author = "Andrew W. Appel",
address = princeton,
journal = LSC,
year = 1989,
volume = 2,
pages = "153--162",
comment = "For a purely statically-typed language, no per-object runtime type
information is necessary, except the types of the root set variables."
}

@article{appe89c,
author = "Appel, Andrew W.  and Bendiksen, Aage",
title = "Vectorized Garbage Collection",
journal = "The Journal of Supercomputing",
volume = 3,
pages = "151--160",
URL = "http://www.cs.princeton.edu/fac/~appel/papers/169.ps",
year = 1989
}

@article{appe90,
author = "Andrew W. Appel",
title = "A Runtime System",
journal = LSC,
volume = 3,
year = 1990,
pages = "343--380"
}



@article{appe91,
title = "Virtual Memory Primitives for User Programs",
author = "Andrew W. Appel and Kai Li",
address = princeton,
journal = Sigplan,
year = 1991,
volume = 26,
number = 4,
pages = "96--107",
URL = {http://ncstrl.cs.Princeton.EDU/expand.php?id=TR-276-90}
}


@incollection{appe91a,
author = "Andrew W. Appel",
title = "Garbage Collection",
booktitle = "Topics in Advanced Language Implementation",
editor = "Peter Lee",
pages = "89--100",
publisher = MIT,
year = 1991
}


@inproceedings{appe92,
title = "Compilers and Runtime Systems for Languages with Garbage Collection",
author = "Andrew W. Appel",
crossref = "PLDI92",
comment = "TUTORIAL:
Appel spent most of the time talking about Garbage
Collection and Data Representation issues covered by his papers and
book.  He had McCarthy's 1960 description of Mark and Sweep on a single
slide, pointing out that publications were much more terse 30 years
ago.  He claims that Garbage Collectors are already ``down in the
noise'' today, but that they now should start improving mutator
performance to earn their keep.	 On Compiler Issues, he suggests that
language specifications should stipulate what is live data, and have
the collector guarantee a limit near that.  His case study was SML/NJ
but he had run out of time."
}

@inbook{appe92a,
author = "Andrew W. Appel",
title = "Compiling with Continuations",
chapter = 16,
publisher = CUP,
pages = "205--214",
year = 1992
}

@techreport{appe93,
author = "Andrew W. Appel and Marcelo J. R. Gon\c{c}alves",
title = "Hash-consing Garbage Collection",
institution = princeton,
number = "CS-TR-412-93",
month = feb,
year = 1993,
URL = {http://ncstrl.cs.Princeton.EDU/expand.php?id=TR-412-93}
}

@techreport{appe94,
author = "Andrew W. Appel and Zhong Shao",
title = "An Empirical and Analytic Study of Stack vs. Heap Cost for Languages with Closures",
institution = princeton,
number = "CS--TR--450--94",
month = mar,
year = 1994,
URL = {http://ncstrl.cs.Princeton.EDU/expand.php?id=TR-450-94}
}

@techreport{appe94a,
title = {Emulating Write-Allocate on a No-Write-Allocate Cache},
author = {Andrew W. Appel},
institution = princeton,
number = {TR-459-94},
month = jun,
year = 1994,
URL = {http://ncstrl.cs.Princeton.EDU/expand.php?id=TR-459-94},
abstract = {A cache write-miss policy of write-allocate leads to better
performance for many programs than a policy of no-write-allocate. I show
a compiling technique to emulate a write-allocate policy even on a
no-write-allocate machine, if that machine has non-blocking cache read
misses (e.g. DEC Alpha 21064). The trick is to pre-fetch garbage before
the write, so that the cache line will be allocated and the write will
hit the cache.  Measurements show a factor-of-1.2 improvement in execution
time. 
}
}

@article{appe95,
author = "Andrew W. Appel and Zhong Shao",
title = "An Empirical and Analytic Study of Stack vs. Heap Cost for Languages with Closures",
journal = JFP,
year = 1995,
URL = "ftp://daffy.cs.yale.edu/pub/papers/shao/stack.ps"
}

@article{appe96,
title = "Empirical and analytic study of stack versus heap cost for languages with closures",
author = "Andrew W. Appel and Zhong Shao",
pages = "47--74",
journal = JFP,
month = jan,
year = 1996,
volume = 6,
number = 1
}

@book{appe97,
author = "Andrew W. Appel",
title = "Modern Compiler Implementation in {ML}: Basic Techniques",
publisher = CUP,
ISBN = "0-521-58775-1",
URL = "http://www.cup.org/Titles/58/052158275X.html",
year = 1997
}

@book{appe97a,
author = "Andrew W. Appel",
title = "Modern Compiler Implementation in {C}: Basic Techniques",
publisher = CUP,
ISBN = "0-521-58653-4",
URL = "http://www.cup.org/Titles/58/0521583896.html",
year = 1997
}

@book{appe97b,
author = "Andrew W. Appel",
title = "Modern Compiler Implementation in {J}ava: Basic Techniques",
publisher = CUP,
ISBN = "0-521-58654-2",
URL = "http://www.cup.org/Titles/58/0521583896.html",
year = 1997
}

@misc{appe97c,
author = {Andrew W. Appel},
title = {A Better Analytical Model for the Strong Generational
Hypothesis},
month = nov,
year = 1997,
note = {Cited by \cite{stef99}.}
}

@book{appe98,
author = "Andrew W. Appel",
title = "Modern Compiler Implementation in {ML}",
publisher = CUP,
ISBN = "0-521-52745-1",
year = 1998
}

@book{appe98a,
author = "Andrew W. Appel",
title = "Modern Compiler Implementation in {C}",
publisher = CUP,
ISBN = "0-521-58390-X",
year = 1998
}

@book{appe98b,
author = "Andrew W. Appel",
title = "Modern Compiler Implementation in {J}ava",
publisher = CUP,
ISBN = "0-521-58388-8",
year = 1998
}

@article{appl88,
title = "Garbage Collection for {P}rolog based on {WAM}",
author = "Karen Appleby and Mats Carlsson and Seif Haridi and Dan Sahlin",
address = "IBM Corp, Thomas J Watson Res Ctr, Yorktown Hts, Ny, 10598 
Swedish Inst Comp Sci, S--16428 Kista, Sweden",
journal = CACM,
publisher = ACM,
year = 1988,
volume = 31,
number = 6,
pages = "719--741",
abstract = {The Warren abstract machine (WAM) has become a generally accepted
standard Prolog implementation technique.  Garbage collection is an important
aspect in the implementation of any Prolog system.  A synopsis of the WAM is
presented and then marking and compaction algorithms are shown that take
advantage of WAM's unique use of the data areas.  Marking and compaction are
performed on both the heap and the trail; both use pointer reversal techniques,
which obviate the need for extra stack space.  However, two bits for every
pointer on the heap are reserved for the garbage collection algorithm.  The
algorithm can work on segments of the heap, which may lead to a significant
reduction of the total garbage collection time.  The time of the algorithms 
are linear in the size of the areas.}
}


@article{arnb72,
author = "Stefan Arnborg",
title = "Storage Administration in a Virtual Memory Simulation System",
journal = "BIT",
volume = 12,
number = 2,
year = 1972,
pages = "125--141",
}


@article{arnb74,
author = "Stefan Arnborg",
title = "Optimal Memory Management in a System with Garbage Collection",
journal = "BIT",
volume = 14,
number = 4,
year = 1974,
pages = "375--381",
}

@book{arms93,
author = "Joe Armstrong and Robert Virding and Mike Williams",
title = {Concurrent Programming in {ERLANG}},
publisher = PH,
year = 1993
}

@inproceedings{arms95,
title = "One-Pass Real-Time Generational Mark-Sweep Garbage Collection",
author = "Joe Armstrong and Robert Virding",
address = "Computer Science Laboratory, Ellemtel Telecommunications Systems Labo
ratories, Alvsjo, Sweden",
crossref = "IWMM95",
URL = {http://citeseer.nj.nec.com/armstrong95one.html}
}

@inproceedings{asse93,
author = {Holger Assenmacher and Thomas Breitbach and Peter Buhler and Volker H\"{u}bsch and Reinhard Schwarz},
title = "{PANDA} --- Supporting Distributed Programming in {C++}",
crossref = "ECOOP93", 
pages = "361--383",
abstract = "PANDA is a run-time package based
on a very small operating system kernel which supports distributed
applications written in C++. It provides powerful abstractions such
as very efficient user-level threads, a uniform global address
space, object and thread mobility, garbage collection, and
persistent objects. The paper discusses the design rationales
underlying the PANDA system. The fundamental features of PANDA are
surveyed, and their implementation in the current prototype
environment is outlined."
}

@article{atki88,
title = "The Active Deallocation of Objects in Object-Oriented Systems",
author = "Martin C. Atkins and Lee R. Nackman",
institution = "{IBM} Corp., Thomas J Watson Research Center, Dept Mfg Res, Yorktown Heights, NY",
journal = SPE,
publisher = Wiley,
year = 1988,
volume = 18,
number = 11,
pages = "1073--1089"
}

@phdthesis{atki89,
title = "Implementation Techniques for Object-Oriented Systems",
author = "Martin Atkins",
school = "University of York",
month = jun,
year = 1989
}

@article{atki83,
author = {Malcolm P. Atkinson and P.J. Bailey and K.J. Chisholm and W.P. Cockshott and Ron Morrison},
title = {An Approach to Persistent Programming},
journal = CompJ,
publisher = BCS,
volume = 26,
number = 4,
pages = {360--365},
month = dec,
year = 1983
}

@article{atki85,
title = "Procedures as Persistent Data Objects",
author = "Malcolm P. Atkinson and Ronald Morrison",
pages = "539--559",
journal = toplas,
publisher = ACM,
year = 1985,
month = oct,
volume = 7,
number = 4
}

@inproceedings{atki89a,
author = "Russ Atkinson and Alan Demers and Carl Hauser and Christian
Jacobi and Peter Kessler and Mark Weiser",
title = "Experiences Creating a Portable Cedar",
crossref = "PLDI89",
pages = "322--329",
}

@inproceedings{atta01,
title = {A Comparative Evaluation of Parallel Garbage Collectors},
author = {Clement R. Attanasio and David F. Bacon and Anthony Cocchi and Stephen Smith},
booktitle = {Fourteenth Annual Workshop on Languages and Compilers for Parallel Computing},
address = {Cumberland Falls, KT},
series = LNCS,
publisher = SV,
month = aug,
year = 2001,
URL = {http://www.research.ibm.com/people/d/dfb/papers/Attanasio01Comparative.ps},
abstract = {Describes a suite of garbage collectors we implemented in
the IBM Jalapeo Java Virtual Machine, and quantitatively evaluates the
relative performance of the different collectors. With large amounts of
available memory, a generational semi-space copying collector performs
best. But a hybrid collector that uses a copying semi-space for the
young generation and a mark-and-sweep collector for the old generation
can run at close to the same speed in half the memory of other
collectors, thereby doubling the potential transaction throughput.
}
}

@techreport{atta94,
author = "Giuseppe Attardi and Tito Flagella",
title = "A Customisable Memory Management Framework",
institution = " International Computer Science Institute, Berkeley",
year = 1994,
number = "TR-94-010",
URL = "ftp://ftp.icsi.berkeley.edu:/pub/techreports/1994/tr-94-010.ps.Z",
note = "Also Proceedings of the {USENIX} {C++} Conference, Cambridge, MA, 1994"
}

@inproceedings{atta94a,
author = "Giuseppe Attardi and Tito Flagella",
title = "A Customisable Memory Management Framework",
crossref = "ECOOP84",
pages = "320--343"
}

@inproceedings{atta95,
title = "Performance Tuning in a Customizable Collector",
author = "Giuseppe Attardi and Tito Flagella and Pietro Iglio",
address = "Dipartimento di Informatica, Universita di Pisa",
crossref = "IWMM95",
}

@article{atta96,
title = {Memory Management in the {PoSSo} Solver},
author = {Giuseppe Attardi and Tito Flagella},
journal = {Journal of Symbolic Computation},
volume = 21,
number = 3,
pages = {293--311},
year = 1996
}

@article{atta98,
title = {A Customisable Memory Management Framework for {C++}},
author = "Giuseppe Attardi and Tito Flagella and Pietro Iglio",
journal = SPE,
month = nov,
year = 1998,
volume = 28,
number = 11,
pages = {1143--1183},
URL = {ftp://ftp.di.unipi.it/pub/Papers/attardi/SPE.ps.gz},
abstract = {Automatic garbage collection relieves programmers from the burden of
managing memory themselves and several techniques have been developed
that make garbage collection feasible in many situations, including
real time applications or within traditional programming
languages. However optimal performance cannot always be achieved by a
uniform general purpose solution.  Sometimes an algorithm exhibits a
predictable pattern of memory usage that could be better handled
specifically, delaying as much as possible the intervention of the
general purpose collector.  This leads to the requirement for
algorithm specific customisation of the collector strategies.  We
present a dynamic memory management framework which can be customised
to the needs of an algorithm, while preserving the convenience of
automatic collection in the normal case.  The Customisable Memory
Manager (CMM) organises memory in multiple heaps.  Each heap is an
instance of a C++ class which abstracts and encapsulates a particular
storage discipline.  The default heap for collectable objects uses the
technique of mostly copying garbage collection, providing good
performance and memory compaction.  Customisation of the collector is
achieved exploiting object orientation by defining specialised
versions of the collector methods for each heap class.  The object
oriented interface to the collector enables coexistence and
coordination among the various collectors as well as integration withtraditional code unaware of garbage collection.  The CMM is
implemented in C++ without any special support in the language or the
compiler.  The techniques used in the CMM are general enough to be
applicable also to other languages.  The performance of the CMM is
analysed and compared to other conservative collectors for C/C++ in
various configurations.}
}

@book{auge79,
author = "Moshe J. Augenstein and Aaron M. Tenenbaum",
title = "Data Structures using Pascal",
edition = "Second",
publisher = "Prentice-Hall", 
address = "Englewood Cliffs, N. J.",
year = 1986,  
comments = {book with sections on garbage collection},
}


@inproceedings{augu87,
title = "Garbage Collection in a Distributed Environment",
author = "Lex Augusteijn",
institution = "Philips Res Labs, Eindhoven, Netherlands",
crossref = "PARLE87",
pages = "75--93",
comment = "on-the-fly garbage collection, mark-sweep, termination
detection."
}


@inproceedings{augu84,
author = "Lennart Augustsson",
title = "A Compiler for Lazy {ML}",
pages = "218--227",
crossref = "LFP84",
}

@inproceedings{aust94,
author = "Todd M. Austin and Scott E. Breachand Gurindar S. Sohi",
title = "Efficient Detection of all Pointer and Array Access Errors",
crossref = "PLDI94",
pages = "290--301"
}

@article{axfo90,
title = "Reference Counting of Cyclic Graphs for Functional Programs",
author = "Thomas H. Axford",
address = "University Birmingham, Birmingham B15 2tt, W Midlands, England",
journal = CompJ,
publisher = BCS,
year = 1990,
volume = 33,
number = 5,
pages = "466--470"
}

@inproceedings{azag98,
author = {Alain Azagury and Elliot K. Kolodner and Erez Petrank and Zvi Yehudai},
title = {Combining Card Marking with Remembered Sets: How to Save Scanning Time},
pages = {10--19},
crossref = {ISMM98},
URL = {http://www.cs.technion.ac.il/~erez/publications.html},
abstract = {We consider the combination of card marking with remembered
sets for generational garbage collection as suggested by Hosking and
Moss. When more than two generations are used, a naive implementation
may cause excessive and wasteful scanning of the cards and thus
increase the collection time. We offer a simple data structure and a
corresponding algorithm to keep track of which cards need be scanned
for which generation. We then extend these ideas for the Train
Algorithm of Hudson and Moss. Here, the solution is more involved, and
allows tracking of which card should be scanned for which
car-collection in the train. }
}

@article{azag99,
author = {Alain Azagury and Elliot K. Kolodner and Erez Petrank},
title = {A Note on the Implementation of Replication-Based Garbage Collection for
Multithreaded Applications and Multiprocessor Environments},
journal = {Parallel Processing Letters},
year = 1999,
URL = {http://www.cs.technion.ac.il/~erez/publications.html}
}

@inproceedings{azat03,
author = {Hezi Azatchi and Yossi Levanoni and Harel Paz and Erez Petrank},
title = {An On-The-Fly Mark and Sweep Garbage Collector Based on SLiding View},
URL = {http://www.cs.technion.ac.il/~erez/publications.html},
crossref = {OOPSLA03}
}

@inproceedings{azat03a,
title = "Integrating Generations with Advanced Reference Counting Garbage Collectors",
author = "Hezi Azatchi and  Erez Petrank",
pages = "185--199",
address = "Warsaw, Poland",
booktitle = "Proceedings of the Compiler Construction: 12th International Conference on Compiler Construction, CC 2003",
year = 2003,
month = may,
publisher = "Springer-Verlag Heidelberg",
series = "Lecture Notes in Computer Science",
volume = "2622",
}

@article{baba83,
author = "Babaoglu, Ozalp and Domenico Ferrari",
title = "Two-Level Replacement Decisions in Paging Stores",
journal = IEEETransComp,
publisher = IEEE,
volume = "C-32",
number = 12,
month = dec,
year = 1983,
pages = {1151--1159}
}

@incollection{baba93,
author = {Babaoglu, Ozalp and Keith Marzullo},
title = {Consistent Global States of Distributed Systems: Fundamental Concepts and Mechanisms},
booktitle = {Distributed Systems},
editor = {S. Mullender},
publisher = AW,
pages = {55--96},
year = 1993
}


@inproceedings{back83,
title = "Derivation of Efficient {DAG} Marking Algorithms",
author = {R. J. R. Back and Heikki Mannila and Kari-Jouko R\"{a}ih\"{a}},
pages = "20--27",
crossref = "POPL83"
}

@inproceedings{baco01,
title = {Java Without the Coffee Breaks: A Nonintrusive Multiprocessor Garbage Collector},
author = {David F. Bacon and Clement R.  Attanasio and Han B. Lee and V. T. Rajan and Stephen Smith},
crossref = {PLDI01}
}

@inproceedings{baco01a,
title = {Concurrent Cycle Collection in Reference Counted Systems},
author = {David F. Bacon and V.T. Rajan},
crossref = {ECOOP01}
}

@inproceedings{baco03,
title = {A Real-Time Garbage Collecor with Low Overhead and Consistent Utilization},
author = {David F. Bacon and Perry Cheng and V.T. Rajan},
crossref = {POPL03}
}

@inproceedings{baco03a,
title = {Controlling Fragmentation and Space Consumption in the {M}etronome, a Real-time 
Garbage Collector for {J}ava},
author = {David F. Bacon and Perry Cheng and V.T. Rajan},
pages =        "81--92",
crossref = {LCTES03}
}

@mastersthesis{bade82,
author = "Scott B. Baden",
title = "High Performance Reclamation in an Object-Based Memory System",
school = "Computer Science Division, Department of EECS, University of 
California, Berkeley",
year = 1982,
month = jun
}

@incollection{bade83,
author = "Scott B. Baden",
title = "Low-Overhead Storage Reclamation in the {S}malltalk-80 Virtual Machine",
crossref = "Smalltalk-BHWA",
pages = "331--342",
comment = "Reference counting: don't count references from roots -- reduces
manipulations by 90 percent and RC time by half"
}

@techreport{bade84,
author = "Baden, Scott B.",
title = "High Performance Storage Reclamation in an Object-Based Memory System",
institution = "University of California, Berkeley",
type = "CSD",
year = 1984,
number = "84-167",
}



@article{baec70,
author = "H. D. Baecker",
title = "Implementing  the {A}lgol--68 Heap",
journal = "BIT",
volume = 10,
number = 4,
year = 1970,
pages = "405--414",
comment = "Proposes adding areas or regions to Algol-68. Each region maintains
a table of objects that reside in the region."
}


@article{baec72,
author = "H. D. Baecker",
title = "Garbage Collection for Virtual Memory Computer Systems",
journal = CACM,
publisher = ACM,
volume = 15,
number = 11,
month = Nov,
year = 1972,
pages = "981--986",
}

@article{baec73,
title = "Aspects of Reference Locality in List Structures in Virtual Memory",
author = "H. D. Baecker",
journal = SPE,
publisher = Wiley,
volume = 3,
number = 3,
year = 1973,
pages = "245--254"
}


@article{baec75,
author = "H. D. Baecker",
title = "Areas and Record Classes",
journal = CompJ,
publisher = BCS,
volume = 18,
number = 3 ,
month = Aug,
year = 1975,
pages = "223--226",
}


@article{baer76,
author = "Baer, Jean-Loup and Sager, Gary R.",
title = "Dynamic Improvement of Locality in Virtual Memory Systems",
journal = IEEETransSWE,
publisher = IEEE,
volume = "SE-2",
number = 1,
month = mar,
pages = {54-62},
year = 1976
}


@inproceedings{baer77,
author = "Jean-Loup Baer and M. Fries",
title = "On the Efficiency of some List Marking Algorithms",
pages = "751--6",
booktitle = "Information Processing 77, Toronto",
month = aug,
editor = "B. Gilchrist",
publisher = "North-Holland",
year = 1977
}

@phdthesis{bagh87,
author = "Bagherzadeh, Nader",
title = "Distributed Resource Management: Garbage Collection",
year = 1987,
school = "University of Texas at Austin"
}

@article{bagh91,
author = "Bagherzadeh, Nader and Heng, S-l. and Wu, C-l.",
title = "A Parallel Asynchronous Garbage Collection Algorithm for Distributed Systems",
journal = "IEEE Transactions on Knowledge and Data Engineering",
publisher = IEEE,
volume = 3,
number = 1,
month = mar,
pages = "100--107",
year = 1991
}

@book{bail75,
author = {Norman T.J.Bailey},
title = {The Mathematical Theory of Infectious Diseases and its Applications},
publisher = {Griffin},
edition = {2nd},
year = 1975,
ISBN = {0-8564264-231-8}
}

@article{bake85,
author = "Baker, Brenda and E. G. Coffman and D. E. Willard",
title = "Algorithms for Resolving Conflicts in Dynamic Storage Allocation",
journal = JACM,
publisher = ACM,
volume = 32,
number = 2,
pages = "327--343",
year = 1985,
month = apr
}


@techreport{bake77,
author = "Baker, Henry G. and Hewitt, Carl E.",
title = "The Incremental Garbage Collection of Processes",
institution = MIT,
year = 1977,
month = dec,
type = "AI memo",
number = "454"
}

@article{bake77a,
author = "Baker, Henry G. and Hewitt, Carl E.",
title = "The Incremental Garbage Collection of Processes",
journal = SIGPLAN,
publisher = ACM,
volume = 12,
number = 8,
pages = "55--59",
month = aug,
year = 1977,
URL = "http://home.pipeline.com/~hbaker1/Futures.ps.Z",
abstract = "An early discussion of the concept of 'futures' in a parallel functional programming language.
Naively uses 'reachability' for eliminating garbage processes, which is now known to be insufficient in the
presence of shared cells with assignment."
}

@article{bake78,
author = "Henry G. Baker",
title = "List Processing in Real-Time on a Serial Computer",
journal = CACM,
publisher = ACM,
volume = 21,
number = 4,
pages = "280--94",
year = "1978",
comment = "The best known real-time incremental copying gc.  Uses a read barrier.",
URL = "http://home.pipeline.com/~hbaker1/RealTimeGC.ps.Z"
}


@techreport{bake78a,
author = "Henry G. Baker",
title = "Actor Systems for Real-Time Computation",
institution = "Laboratory for Computer Science",
number = "MIT Rep. TR--197",
month = Mar,
year = 1978,  
URL = "ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/listings/abstracts/TR-197.html",
}

@incollection{bake79,
author = "Henry G. Baker",
title = "Optimizing Allocation and Garbage Collection of Spaces in {M}acL{L}isp",
booktitle = "Artificial Intelligence: An MIT Perspective",
editor = "Winston and Brown",
publisher = MIT,
year = 1979,
URL = "http://home.pipeline.com/~hbaker1/OptAlloc.ps.Z",
abstract = "How to allocate the sizes of the various spaces in 'big bag of pages' (BIBOP) garbage collection
systems"
}


@techreport{bake80,
author = "Baker, Henry G.",
title = "The Paging Behavior of the {Cheney} List Copying Algorithm",
institution = "University of Rochester Computer Science Department",
year = 1980
}

@techreport{bake89,
author = "Henry G. Baker",
title = "Garbage Collection in {A}da",
institution = "Ada Joint Program Office",
type = "Ada-9X Revision Request",
number = 643,
year = 1989,
month = oct
}

@inproceedings{bake90,
author = "Henry G. Baker",
title = "Unify and Conquer (Garbage, Updating, Aliasing, \ldots) in Functional Languages",
crossref = "LFP90",
pages = "218--226",
}

@inproceedings{bake91,
author = "Baker, Henry G.",
title = "Cache-Conscious Copying Collection",
crossref = "OOPSLA91-gc",
URL = "http://home.pipeline.com/~hbaker1/CacheCGC.ps.Z",
}


@article{bake92,
author = "Baker, Henry G.",
title = "The Buried Binding and Dead Binding Problems of {Lisp} 1.5:
Sources of Incomparability in Garbage Collector Measurements",
journal = "Lisp Pointers",
publisher = ACM,
volume = 4,
number = 2,
pages = "11--19",
month = apr,
year = 1992
}

@article{bake92a,
title = "The {T}readmill, Real-time Garbage Collection without Motion Sickness",
author = "Henry G. Baker",
journal = SIGPLAN,
publisher = ACM,
volume = 27,
number = 3,
pages = "66--70",
month = Mar,
year = 1992,
URL = "http://home.pipeline.com/~hbaker1/NoMotionGC.ps.Z",
comment = {
Incremental non-copying GC with some of the advantages of a copying scheme.
Objects are held in a doubly-linked list and each has a "colour"
to indicate which (logical) space it is a member of.
Clever.
Doesn't deal with fragmentation.}
}

@article{bake92b,
author = "Henry  G. Baker",
title = "Lively Linear {Lisp} --- `{Look} {Ma}, No Garbage!'",
journal = SIGPLAN,
publisher = ACM,
volume = 27,
number = 9,
pages = "89--98",
month = aug,
year = 1992
}

@inproceedings{bake92c,
title = "Thermodynamics of Garbage Collection",
author = "Henry  G. Baker",
address = "Nimble Computer Corporation, USA",
crossref = "IWMM92",
URL = "http://home.pipeline.com/~hbaker1/ThermoGC.ps.Z",
}


@article{bake92d,
title = "{CONS} should not {CONS} its Arguments, or a Lazy Alloc is a Smart Alloc",
author = "Henry G. Baker",
journal = SIGPLAN,
publisher = ACM,
volume = 27,
number = 3,
URL = "http://home.pipeline.com/~hbaker1/LazyAlloc.ps.Z",
month = Mar,
year = 1992
}


@article{bake93,
author = "Baker, Henry G.",
title = "`{I}nfant Mortality' and Generational Garbage Collection",
journal = SIGPLAN,
publisher = ACM,
volume = 28,
number = 4,
month = apr,
URL = "http://home.pipeline.com/~hbaker1/YoungGen.ps.Z",
year = 1993,
comment = "A counterexample to the `most objects die young' notion showing
generational gc as ineffective in improving the average mark/cons ratio.
Other benefits --- better locality, smaller number of large delays ---
may still make generational gc attractive."
}

@misc{bake93a,
author = "Baker, Henry G.",
title = "{CONS} Should Not {CONS} Its Arguments, Part II: {C}heney on the {M.T.A.}",
month = feb,
year = 1994,
howpublished = "comp.lang.scheme.c newsgroup"
}

@article{bake93b,
author = "Baker, Henry G.",
title = "Safe and Leak-Proof Resource Management using {Ada83} Limited Types",
journal = "ACM Ada Leters",
publisher = ACM,
volume = 13,
number = 5,
pages = "32--42",
month = sep,
year = 1993
}

@article{bake93c,
author = "Baker, Henry G.",
title = "The Boyer Benchmark Meets Linear Logic",
journal = "Lisp Pointers",
publisher = ACM,
volume = 6,
number = 4,
month = oct,
year = 1993,
pages = "3--10"
}

@article{bake94,
author = "Baker, Henry G.",
title = "Minimising Reference Count Updating with Deferred and Anchored Pointers for Functional Data Structures",
URL = "http://home.pipeline.com/~hbaker1/LRefCounts.ps.Z",
journal = SIGPLAN,
publisher = ACM,
volume = 29,
number = 9,
month = sep,
year = 1994,
comment = {Baker claims that RC can be made more efficient. But he also strongly
supports Linear Logic. See
'A Linear Logic Quicksort' SIGPLAN 29(2), Feb, 1994, 13-18 and
'Linear Logic and Permutation stacks' ACM Comp. Arch. news 22(1), March, 1994, 34-43}
}

@article{bake95,
author = "Baker, Henry G.",
title = "Use-Once Variables and Linear Objects --- Storage Management, Reflection and Multi-threading",
journal = SIGPLAN,
publisher = ACM,
volume = 30,
number = 1,
year = 1995
}

@misc{bake92e,
author = "C. A. Baker-Finch",
title = "Relevance and Contraction: A  Logical Basis for Strictness and Sharing Analysis",
year = 1992,
note = "Submitted to " # JFP
}

@inproceedings{bake00,
author = {Adam Bakewell and Colin Runciman},
title = {A Model for Comparing the Space Usage of Lazy Evaluators},
booktitle = {Second International Conference on Principles and Practice of Declarative Programming},
address = {Montreal},
month = sep,
year = 2000
}

@article{bal91,
author = "Henri E. Bal and Andrew S. Tanenbaum",
title = "Distributed Programming with Shared Data",
journal = "Computer Languages",
volume = 16,
number = 2, 
pages = "129--146", 
year = 1991
}

@article{bal92,
author = "Henri E. Bal and M. Frans Kaashoek and Andrew S. Tanenbaum",
title = "Orca: A Language for Parallel Programming of Distributed Systems",
journal = TransSWE,
publisher = ACM,
volume = 18,
number = 3,
pages = "190--205", 
year = 1992
}

@inproceedings{ball92,
author = "Ball and James Larus",
title = "Optimal Profiling and Tracing of Programs",
crossref = "POPL92",
pages = "59--70"
}

@incollection{ball83,
author = "Stoney Ballard and Stephen Shirron",
title = "The Design and Implementation of {VAX}/{S}malltalk-80",
crossref = "Smalltalk-BHWA",
pages = "127--150",
comment = "Variation of Lieberman-Hewitt collector; use indirection table;
don't like reference counting"
}

@article{bana94,
title = "Term Graph Rewriting and Garbage Collection using Opfibrations",
author = "R Banach",
journal = "Theoretical Computer Science",
volume = 131,
number = 1,
month = aug,
year =1994,
pages = "29--94"
}

@inproceedings{bane99,
author = {A. Banerjee and N. Heintze and J.G. Riecke},
title = {Region Analyssi and the Polymorphic Lambda Calculus},
booktitle = {Proceedings of the Fourteenth Annual IEEE Symposium on Logic in Computer Science},
address = {Trento, Italy},
month = jul,
year = 1999,
publisher = IEEE,
pages = {88--97}
}

@inproceedings{bara03,
title = {Mostly Concurrent Garbage Collection Revisited},
author = {Katherine Barabash and Yoav Ossia and Erez Petrank},
URL = {http://www.cs.technion.ac.il/~erez/publications.html},
crossref = {OOPSLA03}
}

@article{bara82,
author = "David R. Barach and David H. Taenzer and Robert E. Wells",
title = "A Technique for Finding Storage Allocation Errors in {C}-language Programs",
journal = SIGPLAN,
publisher = ACM,
volume = 17,
number = 5,
pages = "16--23",
month = may,
year = 1982
}

@inproceedings{bara01,
author = {K. Barabash and N. Buchbinder and Tamar Domani and Elliot Kolodner and Yoav Ossia and S.S. Pinter and J. SHepherd and R.Sivan and V. Umansky},
title = {Mostly Accurate Stack Scanning},
crossref = {JVM01},
URL = {http://www.usenix.org/events/jvm01/barabash.html},
pages = {153--170}
}


@techreport{barb71,
author = "M. Barbacci",
title = "A {LISP} Processor for {C}.ai",
institution = CMU,
type = "Memo",
number = "CMU-CS-71-103",
year = 1971
}


@inproceedings{bark86,  
title = "Garbage Cut for Garbage Collection of Iterative {P}rolog Programs.",
author = "Jonas Barklund and H\o{a}kan Millroth",
booktitle = "Proceedings --- 1986 Symposium on Logic Programming. 
{S}alt {L}ake {C}ity, {S}ept 22--25",
publisher = IEEE,
pages = "276--283",
year = 1986,
URL = "ftp://ftp.csd.uu.se/pub/papers/reports/0038.ps.gz",
abstract = {
A strategy is presented for garbage collection in Prolog machines.
Its application to iterative programs and implications on programming style is
described.  An implementation of the garbage collection together with an
implementation of cut in an abstract machine for Prolog is suggested.  Some
benchmark figures are presented, indicating a two-fold speedup of garbage
collection for large programs.}
}

@techreport{bark86a,
title = {Garbage Cut},
author = {Jonas Barklund and H\o{a}kan Millroth},
institution = {Uppsala University},
number = 38,
URL = {ftp://ftp.csd.uu.se/pub/papers/reports/0038.ps.gz},
year = 1986
}

@techreport{bark87,
author = "Jonas Barklund",
title = "A Garbage Collection Algorithm for {T}ricia",
number = "37B",
institution = "Uppsala University",
year = 1987,
URL = {ftp://ftp.csd.uu.se/pub/papers/reports/0037.ps.gz}
}

@inproceedings{barn97,
author = {Nick Barnes and Richard Brooksby and David Jones and Gavin Matthews
and Pekka P. Pirinen and Nick Dalton and P. Tucker Withington},
title = {A Proposal for a Standard Memory Management Interface},
URL = {ftp://ftp.dcs.gla.ac.uk/pub/drastic/gc/harlequin.ps},
crossref = {OOPSLA97-gc}
}

@article{barn79,
author = {Jeff A. Barnett},
title = {Garbage collection versus swapping},
journal = {Operating Systems Review},
volume = 13,
number = 3,
year = 1979
}

@inproceedings{barr93,
title = "Using Lifetime Predictors to Improve Memory Allocation Performance",
author = "David A. Barrett and Benjamin G. Zorn",
crossref = "PLDI93",
pages = "187--196",
URL = {ftp://ftp.cs.colorado.edu/pub/cs/techreports/zorn/PLDI-93-predictors.ps.Z},
abstract = {Dynamic storage allocation is used heavily in many application areas
including interpreters, simulators, optimizers, and translators.  We
describe research that can improve all aspects of the performance of
dynamic storage allocation by predicting the lifetimes of short-lived
objects when they are allocated.  Using five significant,
allocation-intensive C programs, we show that a great fraction of all
bytes allocated are short-lived (> 90\% in all cases).  Furthermore, we
describe an algorithm for lifetime prediction that accurately predicts
the lifetimes of 42-99\% of all objects allocated.  We describe and
simulate a storage allocator that takes advantage of lifetime
prediction of short-lived objects and show that it can significantly
improve a program's memory overhead and reference locality, and even,
at times, improve CPU performance as well.}
}

@techreport{barr93a,
author = "David A. Barrett and Benjamin Zorn",
title = "Garbage Collection using a Dynamic Threatening Boundary",
institution = "University of Colorado",
type = "Computer Science Technical Report",
number = "CU-CS-659-93",
month = jul,
year = 1993,
URL = "ftp://ftp.cs.colorado.edu/pub/cs/techreports/zorn/CU-CS-659-93.ps.Z",
abstract = {Generational techniques have been very successful in reducing the
impact of garbage collection algorithms upon the performance of programs.
However, it is impossible for designers of collection algorithms to anticipate 
the memory allocation behavior of all applications in advance.  Existing 
generational collectors rely upon the applications programmer to tune the 
behavior of the collector to achieve  maximum performance for each application.
Unfortunately, because the many tuning parameters require detailed knowledge 
of both the collection algorithm and the program allocation behavior in order 
to be used effectively, such tuning is difficult and error-prone.  We propose 
a new garbage collection algorithm that uses just two easily-understood 
tuning parameters that directly reflect the maximum memory and pause time 
constraints familiar to application programmers and users.
Like generational collectors, ours divides memory into two spaces,
one for short-lived, and another for long-lived objects.  Unlike previous
work, our collector dynamically adjusts the boundary between these 
two spaces in order to directly meet the resource constraints specified by the 
user.  We describe two methods for adjusting this boundary, compare them with 
several existing algorithms, and show how effectively ours meets 
the specified constraints.  Our pause-time collector saved memory by holding 
median pause times closer to the constraint than the other pause-time 
constrained algorithm and, when not over-constrained, our memory-constrained
collector exhibited the lowest CPU overhead of the algorithms we measured 
yet was capable of maintaining a maximum memory constraint.}
}

@inproceedings{barr95,
author = "David A. Barrett and Benjamin Zorn",
title = "Garbage Collection using a Dynamic Threatening Boundary",
crossref = "PLDI95",
}

@inproceedings{barr98,
author = {L.A. Barroso and K. Gharachorloo and E. Bugnion},
title = {Memory System Characterization of Commercial Workloads},
booktitle = {25th Annual International Symposium on Computer Architecture},
pages = {3--14},
year = 1998,
URL = {http://portal.acm.org/citation.cfm?id=279363&coll=portal&dl=ACM&CFID=6874820&CFTOKEN=53289201#FullText}
}

@article{bart77,
author = "Jeffrey M. Barth",
title = "Shifting Garbage Collection Overhead to Compile Time",
journal = CACM,
publisher = ACM,
volume = 20,
number = 7 ,
month = jul,
year = 1977,
pages = "513--518",
}


@techreport{bart88,
author = "Bartlett, Joel F.",
title = "Compacting Garbage Collection with Ambiguous Roots",
number = "88/2", 
URL = "http://www.research.digital.com/wrl/techreports/88.2.ps",
institution = DECWRL,
month = Feb, 
comment = "Excellent trick here---make newness a page property, not an
  address-range property",
note = "Also in Lisp Pointers 1, 6 (April--June 1988), 2--12",
year = 1988
}


@techreport{bart89,
author = "Joel F. Bartlett",
title = "Mostly-{C}opying Garbage Collection picks up Generations and {C++}",
institution = DECWRL,
type = "Technical Note",
volume = "TN--12",
month = oct,
year = "1989",
URL = "ftp://ftp.digital.com/pub/DEC/WRL/research-reports/WRL-TN-12.ps",
note = "Sources available in ftp://ftp.digital.com/pub/DEC/CCgc",
}

@techreport{bart89a,
author = "Joel F. Bartlett",
title = "{SCHEME}-$>${C}: a Portable {S}cheme-to-{C} Compiler",
institution = DECWRL,
month = jan,
year = 1989
}

@inproceedings{bart90,
author = "Joel F. Bartlett",
title = "A Generational, Compacting Collector for {C++}",
crossref = "OOPSLA90-gc",
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/GC90/Bartlett.ps.Z",
}



@article{bast88,
title = "Concurrent Maintenance of Data-Structures in a Distributed 
Environment",
author = "F. B. Bastani and S. S. Iyengar and I. L. Yen",
address = "University of  Houston, Department of Computer Science",
journal = CompJ,
publisher = BCS,
year = 1988,
volume = 31,
number = 2,
pages = "165--174"
}


@inproceedings{bate82,
author = "Raymond L. Bates and David Dyer and Johannes A. G. M. Koomen",
title = "Implementation of {I}nterlisp on {VAX}",
crossref = "LFP82",
pages = "81--87"
}


@article{bats76,
author = "Alan Batson",
title = "Program Behavior at the Symbolic Level",
journal = "{IEEE} Computer",
publisher = IEEE,
month = nov,
year = 1976,
pages = "21--26"
}

@article{bats77,
author = "Alan P. Batson and R. E. Brundage",
title = "Segment Sizes and Lifetimes in {ALGOL} 60 Programs",
journal = CACM,
publisher = ACM,
volume = 20,
number = 1,
year = 1977,
month = jan,
pages = {36--44}
}



@book{baue82,
title = "Algorithmic Language and Program Development",
author = {F. L. Bauer and H. W\"{o}ssner},
publisher = SV,
year = 1982,
comment = "Contains useful chapters on recursion removal and transformation
of recursion into iteration."
}


@article{baum91,
title = "Computer Scheduling Algorithms --- Past,  Present,  and Future",
author = "K. M. Baumgartner and B. W. Wah",
address = "Digital Equipment Corp, Maynard, Ma, 01754 Univ Illinois, 
Coordinated Science Laboratory, Urbana, Il, 61801",
journal = "Information Sciences",
month = Sep,
year = 1991,
pages = "319--345"
}


@techreport{bawd77,
author = "A. Bawden and Richard Greenblatt and J. Holloway and T. Knight and David A. Moon and D. Weinreb",
title = "{L}isp Machine Progress Report",
number = "Memo 444",
institution = "A.I. Lab",
address = "MIT, Cambridge, MA",
month = Aug,
year = 1977,  
}

@article{bayl00,
author = {Baylor, S.J. and Devarakonda, M. and Fink, S. and Gluzberg, E. and
Kalantar, M. and  Muttineni, P. and Barsness, E. and Munroe, S. and Arora, R. 
and Dimpsey, R.}, 
title = "{J}ava Server Benchmarks", 
journal = ISJ, 
volume = 39, 
number = 1, 
year = 2000
}

@article{bays77,
author = "C. Bays",
title = "A Comparison of Next-Fit, First-Fit and Best-Fit",
journal = CACM,
publisher = ACM,
volume = 20,
number = 3,
pages = "191--192",
month = mar,
year = 1977
}


@phdthesis{beau91,
author = "Barbara Beaudoing",
title = {Recycler-en-Marquant: Un Algorithme de Gestion de M\'{e}moire en Temps
R\'{e}el, \'{E}tude et Implantation},
school = {Universit\'{e} de Paris VI},
year = 1991
}

@inproceedings{beau91a,
author = "Barbara Beaudoing  and Christian Queinnec",
title = "Mark-{DURING}-{S}weep: A Real-Time Garbage Collector",
crossref = "PARLE91",
}

@inproceedings{beeb01,
author = {{Beebee, Jr.}, William S. and Martin Rinard},
title = {An Implementation of Scoped Memory for Real-Time Java},
crossref = {EMSOFT01},
pages = {289--305},
}

@article{beck82,
author = "Leland L. Beck",
title = "A Dynamic Storage Allocation Technique based on Memory Residence Time",
journal = CACM,
publisher = ACM,
volume = 25,
number = 10,
month = oct,
year = 1982,
pages = "714--724"
}

@techreport{beck86,
author = "Michael J. Beckerle and Kattamuri Ekanadham",
title = "Distributed Garbage Collection with no Global Synchronisation",
institution = IBM,
type = "Research Report",
number = "RC 11667 (\#52377)",
month = jan,
year = 1986,
comment = "Handles cycles"
}

@inproceedings{beem90,
author = "Marcel Beemster",
title = "Back-end Aspects of a Portable {POOL--X} Implementation",
booktitle = "Parallel Database Systems ({PRISMA}) Workshop Proceedings",
editor = "Pierre America",
series = LNCS,
volume = 503,
publisher = SV,
pages = "193--228",
year = 1990,
}

@article{bekk83,
author = "Yves Bekkers and B. Canet and Olivier Ridoux and L. Ungaro",
title = "A Short Note on Garbage Collection in {P}rolog Interpreters",
journal = "Logic Programming Newsletter",
volume = 5,
year = 1983,
comment = "Some binding values may become useless.",
}

@inproceedings{bekk84,
author = "Yves Bekkers and B. Canet and Olivier Ridoux and L. Ungaro",
title = "A Memory Management Machine for {P}rolog Interpreters",
crossref = "ICLP84",
pages = "343--351",
comment = "Traverse goal-statements in the backtrack stack but consider binding status.",
}

@inproceedings{bekk86,
author = "Yves Bekkers and B. Canet and Olivier Ridoux and L. Ungaro",
title = "{MALI}: A Memory with a Real-Time Garbage Collector for 
Implementing Logic Programming Languages",
booktitle = "3rd Symposium on Logic Programming",
publisher = IEEE,
year = 1986,
comment = "Traverse goal-statements in the backtrack stack but consider binding status.",
}

@article{bekk85,
author = "Yves Bekkers and B. Canet and Olivier Ridoux and L. Ungaro",
title = "A Memory Management Machine for {P}rolog",
journal = {Informatique--85, Symposium Sovi\'{e}to-Fran\c{c}ais, Tallin},
pages = "111--117",
year = 1985,
}

@inproceedings{bekk91,
author = "Yves Bekkers and L. Ungaro",
title = "Implementing Parallel Garbage Collection for {P}rolog",
booktitle = "Russian Conference on Logic Programming",
series = LNCS,
volume = 592,
editor = "A. Voronkov",
year = 1991,
}

@inproceedings{bekk92a,
title = "A Survey on Memory Management for Logic Programming",
author = "Yves Bekkers and Olivier Ridoux and L. Ungaro",
address = "INRIA/IRISA, France",
crossref = "IWMM92",
}

@inproceedings{bena82,
title = "On-The-Fly Garbage Collection: New Algorithms Inspired by Program Proofs",
author = "Mordechai Ben-Ari",
pages = "14--22",
booktitle = "Automata, languages and programming. Ninth colloquium",
address = "Aarhus, Denmark",
month = "July 12--16",
year = 1982,
editor = "M.  Nielsen and E. M. Schmidt",
publisher = "Springer-Verlag",
}

@article{bena84,
author = "Mordechai Ben-Ari",
title = "Algorithms for On-The-Fly Garbage Collection",
journal = TOPLAS,
publisher = ACM,
volume = "6",
number = "3",
pages = "333--344",
month = jul,
year = "1984",
comments = {This paper presents alternative methods of on-the-fly garbage 
collection \cite{Dijk78} with simpler proofs.} 
}

@inproceedings{bene81,
author = "V. E. Benes",
title = "Models and Problems of Dynamic Storage Allocation",
booktitle = "Applied Probability and Computer Science --- the Interface",
publisher = "Institute of Management Science and Operations Research Society of America",
month = jan,
year = 1981
}

@inproceedings{beng90,
author = "Mats Bengtsson and Boris Magnusson",
title = "Real-time Compacting Garbage Collection",
crossref = "OOPSLA90-gc",
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/GC90/Bengtsson.ps.Z",
}

@mastersthesis{beng90a,
author = "Mats Bengtsson",
title = "Real-time Compacting Garbage Collection Algorithms",
school = "Department of Computer Science, Lund University",
year = 1990,
type = "Licentiate thesis",
URL = "http://www.dna.lth.se/Research/ProgEnv/Abstracts/Thesis.MB.abs.html"
}

@inproceedings{benn87,
author = "J. K. Bennett",
title = "The Design and Implementation of Distributed {S}malltalk",
crossref = "OOPSLA87",
pages = "318--330",
}

@inproceedings{benn90,
author = "J. Bennet and J. Carter and W. Zwaenepoel",
title = "Munin: Distributed Shared Memory based on Type-Specific Memory Coherence",
crossref = "PPoPP90",
pages = "168--176", 
}

@inproceedings{bens97,
title = {The Memory Manager for the {A}urora {J}ava {V}irtual {M}achine Testbed},
author = {Peter Benson},
URL = {ftp://ftp.dcs.gla.ac.uk/pub/drastic/gc/pbenson.ps},
crossref = {OOPSLA97-gc}
}

@inproceedings{beny02,
title = {An Algorithm for Parallel Incremental Compaction},
author = {Ori Ben-Yitzhak and Irit Goft and Elliot Kolodner and Kean Kuiper and Victor Leikehman},
crossref = {ISMM02},
pages = {100--105}
}

@techreport{berg88,
author = "Bergstein, Steven H.",
title = "Best-Case Caching in a Symbolic Multiprocessor",
institution = "Massachusetts Institute of Technology EECS Department",
month = feb,
year = 1988,
address = "Cambridge, MA",
type = "Bachelor's thesis"     
}

@techreport{berg99,
author = "Emery D. Berger and Robert D. Blumofe",
title = "{H}oard: A Fast, Scalable, and Memory-Efficient Allocator for
Shared-Memory Multiprocessors",
institution = "University of Texas at Austin",
number = "UTCS TR99-22",
year = 1999,
month = nov,
URL = "http://www.cs.utexas.edu/users/emery/hoard/download2.cgi?location=UTCS-TR99-22.ps.gz",
}

@inproceedings{berg00,
title = {Hoard: A Scalable Memory Allocator for Multithreaded Applications},
author = {Emery D. Berger and Kathryn S. McKinley and Robert D. Blumofe and Paul R. Wilson},
booktitle = {{ASPLOS-IX}: Ninth International Conference on Architectural Support for Programming Languages and Operating Systems},
address = {Cambridge, MA},
pages = {117--128},
month = nov,
year = 2000,
URL = {ftp://ftp.cs.umass.edu/pub/osl/papers/asplos2000.ps.gz}
}

@inproceedings{berg01,
title = {Composing High-Performance Memory Allocators},
author = {Emery D. Berger and Benjamin G. Zorn and Kathryn S. McKinley},
crossref = {PLDI01},
URL = {ftp://ftp.cs.umass.edu/pub/osl/papers/pldi2001.ps.gz}
}

@inproceedings{berg02,
author = "Emery D. Berger and Benjamin G. Zorn and Kathryn S. McKinley",
title = "Reconsidering Custom Memory Allocation",
crossref = {OOPSLA02},
URL = "http://citeseer.nj.nec.com/berger01reconsidering.html",
abstract = {
Programmers hoping to achieve performance improvements often use
custom memory allocators. This in-depth study examines eight
applications that use custom allocators. Surprisingly, for six of
these applications, a state-of-the-art general-purpose allocator (the
Lea allocator) performs as well as or better than the custom
allocators. The two exceptions use regions, which deliver higher
performance (improvements of up to 44\%). Regions also reduce
programmer burden and eliminate a source of memory leaks. However, we
show that the inability of programmers to free individual objects
within regions can lead to a substantial increase in memory
consumption. Worse, this limitation precludes the use of regions in
common programming idioms, reducing their usefulness.

We present a generalization of general-purpose and region-based
allocators that we call {\em reaps}. Reaps are a combination of
regions and heaps, providing a full range of region semantics with the
addition of individual object deletion. We show that our
implementation of reaps provides high performance, outperforming other
allocators with region-like semantics. Our results indicate that
programmers needing fast regions should use reaps, and that most
programmers considering custom allocators should instead use the Lea
allocator.  }
}

@article{berr78,
author = "Berry, D. M. and Chirica, L. M. and Johnston, J. B. and Martin, D. F. and Sorkin A.",
title = "Time Required for Garbage Collection in Retention Block-Structured Languages",
journal = "Journal of Computer Information Science",
volume = 7,
number = 1 ,
year = 1978,
pages = "361--404",
}


@article{berz65,
author = "A. T. Bertziss",
title = "A Note on the Storage of Strings",
journal = CACM,
publisher = ACM,
volume = 8,
number = 8,
month = aug,
year = 1965,
pages = "512--513"
}

@book{berz75,
author = "A. T. Berztiss",
title = "Data Structures Theory and Practice",
edition = "Second",
publisher = AP,
year = 1975,  
comments = {book with sections on garbage collection},
}


@article{bett73,
title = "An Analytical Storage Allocation Model",
author = "Terry Betteridge",
journal = ActInf,
publisher = SV,
volume = 3,
year = 1973,
pages = "101--122"
}

@book{bett82,
author = "Terry Betteridge",
title = "An Algebraic Analysis of Storage Fragmentation",
publisher = "UMI Research Press",
address = "Ann Arbor, Michigan",
year = 1982
}

@inproceedings{beva87,
author = "David I. Bevan",
title = "Distributed Garbage Collection using Reference Counting",
crossref = {PARLE87},
pages = "176--187",
comments = "Weighted reference count algorithm (see also \cite{wats87}) 
reduces communication overheads."
}


@inproceedings{beva88,
title = "Efficient Reference Counting Solution to the Distributed Garbage 
Collection Problem.",
author = "David I. Bevan",
booktitle = "{PARLE}: Conference on Parallel Architectures and Languages --- 
Europe. Eindhoven, Jun 15--19",
note = "Also in Parallel Computing 9(2) Jan 1988--1989. p 179--192",
pages = "179--192",
year = "1988",
abstract = {
A good programming language permits the programmer to concentrate
on his application rather than on low-level implementation details.  In
particular, he does not have to concern himself with storage allocation 
because memory management is dealt with efficiently by the implementation of
the language.  To reclaim disused storage for reuse the implementation 
incorporates a garbage collection algorithm.  When the language is implemented
on a distributed multiprocessor architecture, this algorithm ideally collects
garbage as soon as it is created and has minimal overheads in terms of space
requirements and interprocess communications.  We describe here an elegant
algorithm with these properties which makes use of reference counting.}
}

@inproceedings{beve94,
author = {Johan Bevemyr and Thomas Lindgren},
title = {A Simple and Efficient Copying Garbage Collector for {P}rolog},
booktitle = {PLILP94 International Symposium on Programming Language Implementation and Logic Programming},
pages = {88--101},
year = 1994,
URL = {ftp://ftp.csd.uu.se/pub/papers/reports/0087.ps.gz}
}

@techreport{beve95,
author = {Johan Bevemyr},
title = {A Generational Parallel Copying Garbage Collector for Shared Memory {P}rolog},
institution = {Uppsala University},
number = 117,
month = oct,
year = 1995,
URL = {ftp://ftp.csd.uu.se/pub/papers/reports/0117.ps.gz}
}

@article{beye79,
title = "A Space Efficient Dynamic Allocation Algorithm for Queuing Messages",
author = "Eric Beyer and Peter Buneman",
journal = toplas,
publisher = ACM,
year = 1979,
month = oct,
volume = 1,
number = 2,
pages = "287--294"
}

@inproceedings{biag94,
author = "Edoardo Biagioni and Robert Harper and Peter Lee and Brian Milnes",
title = "Signatures for a Network Protocol Stack: A Systems Application of {S}tandard {ML}",
crossref = "LFP94",
}

@inproceedings{biel99,
title = {Implementing a Distributed Garbage Collector for {OO} Databases},
author = {Richard Bielak and Jean-Pierre Sarkis},
organisation = {CAL FP Bank, USA},
booktitle = {TOOLS USA '99 Technology of Object-Oriented Languages and Systems},
address = {Santa Barbara, CA},
month = aug,
year = 1999
}



@inproceedings{bigl85,
author = "B. M. Bigler and S. J. Allan and Rod R. Oldehoeft",
title = "Parallel Dynamic Storage Allocation",
booktitle = "1985 International Conference on Parallel Processing",
year = 1985,
pages = "272--275"
}

@inproceedings{bili92,
author = "Biliris, Alexandros",
title = "An Efficient Database Storage Structure for Large Dynamic
Objects",
booktitle = "Proceedings, {IEEE} Data Engineering Conference",
publisher = IEEE,
address = "Phoenix, Arizona",
month = feb,
year = 1992,
pages = "301--308"
}

@inproceedings{bing93,
title = "Experiences Developing and Using an Object-Oriented Library for Program Manipulation",
author = "Tim Bingham and Nancy Hobbs and Dave Husson",
crossref = "OOPSLA93",
comment = "Boehm GC greatly improved dynamically allocated memory usage, but GC 
is not a substitute for well-designed classes."
}

@inproceedings{birk96,
author = {Lars Birkedal and Mads Tofte and Magnus Vejlstrup},
title = {From Region Inference to von {N}eumann Machines via Region Representation Inference},
crossref = {POPL96},
URL = {http://www.diku.dk/users/tofte/publ/popl96.ps}
}


@article{birm87,
title = "Exploiting Virtual Synchrony in Distributed Systems",
author = "K. Birman",
journal = "Operating Systems Review",
publisher = ACM,
volume = 21,
number = 5,
pages = "123--138",
month = nov,
year = 1987,
comment = "Symmetric atomic multicast protocol."
}

@article{birr78,
author = "Andrew D. Birrell and Roger M. Needham",
title = "An Asynchronous Garbage Collector for the {CAP} Filing System",
journal = "Operating Systems Review",
publisher = ACM,
volume = 12,
number = 2,
pages = "31--33",
month = apr,
year = 1978
}

@techreport{birr93,
author = "Andrew Birrell and David Evers and Greg Nelson and Susan Owicki and Edward Wobber",
title = "Distributed Garbage Collection for Network Objects",
institution = "DEC Systems Research Center",
address = "130 Lytton Avenue, Palo Alto, CA 94301",
number = 116,
month = dec,
year = 1993,
URL = {ftp://ftp.digital.com/pub/DEC/SRC/research-reports/SRC-116.ps.Z},
comment = "based on reference counting, pair-wise communication, no global
synchronization"
}

@techreport{birr94,
author = "Andrew Birrell and Greg Nelson and Susan Owicki and Edward Wobber",
title = "Network Objects",
institution = DECSRC,
number = 115,
month = feb,
year = 1994,
comment = "based on reference counting, pair-wise communication, no global
synchronization"
}

@inproceedings{birr94a,
author = "Andrew Birrell and Greg Nelson and Susan Owicki and Edward Wobber",
title = "Network Objects",
booktitle = {Proceedings of the Fourteenth ACM Symposium on Operating Systems Principles},
address = {Asheville, NC},
publisher = ACM,
pages = {217--230},
year = 1994,
URL = {http://portal.acm.org/ft_gateway.cfm?id=168637&type=pdf&coll=portal&dl=ACM&CFID=16176040&CFTOKEN=97367678}
}

@article{birr95,
author = "Andrew Birrell and Greg Nelson and Susan Owicki and Edward Wobber",
title = "Network Objects",
journal = SPE,
volume = 25,
number = 4,
pages = {87--130},
publisher = {Wiley},
month = dec,
year = 1995,
URL = {http://research.microsoft.com/copyright/accept.asp?path=/users/wobber/netobj-spe.ps&pub=41}
}

@techreport{bish75,
author = "Peter B. Bishop",
title = "Garbage collection in a Very Large Address Space",
type = "Working paper",
number = 111,
institution = "AI Laboratory",
address = "MIT, Cambridge, MA",
month = sep,
year = 1975
}

@phdthesis{bish77,
author = "Peter B. Bishop",
title = "Computer Systems with a Very Large Address Space and Garbage Collection",
school = "MIT Laboratory for Computer Science",
month = May,
year = 1977,
URL = "ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/listings/abstracts/TR-178.html",
comments = {Variant of Kurukawa's algorithm \cite{kuro75}:
marking algorithm which uses
a fixed-length stack. Cohen says that they haven't
been compared and neither of them has been proved correct},
abstract = "The concept of objects is beginning to gain acceptance
throughout the field of computer science.  A new computer system is
proposed that provides hardware support for objects and object
references that can be used in all applications of objects.  The new
system provides small object references that can be copied freely,
makes very small objects efficient, and retrieves the storage for
inaccessible objects automatically.  This system is compared with
some widely used existing systems, and while its speed seems to be
competitive, it is much easier to use.
Object references provide protection in the new system as do
capabilities in capability systems.  The object reference in the new
system contains an address from a linear, paged virtual address space
rather than a unique ID.  Use of small objects is made feasible by
efficiently grouping objects into areas.  Objects in the same area
may be placed on the same page.  The system automatically and
efficiently maintains lists of inter-area links that allow single
areas to be garbage collected independently of the rest of the
system.  The garbage collector can determine whether objects have
been inappropriately placed in an area and can move these objects to
more appropriate areas automatically."
}


@incollection{bjor89,
author = {Anders Bj\"{o}rnerstedt},
title = "Secondary Storage Garbage Collection for Decentralized Object-Based Systems",
booktitle = "Object Oriented Development",
type = "Technical Report",
editor = "D. Tsichritzis",
publisher = "Centre Universitaire d'Informatique, University of Geneva",
month = jul,
year = 1989,
pages = "277--319",
comment = "This paper describes a mechanism for secondary storage garbage collection that may be used to reclaim inaccessible resources in decentralized persistent object based systems. Schemes for object addressing and object identification are discussed and a proposal is
made which handles volatile objects separately from persistent objects.  The garbage collection of the space of volatile objects is decoupled from the garbage collection of the space of persistent objects. The first kind of garbage collection can avoid the
complexity and overhead of a distributed algorithm by classifying exported objects as persistent. The problem of detecting and collecting ``distributed garbage'' is then deferred to garbage collection of persistent objects."
}

@phdthesis{bjor90,
author = {Anders Bj\"{o}rnerstedt},
title = "Secondary Storage Garbage Collection for Decentralized Object-Based Systems",
school = {Royal Institute of Technology and Stockholm University, Sweden},
month = jun,
year = 1990,
note = {Technical Report 77}
}

@inproceedings{bjor02,
title = {{Bu}ddy{C}ache: High Performance Object Storage for Collaborative Strong-Consistency Applications in a {WAN}},
author = {Magnus Bjornsson and Liuba Shrira},
crossref = {OOPSLA02},
abstract = {Collaborative applications provide a shared work
environment for groups of networked clients collaborating on a common
task. They require strong consistency for shared persistent data and
efficient access to fine-grained objects. These properties are
difficult to provide in wide-area networks because of high network
latency.  BuddyCache is a new transactional caching approach that
improves the latency of access to shared persistent objects for
collaborative strong-consistency applications in high-latency network
environments. The challenge is to improve performance while providing
the correctness and availability properties of a transactional caching
protocol in the presence of node failures and slow peers. We have
implemented a BuddyCache prototype and evaluated its performance.
Analytical results, confirmed by measurements of the BuddyCache
prototype using the multi-user 007 benchmark indicate that for typical
Internet latencies, e.g. ranging from 40 to 80 milliseconds round trip
time to the storage server, peers using BuddyCache can reduce by up to
50\% the latency of access to shared objects compared to accessing the
remote servers directly.}
}

@inproceedings{blac86,
author = "Andrew Black and Norman Hutchinson and Eric Jul and Henry Levy",
title = "Object Structure in the {E}merald System",
crossref = "OOPSLA86",
pages = "78--86",
}


@article{blac87,
author = "Andrew Black and Norman Hutchinson and Eric Jul and Henry Levy 
and Larry Carter",
title = "Distribution and Abstract Types in {E}merald",
journal = TransSWE,
publisher = ACM,
volume = 13,
number = 1,
pages = "65--76",
year = 1987,
month = jan,
}

@inproceedings{blac01,
author = {Stephen M. Blackburn and Sharad Singhai and Matthew Hertz and 
Kathryn S. McKinley and J. Eliot B. Moss},
title = {Pretenuring for {J}ava},
crossref = {OOPSLA01},
pages = {342--352},
URL = {ftp://ftp.cs.umass.edu/pub/osl/papers/oopsla2001.ps.gz}
}

@inproceedings{blac02,
author = {Stephen M. Blackburn and Richard Jones and Kathryn S. McKinley and J. Eliot B. Moss},
title = {Beltway: Getting Around Garbage Collection Gridlock},
crossref = {PLDI02},
pages = {153--164},
abstract = {We present the design and implementation of a new garbage
collection framework that significantly generalizes existing copying
collectors. The \emph{Beltway} framework exploits and separates object
age and incrementality. It groups objects in one or more increments on
queues called \emph{belts}, collects belts independently, and collects
increments on a belt in first-in-first-out order. We show that Beltway
configurations, selected by command line options, act and perform the
same as semi-space, generational, and older-first collectors, and
encompass all previous copying collectors of which we are aware.

The increasing reliance on garbage collected languages such as Java
requires that the collector perform well. We show that the generality
of Beltway enables us to design and implement new collectors that are
robust to variations in heap size and improve total execution time over
the best generational copying collectors of which we are aware by up to
40\%, and on average by 5 to 10\%, for small to moderate heap sizes.
New garbage collection algorithms are rare, and yet we define not just
one, but a new family of collectors that subsumes previous work.  This
generality enables us to explore a larger design space and build better
collectors.},
URL = {http://www.cs.ukc.ac.uk/pubs/2002/1363}
}

@inproceedings{blac02a,
title = {In or Out? Putting Write Barriers in Their Place},
author = {Stephen M. Blackburn and Kathryn S. McKinley},
crossref = {ISMM02},
pages = {175--184}
}

@inproceedings{blac03,
title = {Ulterior Reference Counting: Fast Garbage Collection without a Long Wait},
author = {Stephen M. Blackburn and Kathryn S. McKinley},
crossref = {OOPSLA03}
}

@inproceedings{blac04,
author = {Stephen M. Blackburn and Perry Cheng and Kathryn S. McKinley},
title = {Myths and Reality: The Performance Impact of Garbage Collection},
booktitle = {Sigmetrics - Performance 2004, Joint International Conference on Measurement and Modeling of Computer Systems},
address = {New York, NY},
month = jun,
year = 2004,
URL = {http://cs.anu.edu.au/~Steve.Blackburn/pubs/papers/mmtk-sigmetrics-2004.pdf},
abstract = {This paper explores and quantifies garbage collection (GC)
behavior for three whole heap collectors and generational counterparts:
copying semi-space, mark-sweep, and reference counting, the canonical
algorithms from which essentially all other GC algorithms are derived.
Efficient implementations in the memory management toolkit (MMTk) in
Jikes RVM share all common mechanisms to provide a clean experimental
platform. Performance counters and instrumentation measure timing and
memory performance, separating GC and program behavior.

Experiments on SPEC JVM Benchmarks reveal key algorithmic features and
how they match program characteristics to explain the direct cost of GC
as a function of heap size, and the indirect impact of GC on
application performance. Results include the finding that the choice of
GC algorithms can improve mutator locality, disputing the myth that "no
GC is good GC." We show how the trade-offs in space utilization versus
allocation and tracing costs in copying and mark-sweep collectors
motivates a copying nursery for newly allocated objects, even without
high nursery mortality. We find that object locality and pointer
mutations demographics in the mature space are much less sensitive to
GC algorithm, but that copying and mark-sweep for the mature space
occasionally excel in different programs. This study is unique in its
breadth of GC algorithms and its depth of analysis.}
}

@inproceedings{blac04a,
author = {Stephen M. Blackburn and Perry Cheng and Kathryn S. McKinley},
title = {Oil and Water? {H}igh Performance Garbage Collection in {J}ava with {MMTk}},
crossref = {ICSE04},
URL = {http://cs.anu.edu.au/~Steve.Blackburn/pubs/papers/mmtk-icse-2004.pdf},
abstract = {Increasingly popular languages such as Java and C\# require
efficient garbage collection. This paper presents the design,
implementation, and evaluation of MMTk, a Memory Management Toolkit for
and in Java. MMTk is an efficient, composable, extensible, and portable
framework for building garbage collectors. MMTk uses design patterns
and compiler cooperation to combine modularity and efficiency. The
resulting system is more robust, easier to maintain, and has fewer
defects than monolithic collectors. Experimental comparisons with
monolithic Java and C implementations reveal MMTk has significant
performance advantages as well. Performance critical system software
typically uses monolithic C at the expense of flexibility. Our results
refute common wisdom that only this approach attains efficiency, and
suggest that performance critical software can embrace modular design
and high-level languages.}
}


@techreport{blan96,
title = {Garbage Collection statique},
author = {Bruno Blanchet},
type = {DEA report},
institution = {INRIA, Rocquencourt},
month = sep,
year = 1996
}

@inproceedings{blan98,
title = {Escape Analysis: Correctness Proof, Implementation and Experimental Results},
author = {Bruno Blanchet},
pages = {25--37},
crossref = {PLDI98},
comment = {By analysing which objects escape methods/threads, we can allocate on
the stack / avoid synchronisations.}
}

@inproceedings{blan99,
title = {Escape Analysis for Object Oriented Languages. Application to {J}ava},
author = {Bruno Blanchet},
pages = {20--34},
crossref = {OOPSLA99},
comment = {By analysing which objects escape methods/threads, we can allocate on
the stack / avoid synchronisations.}
}

@inproceedings{blau83,
author = "Ricki Blau",
title = "Paging on an Object-Oriented Personal Computer for {S}malltalk",
booktitle = "{ACM} {SIGMETRICS} Conference on Measurement and Modeling of
Computer Systems, {M}inneapolis",
month = aug,
year = 1983,
publisher = ACM,
note = "Also appears as Technical Report UCB/CSD 83/125, University of
California at Berkeley, Computer Science Division (EECS)"
}

@inproceedings{blel99,
author = {Guy E. Blelloch and Perry Cheng},
title = {On Bounding Time and Space for Multiprocessor Garbage Collection},
crossref = {PLDI99},
pages = {104--117}
}

@inproceedings{blon97,
title = {{PerDIS} {PPF} Case Study: Fitting a Distributed Garbage Collection Algorithm to a Persistent Distributed Store Architecture},
author = {Xavier Blondel and Paulo Ferreira and Marc Shapiro},
URL = {ftp://ftp.dcs.gla.ac.uk/pub/drastic/gc/perdis_gc.ps},
crossref = {OOPSLA97-gc}
}

@unpublished{blon98,
title = {Implementing Garbage Collection in the {PerDiS} System},
author = {Xavier Blondel and Paulo Ferreira and Marc Shapiro},
note = {Submitted for publication},
year = 1998,
URL = {http://cretina.inesc.pt/people/pjpf-home/submitted.ps}
}

@techreport{blon99,
title = {Report on the Scalability of Garbage Collection},
author = {Xavier Blondel},
institution = {Esprit},
note = {Deliverable {TC}.1.3-B, {P}er{D}i{S} project},
year = 1999,
URL = {http://www.perdis.esprit.ec.org/deliverables/docs/wpC/tc13b}
}

@phdthesis{blon00,
title = {Gestion de m\'{e}ta-donne\'{e}s de la m\'{e}moire dans un
environment r\'{e}parti persistant transactionnel \`{a} grande
\'{e}chelle: l'exemple de {P}er{D}i{S}},
author = {Xavier Blondel},
school = {Conservatoire National des Arts et M\'{e}tiers},
month = sep,
year = 2000
}

@article{bobr64,
title = "A Comparison of List-Processing Computer Languages",
author = "Daniel G. Bobrow and Bertram Raphael",
journal = CACM,
publisher = ACM,
volume = 7,
number = 4,
month = apr,
year = 1964,
pages = "231--240"
}

@article{bobr67,
author = "Daniel G. Bobrow and Daniel L. Murphy",
title = "Structure of a {LISP} System Using Two-Level Storage",
journal = CACM,
publisher = ACM,
volume = 10,
number = 3,
month = mar,
year = 1967,
pages = "155--159",
}


@article{bobr68a,
author = "Daniel G. Bobrow",
title = "Storage Management in {L}isp",
journal = "Symbol manipulation languages and techniques",
editor = "Daniel G. Bobrow",
publisher = "North-Holland",  
address = "Amsterdam",
year = 1968,
}


@article{bobr68b,
author = "Daniel G. Bobrow and Daniel L. Murphy",
title = "A Note on the Efficiency of a {LISP} Computation in a Paged Machine",
journal = CACM,
publisher = ACM,
volume = 11,
number = 8,
month = Aug,
year = 1968,
pages = "558--560",
}


@article{bobr75,
author = "Daniel G. Bobrow",
title = "A Note on Hash Linking",
journal = CACM,
publisher = ACM,
volume = 18,
number = 7 ,
month = jul,
year = 1975,
pages = "413--15",
comment = { Hash link cells with RC != 1.  }
}


@article{bobr79,
title = "Compact Encodings of List Structure",
author = "Daniel G. Bobrow and Douglas W. Clark",
journal = toplas,
publisher = ACM,
year = 1979,
month = oct,
volume = 1,
number = 2,
pages = "266--286",
comment = "Good words on {CDR}-coding"
}


@article{bobr80,
title = "Managing Re-entrant Structures using Reference Counts",
author = "Daniel G. Bobrow",
journal = toplas,
publisher = ACM,
year = 1980,
month = jul,
volume = 2,
number = 3,
pages = "269--273",
comment = "can handle some special cases of reference counting, but
restricts the programmer to certain stereotyped patterns."
}


@techreport{boeh85,
author = "Hans-Juergen Boehm and Alan Demers",
title = "Implementing {R}ussell",
institution = RICE,
number = "COMP TR85-25",
year = 1985
}


@article{boeh88,
title = "Garbage Collection in an Uncooperative Environment",
author = "Hans-Juergen Boehm and Mark Weiser",
institution = "{Rice Univ, Department of Computer Science, Houston, Texas, 77251} and
{Xerox Corp., Palo Alto Research Center, Palo Alto, Ca, 94304}",
journal = SPE,
publisher = Wiley,
year = 1988,
volume = 18,
number = 9,
pages = "807--820",
URL = "http://www.hpl.hp.com/personal/Hans_Boehm/gc/index.html",
abstract = {We describe a technique for storage allocation and garbage
collection in the absence of significant co-operation from the code using the
allocator.  This limits garbage collection overhead to the time actually
required for garbage collection.  In particular, application programs that
rarely or never make use of the collector no longer encounter a substantial
performance penalty.  This approach greatly simplifies the implementation of
languages supporting garbage collection.  It further allows conventional
compilers to be used with a garbage collector, either as the primary means 
of storage reclamation, or as a debugging tool.}
}


@unpublished{boeh88a,
author = "Hans-Juergen Boehm and Lucy Hederman",
title = "Storage Allocation Optimization in a Compiler for {R}ussell",
note = "Submitted for publication",
year = 1988,
month = jul
}

@article{boeh91,
title = "Mostly Parallel Garbage Collection",
author = "Hans-Juergen Boehm and Alan J. Demers and Scott  Shenker",
address = PARC,
journal = SIGPLAN,
publisher = ACM,
year = 1991,
volume = 26,
number = 6,
pages = "157--164",
URL = {http://reality.sgi.com/employees/boehm_mti/papers/pldi91.ps.Z},
comment = "Incremental update, uses VM dirty bits as a coarse pagewise write barrier."
}


@inproceedings{boeh91a,
author = "Hans-Juergen Boehm",
title = "Simple {GC}-Safe Compilation",
crossref = "OOPSLA91-gc",
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/GC91/boehm.ps"
}


@inproceedings{boeh91b,
author = "Hans-Juergen Boehm and Eliot Moss and Joel Bartlett and David R.
Chase",
title = "Panel Discussion: Conservative vs. Accurate Garbage Collection",
note = "Summary appears in Wilson and Hayes' OOPSLA'91 GC workshop report",
crossref = "OOPSLA91-gc",
}


@inproceedings{boeh91c,
title = "Hardware and Operating System Support for Conservative Garbage Collection",
author = "Hans-Juergen Boehm",
crossref = "IWOOOS91",
pages = {61--67},
}

@article{boeh92,
author = "Hans-Juergen Boehm and David R. Chase",
title = "A Proposal for Garbage-Collector-Safe {C} Compilation",
journal = "Journal of C Language Translation",
mon = dec,
year = 1992,
pages = "126--141",
URL = {http://reality.sgi.com/employees/boehm_mti/papers/boecha.ps.gz},
comment = "on GC in the presence of compiler optimizations?"
}


@inproceedings{boeh93,
title = "Space Efficient Conservative Garbage Collection",
author = "Hans-Juergen Boehm",
crossref = "PLDI93",
pages = "197--206",
URL = "http://www.hpl.hp.com/personal/Hans_Boehm/gc/index.html",
}

@inproceedings{boeh93a,
author = "Hans-Juergen Boehm and Zhong Shao",
title = "Inferring Type Maps during Garbage collection",
crossref = "OOPSLA93-gc",
URL = "ftp://daffy.cs.yale.edu/pub/papers/shao/gc.ps"
}

@article{boeh95,
author = "Hans-Juergen Boehm",
title = "Dynamic Memory Allocation and Garbage Collection",
journal = "Computers in Physics",
volume = 9,
number = 3,
month = "May/June",
year = 1995,
pages = "297--303"
}

@inproceedings{boeh96,
author = "Hans-Juergen Boehm",
title = "Simple Garbage-Collector Safety",
URL = "http://www.hpl.hp.com/personal/Hans_Boehm/gc/index.html",
pages = "89--98",
crossref = "PLDI96"
}

@inproceedings{boeh00,
author = {Hans-Juergen Boehm},
title = {Reducing Garbage Collector Cache Misses},
crossref = {ISMM2000},
abstract = {
Cache misses are currently a major factor in the cost of garbage
collection, and we expect them to dominate in the future.  Traditional
garbage collection algorithms exhibit relatively little temporal
locality; each live object in the heap is likely to be touched exactly
once during each garbage collection. We measure two techniques for
dealing with this issue:  prefetch-on-grey, and lazy sweeping. The
first of these is new in this context. Lazy sweeping has been in common
use for a decade. It was introduced as a mechanism for reducing paging
and pause times; we argue that it is also crucial for eliminating cache
misses during the sweep phase. Our measurements are obtained in the
context of a non-moving garbage collector. Fully copying garbage
collection inherently requires more traffic through the cache, and thus
probably also stands to benefit substantially from something like the
prefetch-on-grey technique. Generational garbage collection may reduce
the benefit of these techniques for some applications, but experiments
with a non-moving generational collector suggest that they remain quite
useful.
}
}

@inproceedings{boeh01,
author = {Hans-Juergen Boehm},
title = {Bounding Space Usage of Conservative Garbage Collectors},
crossref = {POPL02},
URL = {http://www.hpl.hp.com/techreports/2001/HPL-2001-251.html}
}

@inproceedings{boeh03,
author = {Hans-Juergen Boehm},
title = {Destructors, Finalizers, and Synchronization},
crossref = {POPL03},
}

@techreport{boer92,
author = "de Boer, F. S. and Klop, J. W.",
title = "Asynchronous Communication in Process Algebra: Extended Abstract",
institution = "Stichting Mathematisch Centrum",
year = 1992,     
number = "CS-R9206",
month = Jan,
abstract = "We study the paradigm of asynchronous process 
communication, as contrasted with the synchronous communication 
mechanism which is present in process algebra frameworks such as 
CCS, CSP and ACP. We investigate semantics and axiomatizations 
with respect to various observability criteria: bisimulation, 
traces and abstract traces.  Our aim is to develop a process 
theory which can be regarded as a kernel for languages based on 
asynchronous communication, like data flow, concurrent logic 
languages and concurrent constraint programming."
}

@inproceedings{bogd99,
title = {Removing Unnecessary Synchronization in {J}ava},
author = {Jeff Bogda and Urs H\"{o}lzle},
pages = {35--46},
crossref = {OOPSLA99},
comment = {By analysing which objects escape threads, we can avoid synchronisations.}
}

@inproceedings{boiz86,
author = "P. Boizumault",
title = "A General Model to Implement {\it dif} and {\it freeze}",
crossref = "ICLP86"
}

@article{borm02a,
title = {Sensible Sanitation --- Understanding the {IBM} {J}ava Garbage Collector, Part 1: Object allocation},
author = {Sam Borman},
journal = {IBM developerWorks},
month = aug, 
year = 2002,
URL = {http://www-106.ibm.com/developerworks/ibm/library/i-garbage1/},
abstract = {This article is the first of three in a series on the IBM
Java Garbage Collector (GC), a storage manager for the IBM Java
development kits and runtime environments. The series will cover:
storage areas used by GC; object allocation; garbage collection; how
external interfaces work; and verbosegc and other command line
parameters.
This article discusses how objects are allocated in the Java heap for
garbage collection. It describes the layout of an object and examines
some of the data areas, such as the heap and the free list. The author
also discusses direct allocation from the heap and thread local
allocation, and gives some recommendations for controlling the heap
size. Information in this article reflects the Java 1.2.2 through 1.3.1
versions.}
}

@article{borm02b,
title = {Sensible Sanitation --- Understanding the {IBM} {J}ava Garbage Collector, Part 2: Garbage Collection},
author = {Sam Borman},
journal = {IBM developerWorks},
month = aug, 
year = 2002,
URL = {http://www-106.ibm.com/developerworks/ibm/library/i-garbage2/},
abstract = {This is the second of three articles in a series on the IBM
Java Garbage Collector (GC), which is a storage manager for the IBM
Java development kits and runtime environments. Part 1 in this series
covered object allocation, and the next article will discuss verbosegc
and other command line parameters. In this article Sam Borman reviews
how garbage collection works, and describes the three main phases of
GC: mark, sweep, and compact. He also discusses concurrent mark and
parallel bitwise sweep. The article includes a brief discussion of
reference objects, heap expansion, and heap shrinkage. Information in
this article reflects the Java 1.2.2 through 1.3.1 release levels.}
}

@article{borm02c,
title = {Sensible Sanitation --- Understanding the {IBM} {J}ava Garbage Collector, Part 3: \texttt{verbosegc} and command-line},
author = {Sam Borman},
journal = {IBM developerWorks},
month = sep, 
year = 2002,
URL = {http://www-106.ibm.com/developerworks/ibm/library/i-garbage3/},
abstract = {This is the last article in our series on the IBM Java
Garbage Collector (GC), which is a storage manager for the IBM Java
product. Part 1 in this series covered object allocation, and part 2
discussed phases of GC.

In this article Sam Borman explains how to interpret verbosegc, and how
some of the command-line parameters work. He uses examples to
illustrate verbosegc output, and describes the command line parameters
that influence GC and when to use them. Information in this article
reflects the Java 1.2.2 through 1.3.1 release levels.}
}

@phdthesis{boqu99,
author = {U. Boquist},
title = {Code Optimisation Techniques for Lazy Functional Languages},
school = {Chalmers University of Technology},
address = {Gothenburg, Sweden},
month = apr,
year = 1999
}

@inproceedings{bowm93,
author = "Howard Bowman and John Derrick and Richard E. Jones",
title = "Modelling Garbage Collection Algorithms",
booktitle = "International Workshop on Concurrency in Computational Logic,
City University, London, 13 December 1993",
month = dec,
year = 1993,
comment = "Initial report of attempts to model CRC algorithms using 
CCS and temporal logic."
}

@inproceedings{boya03,
author = {Chandrasekhar Boyapati and Alexandru Salcianu and {Beebee, Jr.}, William and Martin Rinard},
title = {Ownership Types for Safe Region-Based Memory Management in {R}eal-{T}ime {J}ava},
crossref = {PLDI03}
}

@incollection{boye72,
author = "R. S. Boyer and J. S. Moore",
title = "The Sharing of Structure in Theorem-Proving Programs",
booktitle = "Machine Intelligence",
editor = "B. Meltzer and Donald Michie",
publisher = "Edinburgh University Press",
pages = "101--116",
year = 1972,
comment = "The first implementations of logic programming used Boyer-Moore's 
`structure sharing' which represents a term with a pair of pointers, one 
to a static model and the other to an `environment'.",
}

@article{boys93,
title = "Reducing Object Storage Requirements in a Multi-User Environment",
author = "P. Boysen and P. Shah",
journal = SPE,
volume = 23,
number = 2,
month = mar,
year = 1993,
pages = "243--253"
}

@article{bozm84,
author = "G. Bozman and W. Buco and T. P. Daly and W. H. Tetzlaff",
title = "Analysis of Free Storage Algorithms --- Revisited",
journal = ISJ,
volume = 23,
number = 1,
pages = "44-64",
year = 1984
}

@article{bozm84a,
title = "The Software Lookaside Buffer Reduces Search Overhead with Linked Lists
",
author = "Gerald Bozman",
journal = CACM,
publisher = ACM,
volume = 27,
number = 3,
month = mar,
year = 1984,
pages = "222--227"
}


@incollection{bran71,
author = "P. Branquart and J. Lewi",
title = "A Scheme of Storage Allocation and Garbage Collection for {A}lgol--68",
crossref = "Algol68",
pages = "198--238",
}

@inproceedings{brec01,
title = {Controlling Garbage Collection and Heap Growth to Reduce the Execution Time of {J}ava Applications},
author = {Tim Brecht and Eshrat Arjomandi and Chang Li and Hang Pham},
crossref = {OOPSLA01}
}

@article{bren89,
title = "Efficient Implementation of the First-Fit Strategy for Dynamic Storage Allocation",
author = "R. P. Brent",
pages = "388--403",
journal = toplas,
publisher = ACM,
year = 1989,
month = jul,
volume = 11,
number = 3
}


@phdthesis{bris92,
author = "P. Brisset",
title = "Compilation de $\lambda${P}rolog",
school = {Universit\'{e} de Rennes},
year = 1992,
comment = "MALI uses copying for lists of goals.",
}

@mastersthesis{brit75,
author = {Dianne Ellen Britton},
title = {Heap Storage Management for the Programming Language {P}ascal},
school = {University of Arizona},
year = 1975,
URL = {http://druseikis.com/dbritton/msthesis/}
}


@article{brob03,
author = {Magnus Broberg and Daniel H\"{a}ggander and Per Lid\'{e}n and Lars Lundberg},
title = {Improving the Performance of Multiprocessor Memory Management in {J}ava},
journal = {Java Report},
note = {To appear}
}

@article{brom80,
author = "A. G. Bromley",
title = "Memory Fragmentation in Buddy Methods for Dynamic Storage Allocation",
journal = ActInf,
publisher = SV,
volume = 14,
number = 2,
month = aug,
year = 1980,
pages = "107--117"
}

@inproceedings{broo82,
author = "Rodney A. Brooks and Richard P. Gabriel and Guy L. Steele",
title = "S--1 {C}ommon {L}isp Implementation",
crossref = "LFP82",
pages = "108--113",
}


@inproceedings{broo83,
author = "Rodney A. Brooks and Richard P. Gabriel and Guy L. Steele",
title = "{LISP}-in-{LISP}: High Performance and Portability",
booktitle = "International Joint Conference on Artifical Intelligence",
year = 1983,
volume = 2,
pages = {845--849},
organization = "IJCAI"
}


@inproceedings{broo84,
title = "Trading Data Space for Reduced Time and Code Space in Real-Time 
Garbage Collection on Stock Hardware",
author = "Rodney A. Brooks",
pages = "256--262",
crossref = "LFP84",
comment = "Variation on Baker where objects are {\em always} referred to
via an indirection field iembedded in the object itself. If an object is
valid, the indirection points to itself. If it is an obsolete version in
tospace, it points to the new version. Unconditional indirection is cheaper
than checking. 
Write-barrier scheme. Expensive."
}


@phdthesis{brow84,
title = "Recursive Structures in Computer Systems",
author = "David R. Brownbridge",
school = "University of Newcastle upon Tyne",
year = 1984,
month = sep
}


@inproceedings{brow85,
author = "David R. Brownbridge",
title = "Cyclic Reference Counting for Combinator Machines",
crossref = "FPCA85",
comments = {
Presents an interesting, but incorrect algorithm 
(see \cite{salk87}), for cyclic reference counting
based on the notion of strong and weak (cycle-closing) pointers.}
}


@article{broy82,
title = "Combining Algebraic and Algorithmic Reasoning: An Approach to the {S}chorr--{W}aite Algorithm",
author = "Manfred Broy and Peter Pepper",
pages = "362--381",
journal = toplas,
publisher = ACM,
year = 1982,
month = jul,
volume = 4,
number = 3
}

@techreport{bruh87,
author = "Bruha, Ivan",
title = "Representation of Structures and Garbage Collection in 
{McMaster} {POPLOG}",
institution = "McMaster University, Department of Computer Science and 
Systems,Canada",
year = 1987,
number = "88-01"
}

@inproceedings{brus87,
author = "T. Brus and van Eekelen, M. J. C. D. and M. J. Plasmeijer and H. P. Barendregt",
title = "Clean --- A Language for Functional Graph Rewriting",
crossref = "FPCA87",
pages = "364--384"
}


@inproceedings{bruy82,
author = "Maurice Bruynooghe",
title = "A Note on Garbage Collection in {P}rolog Interpreters",
crossref = "ICLP82",
pages = {52--55}
}



@article{bruy82a,
author = "Maurice Bruynooghe",
title = "Garbage Collection in {P}rolog Implementations",
journal = "Logic Programming",
editor = {S.-A. T\"{a}rnlund and K. L. Clark},
pages = "83--98",
note = "Also in Workshop on Logic Programming, Debrecen, Hungary, 1980",
year = 1980,
comment = "Structure copying:simplifies gc algorithms (mell80).",
}



@incollection{bruy84,
author = "Maurice Bruynooghe",
title = "Garbage Collection in {P}rolog Implementations",
booktitle = "Implementations of {P}rolog",
editor = "J. A. Campbell",
year = 1984,
pages = "259--267",
publisher = "Ellis-Horwood",
comment = "Traverse goal-statements in the backtrack stack but consider binding status.",
}



@incollection{bruy86,
title = "Compile-Time Garbage Collection or {H}ow to Transform Programs in an 
Assignment-Free Language into Code with Assignments",
author = "Maurice Bruynooghe",
pages = "113--129",
booktitle = "Program specification and transformation. The {IFIP} {TC2/WG} 2.1 
Working Conference, {B}ad {T}olz, {G}ermany", 
month = "April 15--17, 1986",
editor = "L. G. L. T. Meertens",
publisher = "North-Holland",
address = "Amsterdam",
year = "1987"
}


@techreport{bruy86a,
author = "Maurice Bruynooghe",
title = "Compile-Time Garbage Collection",
institution = "Katholieke Universiteit of Leuven",
type = "Report",
number = "CW43",
year = 1986
}

@inproceedings{bruy88,
author = "Maurice Bruynooghe and G. Janssens",
title = "An Instance of Abstract Interpretation Integrating Type and Mode Inferencing",
booktitle = "5th International Conference and Symposium on Logic Programming",
pages = "669--683",
publisher = MIT,
year = 1988
}

@techreport{burg99,
title = {The Concurrent {M}assey {H}ope+{C} Functional Language System},
author = {Peter Burgess and Nigel Perry and Robert Pointon},
type = "Report",
institution = {Massey University},
year = 1999,
note = {Available on request from Nigel Perry.},
comment = {Technique similar to that of \cite{hend02} for finding pointers.}
}

@inproceedings{burn87,
title = "Parallel Reduction Architecture",
author = "T. D. Burnett",
booktitle = "Highly Parallel Computers, Proceedings of the {IFIP} {WG} 10.3 
Working Conference for Numerical and Signal Processing Applications.
{S}ophia {A}ntipolis, {F}rance", 
month = "March 24--26",
publisher = "North-Holland",
address = "Amsterdam",
pages = "41--57",
year = "1987",
isbn = "0--444--70131--1",
abstract = {
A parallel machine architecture is presented aimed at digital
signal processing applications.  The ability of the reduction language F. P. to
express parallelism within algorithm is used as the basis for this parallel
processor.  Efficiency of operation of each individual processing element is
stressed and a novel garbage collection techniques which imposes neglible time
penalty makes a major contribution to this efficiency.  This paper reports
simulation results which indicate that the architecture is well suited to 
high performance signal processing.}
}

@article{burt00,
author = {Joshua W. Burton},
title = {Garbage Collection on the Run},
journal = Dobbs,
volume = 311,
pages = {46--53},
month = apr,
year = 2000
}

@article{burt76,
author = "F. Warren Burton",
title = "A Buddy System Variation for Disk Storage Allocation",
journal = CACM,
publisher = ACM,
volume = 19,
number = 7,
month = jul,
year = 1976,
pages = "416--417"
}

@article{burt00a,
author = {F. Warren Burton and David J. Simpson},
title = {Memory Requirements for Parallel Programs},
journal = {Parallel Computing},
volume = 26,
number = {13---14},
year = 2000,
pages = {1739---1763},
URL = {http://www.elsevier.nl/PII/S0167819100000533}
}

@inproceedings{butl86,
title = "Storage Reclamation for Object Oriented Database Systems: a Summary 
of the Expected Costs",
author = "Margaret H. Butler",
booktitle = "Proceedings --- 1986 International Workshop on Object-Oriented 
Database Systems. {P}acific {G}rove, {C}a, {USA}, {S}ept 23--26",
publisher = IEEE,
pages = "210--211",
year = 1986,
abstract = {A brief description is given of the model used for evaluating
garbage collection algorithms.  A summary is then provided of the results of a
study analyzing the input/output behavior of existing automatic storage
reclamation schemes when operating on data stored in a database management
system.  The tradeoffs that must be kept in mind when choosing a storage
reclamation scheme for a database system are examined.},
comment = {Generational hypothesis does not apply to large distributed DBs?}
}


@inproceedings{butl87,
author = "Margaret H. Butler",
title = "Storage Reclamation in Object Oriented Database Systems",
booktitle = "Proceedings of the {ACM} {SIGMOD}, San Francisco",
pages = "410--425",
month = may,
year = 1987
}

@inproceedings{cahi93,
title = "The {A}madeus {GRT} --- Generic Runtime Support for Distributed Persistent Programming",
author = {Vinny Cahill and Se\'{a}n Baker and Chris Horn and Gradimir Stavovic},
crossref = "OOPSLA93",
note = {Technical report TCD--CS--93--37}
}

@article{calc03,
title = {Program Logic and Equivalence in the Presence of Garbage Collection},
author = {Cristiano Calcagno and Peter O'Hearn and Richard Bornat},
journal = {Theoretical Computer Science},
volume = 298,
number = 3,
year = 2003,
URL = {http://www.dcs.qmw.ac.uk/~ohearn/papers/GI-tcs.ps},
}

@article{cald94,
title = {Quantifying Behavioral Differences Between {C} and {C++} Programs},
author = {Brad Calder and Dirk Grunwald and Benjamin Zorn},
journal = {Journal of Programming Languages},
year = 1994,
volume = 2,
number = 4,
pages = {313--351},
URL = {ftp://ftp.cs.colorado.edu/pub/techreports/zorn/CU-CS-698-94.ps.Z},
abstract = {Improving the performance of C programs has been a topic of great
interest for many years.  Both hardware technology and compiler
optimization research has been applied in an effort to make C programs
execute faster.  In many application domains, the C++ language is
replacing C as the programming language of choice.  In this paper, we
measure the empirical behavior of a group of significant C and C++
programs and attempt to identify and quantify behavioral differences
between them.  Our goal is to determine whether optimization
technology that has been successful for C programs will also be
successful in C++ programs.  We furthermore identify behavioral
characteristics of C++ programs that suggest optimizations that should
be applied in those programs.  Our results show that C++ programs
exhibit behavior that is significantly different than C programs.
These results should be of interest to compiler writers and
architecture designers who are designing systems to execute
object-oriented programs.}
}

@inproceedings{cald98,
title = {Cache-Conscious Data Placement},
author = {B. Calder and C. Krintz and S. John and T. Austin},
crossref = {ASPLOS98}
}

@article{camp71,
author = "John A. Campbell",
title = "A Note on an Optimal-Fit Method for Dynamic Allocation of Storage",
journal = CompJ,
publisher = BCS,
volume = 14,
number = 1,
year = 1971,
month = feb,
pages = "7--9"
}

@article{camp74,
author = "John A. Campbell",
title = "Optimal Use of Storage in a Simple Model of Garbage Collection",
journal = IPL,
publisher = NH,
volume = 3,
number = 2 ,
month = Nov,
year = 1974,
pages = "374",
}

@techreport{camp86,
title = {A Persistent Store Garbage Collector with Statistical Facilities},
author = {J. Campin and Malcolm Atkinson},
institution = {Universities of Glasgow and St. Andrews},
year = 1986
}

@phdthesis{camp93,
author = "Alvaro E. Campos",
title = "Distributed, Garbage-Collected, Persistent, Virtual Address Spaces",
school = "Princeton University",
type = "{PhD} Dissertation",
address = "Department of Computer Science",
month = jun,
year = 1993,
URL = "http://ncstrl.cs.Princeton.EDU/expand.php?id=TR-419-93"
}

@inproceedings{camp93a,
author = "Alvaro E. Campos and David R. Hanson",
title = "Garbage Collection in {EZ}",
booktitle = "Proceedings of Thirteenth International Conference on Computer Sceince",
address = "La Serena, Chile",
mont = oct,
year = 1993,
publisher = "Plenum Press",
editor = "R. Baeza-Yates"
}

@techreport{cann88,
author = "D. C. Cann and Rod R. Oldehoeft",
title = "Reference Count and Copy Elimination for Parallel Applicative Computing",
institution = "Department of Computer Science, Colorado State University",
address = "Fort Collins, CO",
number = "CS--88--129",
year = 1988
}

@manual{cann92,
author = "D. C. Cann and J. T. Feo and A. D. W. Bohoem and Rod R. Oldehoeft",
title = "{SISAL} Reference Manual: Language Version 2.0",
year = 1992,
URL = "ftp://sisal.llnl.gov/pub/sisal/publications.dir/s2.manual.ps.Z"
}

@inproceedings{cann00,
title = {Contaminated Garbage Collection},
author = {Dante Cannarozzi and Michael Plezbert and Ron Cytron},
crossref = {PLDI00}
}

@inproceedings{capl88,
author = "Michael Caplinger",
title = "A Memory Allocator with Garbage Collection for {C}",
booktitle = "{USENIX} Winter Conference",
publisher = UA,
pages = "323--323",
year = 1988
}

@inproceedings{card84,
author = "Luca Cardelli",
title = "Compiling a Functional Language",
pages = "208--217",
crossref = "LFP84",
}

@techreport{card88,
author = "Luca Cardelli and James Donahue and Lucille Glassman and Mick Jordan 
and Bill Kalsow and Greg Nelson",
title = "Modula-3 Report (revised)",
institution = "DEC Systems Research Center and Olivetti Research Center",
type = "Research Report",
number = "PRC--131",
year = 1988
}

@incollection{card91,
author = {Luca Cardelli},
title = {Typeful Programming},
booktitle = {Formal Description of Programming Concepts},
editor = {E.J. Neuhold and M. Paul},
publisher = SV,
year = 1991,
URL = {http://research.microsoft.com/research/cambridge/luca/Papers/TypefulProg.ps},
note = {Revised 1 January, 1993}
}

@article{card92,
author = "Luca Cardelli and James Donahue and Lucille Glassman
and Mick Jordan and Bill Kalsow and Greg Nelson",
title = "{Modula-3} Language Definition",
journal = SIGPLAN,
publisher = ACM,
volume = 27,
number = 8,
pages = "15--42",
month = aug,
year = 1992,
}

@article{carl92,
author = "Carlini, Giuliano and Rendina, Susan",
title = "Garbage Collection for {C} Programs",
journal = Dobbs,
volume = 17,
number = 11,
month = nov,
year = 1992
}

@inproceedings{carl87,
author = "M. Carlsson",
title = "Freeze, Indexing and Other Implementation Issues in the {WAM}",
crossref = "ICLP87",
pages = "40--58",
}


@inproceedings{carl90,
author = "Svante Carlsson and Christer Mattsson and Mats Bengtsson",
title = "A Fast Expected-Time Compacting Garbage Collection Algorithm",
crossref = "OOPSLA90-gc",
}

@inproceedings{carl91,
author = "Svante Carlsson and Christer Mattsson and Mats Bengtsson and 
Patricio Poblete",
title = "A New Compacting Garbage Collection Algorithm with a Good 
Average-Case Performance",
booktitle = "STACS-91",
year = 1991
}

@inproceedings{cart89,
title = "Cascade: Hardware for High/Variable Precision Arithmetic.",
author = "A. M. Carter",
booktitle = "Proceedings: 9th Symposium on Computer Arithmetic ({ARITH9}). 
{S}anta {M}onica, {S}ept 6--8",
publisher = IEEE,
pages = "184--191",
year = 1989,
abstract = {The Cascade hardware architecture for high/variable precision
arithmetic is described.  It uses a radix-16 redundant signed-digit number
representation and directly supports single or multiple precision addition,
subtraction, multiplication, division, extraction of the square root, and
computation of the greatest divisor.  It is object-oriented and implements an
abstract class of objects, variable precision integers.  It provides a complete
suite of memory management functions implemented in hardware, including a
garbage collector.  The Cascade hardware permits free tradeoffs of space 
versus time.}
}


@article{case91,
author = "Brian Case",
title = "{PA--RISC} Provides Rich Instruction Set within {RISC} Framework",
journal = "Microprocessor Report",
volume = 5,
number = 6,
month = apr,
year = 1991
}

@inproceedings{caud86,
author = "Caudill, Patrick J. and Allen Wirfs-Brock",
title = "A Third-Generation {S}malltalk-80 Implementation",
crossref = "OOPSLA86",
pages = "119--130",
comment = {
In order to resolve the problem of too much tenured garbage,
objects have to pass through multiple generations (each of which is subject to
periodic reclamation) before obtaining tenure.
Copying collector but uses a separate large object area.
Tektronix 4406 Smalltalk, using semispaces for each of 8 generations. }
}

@manual{cent92,
title = "Code{C}enter, The Programming Environment",
key = "CenterLine",
organization = "CenterLine Software",
address = "Cambridge, MA",
year = 1992
}


@inproceedings{chai84,
author = {J\'{e}rome Chailloux and Matthieu Devin and Jean-Marie Hullot},
title = "Le\_{L}isp: A Portable and Efficient {L}isp System",
crossref = "LFP84",
pages = "113-122",
comment = "The heap is divided into separate areas, which are collected
simultaneously but by distinct, although co-operating, strategies."
}

@article{chai90,
author = "Chaiken, David and Craig Fields and Kiyoshi Kurihara and Anant
Agarwal",
title = "Directory-Based Cache Coherence in Large-Scale Multiprocessors",
journal = "IEEE Computer",
publisher = IEEE,
volume = 23,
number = 6,
month = jun,
year = 1990,
pages = "49--58"
}


@phdthesis{chai91,
author = "Emmanuel Chailloux",
title = "Compilation des Langages Fonctionnels: {CeML} un Traducteur {ML}
vers {C}",
school = {Universit\'{e} de Paris VII},
year = 1991,
month = nov
}

@inproceedings{chai92,
title = "A Conservative Garbage Collector with Ambiguous Roots, for Static Type Checking Languages",
author = "Emmanuel Chailloux",
crossref = "IWMM92",
}


@inproceedings{chai92a,
author = "Emmanuel Chailloux",
title = "An Efficient Way of Compiling {ML} to {C}",
booktitle = "{ACM} {SIGPLAN} {W}orkshop on {ML} and its Applications, San
Francisco",
publisher = ACM,
editor = "David MacQueen",
year = 1992,
month = jun
}

@inproceedings{cham89,
title = "An Efficient Implementation of {SELF}, a Dynamically-Typed
Object-Oriented Language Based on Prototypes",
author = "Craig Chambers and David M. Ungar and Elgin Lee",
crossref = "OOPSLA89",
pages = "48--70",
}


@inproceedings{cham89a,
author = "Craig Chambers and David M. Ungar",
title = "Customization:  Optimizing Compiler Technology for {S}elf, a
Dynamically-Typed Object-Oriented Language",
booktitle = "Proceedings of {SIGPLAN} '89",
publisher = ACM,
pages = "146--160",
year = 1989
}


@article{cham91,
title = "An Efficient Implementation of {SELF}, a Dynamically-Typed
Object-Oriented Language Based on Prototypes",
author = "Craig Chambers and David M. Ungar and Frank Jackson",
journal = LSC,
volume = 4,
year = 1991,
pages = "243--281"
}


@inproceedings{cham91a,
author = "Craig Chambers",
title = "Cost of Garbage Collection in the {SELF} System",
crossref = "OOPSLA93-gc",
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/GC91/chambers.ps"
}

@phdthesis{cham92,
author = "Craig Chambers",
title = "The Design and Implementation of the {SELF} Compiler, an Optimizing
Compiler for an Objected-Oriented Programming Language",
school = "Stanford University",
month = mar,
year = 1992,
comment = "Improvement of (wils89b) card-marking scheme."
}

@inproceedings{chan89,
author = "Ellis E. Chang and Randy H. Katz",
title = "Exploiting Inheritance and Structure Semantics for
Effective Clustering and Buffering in an Object-Oriented {DBMS}",
crossref = "SIGMOD89",
pages = "348--357"
}


@article{chan84,
title = "Reliable Broadcast Protocols",
author = "J. Chang and N. F. Maxemchuk",
journal = TransCompSys,
publisher = ACM,
volume = 2,
nunber = 3,
pages = "251--273",
month = aug,
year = 1984,
comment = "Atomic multicast protocol."
}

@inproceedings{chan93,
author = "J. Morris Chang and Edward F. Gehringer",
title = "Evaluation of an Object-Caching Coprocessor Design for Object-Oriented Systems",
booktitle = "Proceedings of IEEE International Conference on Computer
Design",
publisher = IEEE,
month = oct,
year = 1993,
comment = "Coprocessor manages objects in the cache by reference
counting"
}

@inproceedings{chan93a,
author = "J. Morris Chang and Edward F. Gehringer",
title = "Performance of Object Caching for Object-Oriented Systems",
booktitle = "Proceedings of International Conference on Very Large Scale
Integration, VLSI'93, Grenoble, France",
month = sep,
year = 1993,
comment = "Coprocessor manages objects in the cache by reference
counting"
}

@article{chan96,
author = {J. Morris Chang and Edward F. Gehringer},
title = {A High-Performance Memory Allocator for Object-Oriented Systems},
journal = IEEETransComp,
month = mar,
year = 1996,
pages = {357--366}
}

@article{chan97,
author = {J. Morris Chang},
title = {An Optimized Two-Dimensional Buddy System for Dynamic Resource Allocation},
journal = {Journal of High Performance Computing},
volume = 4,
number = 1,
month = dec,
year = 1997,
pages = {47--55}
}

@inproceedings{chan98,
author = {J. Morris Chang and Woo Hyong Lee},
title = {A Study on Memory Allocations in {C++}},
booktitle = {Proceedings of 14th International Conference on Advanced Science and Technology (ICAST'98)},
address = {Naperville, IL},
month = apr,
year = 1998,
pages = {53--62}
}

@inproceedings{chan99,
author = {J. Morris Chang and W. Srisa-an and Chia-Tien Dan Lo},
title = {{DMMX} (Dynamic Memory Management Extensions): An Introduction},
booktitle = {Workshop notes of ICCD workshop on Hardware Support for Objects and Microarchitectures for Java},
address = {Austin, TX},
month = oct,
year = 1999,
pages = {11-14}
}

@inproceedings{chan99a,
author = {J. Morris Chang and Woo Hyong Lee and Yusuf Hasan},
title = {Measuring Dynamic Memory Invocations in Object-Oriented Programs},
booktitle = {Proceedings of 18th IEEE International Performance Conference on Computers and Communications},
address = {Phoenix, AZ},
month = feb,
year = 1999,
pages = {268--274}
}

@inproceedings{chan99b,
author = {J. Morris Chang and W. Srisa-an and Chia-Tien Dan Lo},
title = {{OMeX}: Object Management Extensions for Embedded Systems}, 
booktitle = {The Second International Workshop on Compiler and Architecture Support for Embedded Systems (CASES'99)}, 
address = {Washington, DC}, 
month = oct, 
year = 1999
}

@article{chan00,
author = {J. Morris Chang and C.H. Daugherty},
title = {An Efficient Data Structure for Dynamic Memory Management},
journal = JSS,
year = 2000,
note = {accepted for publication, Summer 2000}
}

@inproceedings{chan00b,
author = {J. Morris Chang and W. Srisa-an and Chia-Tien Dan Lo},
title = {Architectural Support for Dynamic Memory Management},
booktitle = {Proceedings of IEEE International Conference on Computer Design},
address = {Austin, TX},
month = sep,
year = 2000,
pages = {99--104}
}

@inproceedings{chan00c,
author = {J. Morris Chang and Chia-Tien Dan Lo and Edward F. Gehringer},
title = {Hardware Support for Dynamic Memory Management},
booktitle = {Workshop notes of International Symposium on Computer Architecture (ISCA) workshop on Solving the Memory Wall Problem},
address = {Vancouver},
month = jun,
year = 2000}
}

@inproceedings{chan00d,
author = {J. Morris Chang and Yusuf Hasan and Woo Hyong Lee},
title = {High-performance Memory Allocator for Memory Intensive Applications},
booktitle = {Proceedings of Fourth IEEE International Conference on High Performance Computing in Asia-Pacific Region},
address = {Beijing, China},
month = may,
year = 2000,
pages = {6--12}
}

@inproceedings{chan00e,
author = {J. Morris Chang and W. Srisa-an and C.D. Lo},
title = {Hardware Support for Concurrent Garbage Collection in {SMP} Systems},
booktitle = {Proceedings of Fourth IEEE International Conference on High Performance Computing in Asia-Pacific Region},
address = {Beijing, China},
month = may,
year = 2000,
pages = {513--517}
}

@article{chan01,
author = {J. Morris Chang and W.H. Lee and W. Srisa-an},
title = {A Study of the Allocation Behavior of {C++} Programs},
journal = JSS,
year = 2001,
note = {accepted for publication, Fall 2001}
}

@article{chan02,
author = {J. Morris Chang and Witawas Srisa-an and Chia-Tien Dan Lo and Edward F. Gehringer},
title = {{DMMX}: Dynamic Memory Management Extensions},
journal = JSS,
volume = 63,
number = 3,
abstract = {Dynamic memory management allows programmers to be more
productive and increases system reliability and functionality. However,
software algorithms for memory management are slow and
non-deterministic. It is well known that object-oriented applications
tend to be dynamic memory intensive. This has led programmers to eschew
dynamic memory allocation for many real-time and embedded systems.
Instead, programmers using Java or C++ as a development language
frequently decide to allocate memory statically instead of dynamically.
In this paper, we present the design of a bitmap-based memory allocator
implemented primarily in combinational logic to allocate memory in a
small, predictable amount of time. It works in conjunction with an
application-specific instruction-set extension called the dynamic
memory management extension (DMMX). Allocation is done through a
complete binary tree of combinational logic, which allows constant-time
object creation. The garbage collection algorithm is mark sweep, where
the sweeping phase can be accomplished in constant time. This hardware
scheme can greatly improve the speed and predictability of dynamic
memory management. The proposed DMMX is an add-on approach, which
allows easy integration into any CPU, hardware-implemented Java virtual
machine, or processor in memory.},
month = sep,
year = 2002,
URL = {http://www.sciencedirect.com/science?_ob=ArticleURL&_udi=B6V0N-45BHK2S-2&_user=125871&_coverDate=09%2F15%2F2002&_alid=58536322&_rdoc=2&_fmt=full&_orig=search&_qd=1&_cdi=5651&_sort=d&_acct=C000010239&_version=1&_urlVersion=0&_userid=125871&md5=bb2d052b708f1ed95f4dc253dea98b0f}
}

@book{chan86,
title = "Efficient Use of Systems with Many Processors",
author = "R. J. Chansler",
publisher = "University of Michigan Press, Ann Arbor, MI",
series = "Computer science:  computer architecture and design",
number = 6,
year = "1986",
pages = "130",
isbn = "0--8357--1749--6",
abstract = {In the Introduction, the author says that his primary thesis is that ``the
performances of a system can be improved by relaxing the coupling among its
component parts,'' and that ``the interest [of the book] lies in the
performance domain.'' The book contains a case study of some aspects of the
garbage collector of the Cm*/STAROS system (Chapters 2, 3, and 4) and a
synthesis based on this case (Chapters 5, 6, and 7).
Chapter 2 begins by arguing about the necessity of a garbage collector for
STAROS. The author then points out that the analysis of the garbage
collector is an important topic in the performance study of a system with
many processors. Chapter 3 deals with the problem and performances of 
local garbage collection, while Chapter 4 tackles the question of ``when'' the
garbage collection must be made. From Chapter 5, the author analyzes four
types of coupling induced by contention for processors, contention for
resources, communication between processors, and synchronization. Chapter 5,
after some considerations about the case, gives programmers some
practical advice to reduce the coupling caused by the contention for
processors. Two examples of this advice are:  ``Exploit features of the
machine architecture that allow effective use of otherwise idle processors'';
and ``Allocate work to processes that need not compete for processors.''
Chapter 6 also emphasizes hardware structure; the author is ``cognizant of
the peculiarities of the hardware architecture.'' In the same chapter the
author, after an analysis of the STAROS garbage collector, ironically
observes that ``bad programs exploit multiprocessors more effectively than
good programs.'' Chapters 7 and 8 deal with two problems that are often
merged in the literature: communication and synchronization between
processors. The author says that it is often better to compute than to
communicate, and that it is necessary ``to design algorithms to be tolerant
to imprecise data.'' On the subject of synchronization, the author starts
with an introduction where ``the synchronization . . . as the task of
preventing concurrent execution of processes'' is opposed to the
``synchronization as a way to direct the attention of a process or to
assign work.'' An example from STAROS and, as usual, some advice on how 
to reduce coupling are presented.
The book is a research book and it fulfills its purpose, especially for
readers interested in the Cm*/STAROS system. The length is just right.
However, I think that two articles in a research journal would have been a
better choice for the author. The best feature of the book is the case
study. The worst is the synthesis because it is sometimes too commonplace.
The book is interesting, and the ideal reader is a graduate student or a
researcher working on multiprocessors. The title is a little misleading. A
better title would emphasize garbage collection and STAROS, which 
occupies at least two-thirds of the book.}
}


@phdthesis{chas87,
author = "David R. Chase",
title = "Garbage Collection and Other Optimizations",
school = "Rice University",
month = Aug,
year = 1987,
URL = {http://world.std.com/~chase/dissertation.pdf},
comment = "see also http://www.centerline.com/people/chase/papers/thesis/*.ps"
}



@article{chas88,
title = "Safety Considerations for Storage Allocation Optimizations",
author = "David R. Chase",
address = "Olivetti Research Center, Menlo Park, Ca",
journal = Sigplan,
publisher = ACM,
year = 1988,
volume = 23,
number = 7,
pages = "1--10"
}


@article{chas90,
author = "David R. Chase and Wegman and Zadeck",
title = "Analysis of Pointers and Structures",
journal = SIGPLAN,
publisher = ACM,
volume = 25,
number = 6,
year = 1990,
comment = "Incremental Static Single Assignment form, plus heuristics
for detecting trees, and careful treatment of evaluation order to
preserve monotonic behavior.",
abstract = {suggested reference on compile-time garbage collection. 
Imperative programs.}
}


@inproceedings{chas92,
author = "Jeffrey S. Chase and Henry M. Levy and Edward D. Lazowska and Miche
Baker-Harvey",
title = "Lightweight Shared Objects in a 64-bit Operating System",
crossref = "OOPSLA92",
}

@article{chaw03,
title = {Fine-tuning {J}ava Garbage Collection Performance:
How to detect and troubleshoot garbage collection issues with the {IBM} {J}ava Virtual Machine},
author = {Sumit Chawla},
journal = {IBM developerWorks},
month = jan, 
year = 2003,
URL = {http://www-106.ibm.com/developerworks/ibm/library/i-gctroub/},
}

@techreport{chas92a,
author = "Jeffrey S. Chase and Henry M. Levy and Miche Baker-Harvey
and Edward D. Lazowska",
title = "How To Use a 64-bit Virtual Address Space",
institution = "University of Washington",
address = "Seattle, Washington",
number = "92-03-02",
year = 1992,
month = feb
}

@inproceedings{chea00,
author = {Cheadle, Andrew M. and Field, Anthony J. and Marlow Simon and Peyton-Jones, Simon L. and While, R.L},
title = {Non-stop {H}askell},
crossref = {ICFP2000},
URL = {http://portal.acm.org/citation.cfm?id=351265&coll=portal&dl=ACM&CFID=1643303&CFTOKEN=1187591},
comment = {A prototype in Haskell GHC4.01 RTS of Baker as described in \cite{whil92}.}
}

@inproceedings{chen02,
title = {Adaptive Garbage Collection for Battery-Operated Environments},
author = {G. Chen and Mahmut T. Kandemir and Narayanan Vijaykrishnan and Mary Jane Irwin and Mario Wolczko},
crossref = {JVM02},
pages = {1--12},
URL = {http://www.cse.psu.edu/~gchen/papers/jvm02.pdf}
}

@inproceedings{chen02a, 
title = {Tuning Garbage Collection in an Embedded {J}ava Environment},
author = {G. Chen and R. Shetty and Mahmut T. Kandemir and Narayanan Vijaykrishnan and Mary Jane Irwin and Mario Wolczko},
booktitle = {Proceedings of the Eighth International Symposium on High-Performance Computer Architecture (HPCA'02)},
publisher = {IEEE Computer Society},
address = {Boston, MA},
pages = {92--},
month = feb,
year = 2002,
URL = {http://www.cse.psu.edu/~gchen/papers/hpca02.pdf}
}

@article{chen02b, 
title = {Tuning Garbage Collection for Reducing Memory System Energyin an Embedded {J}ava Environment},
author = {G. Chen and R. Shetty and Mahmut T. Kandemir and Narayanan Vijaykrishnan and Mary Jane Irwin and Mario Wolczko},
journal = TECS,
publisher = ACM,
pages = {6--26},
volume = 1,
number = 1,
month = nov,
year = 2002,
URL = {http://portal.acm.org/toc.cfm?id=581888&coll=portal&dl=ACM&type=issue&idx=J840&part=transaction&WantType=transaction&title=ACM%20Transactions%20on%20Embedded%20Computing%20Systems%20%28TECS%29&CFID=7897080&CFTOKEN=61221663},
abstract = {Java has been widely adopted as one of the software
platforms for the seamless integration of diverse computing devices.
Over the last year, there has been great momentum in adopting Java
technology in devices such as cellphones, PDAs, and pagers where
optimizing energy consumption is critical. Since, traditionally, the
Java virtual machine (JVM), the cornerstone of Java technology, is
tuned for performance, taking into account energy consumption requires
reevaluation, and possibly redesign of the virtual machine. This
motivates us to tune specific components of the virtual machine for a
battery-operated architecture. As embedded JVMs are designed to run for
long periods of time on limited-memory embedded systems, creating and
managing Java objects is of critical importance. The garbage collector
(GC) is an important part of the JVM responsible for the automatic
reclamation of unused memory. This article shows that the GC is not
only important for limited-memory systems but also for
energy-constrenergy-constrained architectures. This article focuses on
tuning the GC to reduce energy consumption in a multibanked memory
architecture. Tuning the GC is important not because it consumes
a sizeable portion of overall energy during execution, but because
it influences the energy consumed in the memory during application
execution. In particular, we present a GC-controlled leakage energy
optimization technique that shuts off memory banks that do not hold live
data. Using two different commercial GCs and a suite of thirteen mobile
applications, we evaluate the effectiveness of the GC-controlled energy
optimization technique and study its sensitivity to different parameters
such as bank size, the garbage collection frequency, object allocation
style, compaction style, and compaction frequency. We observe that the
energy consumption of an embedded Java application can be significantly
more if the GC parameters are not tuned appropriately. Further, we
notice that the object allocation pattern and the number of memory
banks available in the underlying architecture are limiting factors on
how effectively GC parameters can be used to optimize the memory energy
consumption.}
}

@article{chen02c,
title = {Influence of Garbage Collection on Memory System Energy},
author = {Guangyu Chen and R. Shetty and Mahmut T. Kandemir and Narayanan Vijaykrishnan and Mary Jane Irwin and Mario Wolczko},
journal = {Transactions on Embedded Computer Systems (TECS)},
publisher = ACM,
month = nov, 
volume = 1,
number = 1,
year = 2002
}

@inproceedings{chen03a,
title = {Heap Compression for memory-Constrained {J}ava Environment},
author = {Guangyu Chen and Mahmut Kandemir and Naraya Vijaykrishnan and Mary Jane Irwin and Bernd Mathiske and Mario Wolczko},
crossref = {OOPSLA03}
}

@article{chen70,
author = " C. J. Cheney",
title = "A Non-Recursive List Compacting Algorithm",
journal = CACM,
publisher = ACM,
volume = 13,
number = 11,
pages = "677--8",
month = nov,
year = 1970,
profiel = "CESV",
abstract = {Breadth-first non-recursive Copying GC.
Avoids use of mark bits by examining pointers to see 
which semi-space they refer to.}
}

@inproceedings{chen98,
title = {Generational Stack Collection and Profile-Driven Pretenuring},
author = {Perry Cheng and Robert Harper and Peter Lee},
crossref = {PLDI98},
URL = {http://foxnet.cs.cmu.edu/papers/pscheng-pldi98.ps}
}

@inproceedings{chen01,
title = {A Parallel, Real-Time Garbage Collector},
author = {Perry Cheng and Guy Belloch},
crossref = {PLDI01},
pages = {125--136}
}

@phdthesis{chen01a,
author = {Perry Cheng},
title = {Scalable Real-Time Parallel Garbage Collection for Symmetric Multiprocessors},
school = CMU,
year = 2001,
URL = {http://reports-archive.adm.cs.cmu.edu/cs2001.html}
}

@techreport{cheo92,
author = "Cheong, Fah-Chun",
title = "Almost Tag-Free Garbage Collection for Strongly-Typed Object-Oriented Languages",
institution = "University of Michigan",
year = 1992,
number = "CSE-TR-126-92",
abstract = "Given the heavy use of dynamic storage under the 
object-oriented paradigm, efficient storage reclamation 
techniques have become especially important.  Previously, Appel 
and Goldberg have discussed compiler-supported tag-free 
collection schemes for strongly typed  languages.  This paper 
presents a more efficient, almost tag-free garbage collection 
scheme that takes into consideration the special requirements of  
object-oriented languages that are strongly typed.  Our method 
requires only a single pass over the run-time procedure-call 
stack during garbage collection, as opposed to two passes for 
Goldberg's scheme and a linear number of passes in the worst case 
for Appel's.
Furthermore, in the case of distributed languages where it is 
practically impossible to unwind the stack all the way to its 
origin while trying to identify generic variables, the methods of 
Appel and Goldberg are  not applicable.  Our scheme uses a 
generic tag vector to help identify generic variables and does 
not require any stack searches beyond the current frame.  We have 
incorporated our proposed scheme into a newly designed 
distributed object-oriented language Oasis.  This paper includes 
a  discussion of our practical implementation experience in the 
Oasis context."
}

@techreport{chev02,
author = {K. Chevalier and J. Kodumal and X. Jiang},
title = {Memory Subsystem Optimization for Functional Languages: A Case Study},
institution = {Computer Science Division, University of California, Berkeley},
month = may, 
year = 2002,
URL = {http://www.cs.berkeley.edu/~zdjiang/cs252}
}

@inproceedings{chi96,
author = {Chi-Keung Luk and Todd C. Mowry},
title = {Compiler-Based Prefetching for Recursive Data Structures},
pages = {222-233},
crossref = {ASPLOS96}
}

@inproceedings{chik87,
author = "T. Chikayama and Y. Kimura",
title = "Multiple Reference Management in {F}lat {GHC}",
booktitle = "4th International Conference on Logic Programming",
pages = "276--293",
year = 1987
}

@inproceedings{chil98,
author = {Trishul M. Chilimbi and James R. Larus },
title = {Using Generational Garbage Collection To Implement Cache-Conscious Data Placement},
pages = {37--48},
booktitle = {Proceedings of the First International Symposium on Memory Management},
address = "Vancouver, BC, Canada",
volume = "34(3)",
month = oct,
year = 1998,
abstract = {Processor and memory technology trends show a continual increase in
the cost of accessing main memory. Machine designers have tried to
mitigate the effect of this trend through a variety of techniques that
attempt to reduce or tolerate memory latency. These techniques,
unfortunately, have only been partially successful for pointer-
manipulating programs. Recent research has demonstrated that these
programs can benefit greatly from the complementary approach of
reorganizing pointer data structures to improve cache locality. This
paper describes how a generational garbage collector can be used to
achieve a cache-conscious data layout, in which objects with high
temporal affinity are placed next to each other, so they are likely to
reside in the same cache block. The paper demonstrates the feasibility
of collecting low overhead, real-time profiling information about data
access patterns for object-oriented languages, and describes a new
copying algorithm that utilizes this information to produce a
cache-conscious object layout. Preliminary results indicate that this
technique reduces cache miss rates by 21-42\%, and improves
program performance by 14-37\%. }
}

@inproceedings{chil99,
author = {Trishul M. Chilimbi and Mark D. Hill and James R. Larus},
title = {Cache-Conscious Structure Layout},
crossref = {PLDI99},
pages = {1--12}
}

@inproceedings{chil99a,
author = {Trishul M. Chilimbi and Bob Davidson and James R. Larus},
title = {Cache-Conscious Structure Definition},
crossref = {PLDI99},
pages = {13--24}
}

@inproceedings{chil00,
author = {Trishul Chilimbi and Richard E. Jones and Benjamin Zorn},
title = {Designing a Trace Format for Heap Allocation Events},
crossref = {ISMM2000},
abstract = {
Dynamic storage allocation continues to play an important role in the
performance and correctness of systems ranging from user productivity
software to high-performance servers. While algorithms for dynamic
storage allocation have been studied for decades, much of the literature is
based on measuring the performance of benchmark programs
unrepresentative of many important allocation-intensive workloads.
Furthermore, to date no standard has emerged or been proposed for
publishing and exchanging representative allocation workloads. In this
paper, we describe a preliminary design of a trace format for such
workloads and investigate its effectiveness at representing large allocation
traces. Our proposal allows for a flexible encoding of information in the trace
to achieve greater compression. We evaluate our preliminary design in two
dimensions. First, we measure how effective these encodings are at
reducing trace size. Second we consider how a meta-level specification
language could be used to describe such formats and to generate trace
readers and writers automatically. 
}
}

@inproceedings{chil01,
author = {Trishul Chilimbi},
title = {Efficient Representations and Abstractions for Quantifying and Exploiting Data Reference Locality},
crossref = {PLDI01},
}

@techreport{chin92,
author = "Ramakrishna Chinta",
title = "Hardware-Assisted Garbage Collection for the {I}con Programming Language",
institution ="Iowa State University",
number = "92--39",
month = dec,
year = 1992,
URL = "http://www.cs.iastate.edu/tech-reports/TR92-39.ps"
}

@inproceedings{chin04,
title = {Region Inference for an Object-Oriented Language}, 
author = {Wei-Ngan Chin and Florin Craciun and Shengchao Qin},
crossref = {PLDI04}
}

@article{chir96,
title = "Reference counting as a computational interpretation of linear logic",
author = "Jawahar Chirimar and Carl A. Gunter and Jon G. Riecke",
pages = "195--244",
journal = JFP,
month = mar,
year = 1996,
volume = 6,
number = 2
}

@inproceedings{chiu91,
author = "Chiueh, Tzi-cker",
title = "An Architectural Technique for Cache-level Garbage Collection",
crossref = "FPCA91",
pages = "520--537",
}

@inproceedings{choi99,
title = {Escape Analysis for {J}ava},
author = {Jong-Deok Choi and M. Gupta and Maurice Serrano and Vugranam C. Sreedhar and Sam Midkiff},
pages = {1--19},
crossref = {OOPSLA99},
comment = {By analysing which objects escape methods/threads, we can allocate on
the stack / avoid synchronisations.}
}

@mastersthesis{chri98,
author = {M. V. Christiansen and P. Velschrow},
title = {Region-based Memory Management in {J}ava},
school = DIKU,
month = may,
year = 1998
}

@article{chri84,
author = "T. W. Christopher",
title = "Reference Count Garbage Collection",
journal = SPE,
publisher = Wiley,
volume = 14,
number = 6,
pages = "503--507",
month = jun,
year = "1984",
comments = {A heap management scheme fo languages (such as Fortran) which do not have
this facility buit in.
Does not rely on the existance of {\it roots} in the graph.
His complex and inefficient algorithm actually contains
a cyclic reference count algorithm.  },
}

@inproceedings{chun00,
author = {Yoo C. Chung and Soo-Mook Moon and Kemal Ebcioglu and Dan Sahlin},
title = {Reducing Sweep Time for a Nearly Empty Heap},
booktitle = {27th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL '00)}, 
address = {Boston, MA},
publisher = ACM,
year = 2000,
month = jan
}

@inproceedings{chun00a,
author = {Yoo C. Chung and Soo-Mook Moon},
title = {Memory Allocation with Lazy Fits},
crossref = {ISMM2000},
abstract = {
Dynamic memory allocation is an important part of modern programming
languages. It is important that it be done fast without wasting too much
memory. Memory allocation using lazy fits is introduced, where pointer
increments, which is very fast, is used as the primary allocation method and
where conventional fits such as best fit or first fit are used as backup. Some
experimental results showing how lazy segregated first fit might perform are
shown, and shows that the approach has the potential to be useful in actual
systems. 
}
}


@techreport{ciep83,
author = "A. Ciepielewski and Seif Haridi",
title = "Storage Models for {O}r-Parallel Execution of Logic Programs",
institution = "Royal Institute of Technology",
address = "Stockholm, Sweden",
number = "TRITA--CS--8301",
year = 1983
}



@article{clar75,
author = "Douglas W. Clark",
title = "A Fast Algorithm for Copying Binary Trees",
journal = IPL,
publisher = NH,
volume = 9,
number = 3 ,
month = Dec,
year = 1975,
pages = "62--63",
comments = {algorithm for copying lists without using a atack or mark bits.
It differs from the moving algorithms in that the altered contents of old lists
are later restored to their original values.},
}


@article{clar76,
author = "Douglas W. Clark",
title = "An Efficient List Moving Algorithm Using Constant Workspace",
journal = CACM,
publisher = ACM,
volume = 19,
number = 6 ,
month = Jun,
year = 1976, 
pages = "352--354",
comments = {Presents an optimization to the copying algorithm (feni69) by moving a list into
a contiguous area of the memory space with the stack implicit in the list being
moved. Clark (clar76) shows that his algorithm is in most cases more efficient
than both Cheney's (chen70) and Reingold's (rein73).},
}


@article{clar77,
author = "Douglas W. Clark and C. Cordell Green",
title = "An Empirical Study of List Structure in {L}isp",
journal = CACM,
publisher = ACM,
volume = 20,
number = 2,
month = Feb,
year = 1977, 
pages = "78--86",
comment = {
On average, in list structures used in practice, non-atomic car fields 1/3 of
time, non-atomic cdr fields 3/4 time (implies average list length = 4).
Thus preorder traversal restricts depth
of stack to be proportional to longest car path in pre-order spanning tree.
Longest car path is likely to be shorter than the longest cdr path.
[What about difference between APP cells and CONS cells? -- rej]
Only 2--10 percent have RC>1.
Using a Fenichel and Yochelson type copying algorithm, and following list cdr's
before car's (post-order), get over 98 percent cdr-direction linearisation (i.e. cdr
points to next cell). Percentage of off-page pointers following linearisation 
varied between 2.7 and 8.4 percent.
Clever cons routine (to attempt to place cons cells on the same page as
arguments) are no more effective than naive routines.
Integers 0--15 account for a significant proportion of pointers to atoms.
Allocation ordering is usually more similar to subsequent access orderings
than arbitrary orderings imposed by a garbage collector.  }
}


@article{clar78a,
author = "Douglas W. Clark",
title = "A Fast Algorithm for Copying List Structures",
journal = CACM,
publisher = ACM,
volume = 21,
number = 5 ,
month = May,
year = 1978,
pages = "351--357",
comments = {algorithm for copying lists without using a stack or mark bits.
It differs from the moving algorithms in that the altered contents of old lists
are later restored to their original values.},
}


@article{clar78b,
author = "Douglas W. Clark and C. Cordell Green",
title = "A Note on Shared List Structure in {L}isp",
journal = IPL,
publisher = NH,
volume = 7,
number = 6,
month = Oct,
year = 1978, 
pages = "312--314",
}


@article{clar79,
author = "Douglas W. Clark",
title = "Measurements of Dynamic List Structure in {L}isp",
journal = TransSWE,
publisher = ACM,
volume = 5,
number = 1,
month = Jan,
year = 1979,
pages = "51--59",
comment = {Allocation ordering is usually more similar to subsequent access orderings
than arbitrary orderings imposed by a garbage collector.  }
}

@article{clar96,
author = "Charles L. A. Clarke and Dave Mason",
title = "Compacting Garbage Collection can be Fast and Simple",
journal = SPE,
publisher = Wiley,
pages = "177--194",
volume = 26,
number = 2,
month = feb, 
year = 1996,
URL = "http://plg.uwaterloo.ca/~claclark/gc.ps"
}

@misc{clic03,
author = {Cliff Click},
title = {Performance Myths Exposed},
year = 2003,
howpublished = {Talk at JavaOne 2003},
URL = {http://servlet.java.sun.com/javaone/resources/content/sf2003/conf/sessions/pdfs/1522.pdf}
}

@inproceedings{clin88,
author = "William D. Clinger and Anne Hartheimer and Erik Ost",
title = "Implementation Strategies for Continuations",
crossref = "LFP88",
pages = "124--131",
}

@inproceedings{clin97,
author = {William D. Clinger and Lars T. Hansen},
institution = {Northeastern University},
title = {Generational Garbage Collection and the {R}adioactive {D}ecay Model},
pages = {97--108},
crossref = {PLDI97}
}


@article{cock84,
author = "Cockshott,  W. and Malcolm Atkinson and K. Chisholm and P. Bailey
and Ron Morrison",
title = "Persistent Object Management System",
journal = SPE,
volume = 14,
number = 1,
month = jan,
year = 1984,
pages = "49--71"        }

@manual{code93,
title = "Alloc-{GC}: The Garbage Collecting Replacement for malloc()",
key = "Codewright's Toolworks",
organization = "Codewright's Toolworks, San Pedro, CA",
year = 1993
}

@article{coff83,
author = "{Coffman, Jr.}, E. G.",
title = "An Introduction to Combinatorial Models of Dynamic Storage Allocation",
journal = "SIAM Review",
volume = 25,
number = 3,
month = jul,
year = 1983,
pages = "311--325"
}

@article{coff85,
author = "{Coffman, Jr.}, E. G. and T. T. Kadota and L. A. Shepp",
title = "On the Asymptotic Optimality of First-Fit Storage Allocation",
journal = IEEETransSWE,
publisher = IEEE,
volume = "SE-11",
number = 2,
month = feb,
year = 1985,
pages = {235--239}
}

@article{coff89,
author = "{Coffman, Jr.}, E. G. and F. T. Leighton",
title = "A Provably Efficient Algorithm for Dynamic Storage Allocation",
journal = "Journal of Computer and System Sciences",
volume = 38,
number = 1,
month = feb,
year = 1989,
pages = "2--35"
}


@article{cohe67a,
author = "Jacques Cohen",
title = "A Use of Fast and Slow Memories in List-Processing Languages",
journal = CACM,
publisher = ACM,
volume = 10,
number = 2,
month = Feb,
year = 1967,
pages = "82--86",
}


@article{cohe67b,
author = "Jacques Cohen and  Laurent Trilling",
title = "Remarks on Garbage Collection Using a Two Level Storage",
journal = "BIT",
volume = 7,
number = 1,
year = 1967, 
pages = "22--30",
comment = "2 pointer compactor"
}


@article{cohe72,
author = "Jacques Cohen and  C. Zuckerman",
title = "Evalquote in Simple {F}ortran: A Tutorial on Interpreting {L}isp",
journal = "BIT",
volume = 12,
number = 3,
year = 1972,
pages = "299--317",
comments = {convenient manner of implementing the tag bit in certain lisp
machines. It takes advantage of the fact that all pointers refer to only odd
(or only even) addresses, since two words are always used to implement a lisp
cell},
}


@article{cohe81,
author = "Jacques Cohen",
title = "Garbage Collection of Linked Data Structures",
journal = "Computing Surveys",
publisher = ACM,
volume = "13(3)",
pages = "341--367",
month = sep,
year = "1981",
abstract = {A concise and unified view of the numerous existing algorithms for
performing garbage collection of linked data structures is presented.  The
emphasis is on garbage collection proper, rather than on storage 
allocation.
First, the classical garbage collection algorithms are , and their
marking and collecting phases, with and without compacting, are 
discussed.
Algorithms describing these phases are classified according to the type of
cells to be collected = "those for collecting single-sized cells are simpler than
those for varisized cells.  Recently proposed algorithms are presented and
compared with the classical ones.  Special topics in garbage collection are
also covered.  A bibliography with topical annotations is included},
comments = {Classical reference in the field --- excellent paper}
}


@article{cohe83,
title = "Comparison of Compacting Algorithms for Garbage Collection",
author = "Jacques Cohen and Alexandru Nicolau",
journal = TOPLAS,
publisher = ACM,
year = 1983,
mon = oct,
volume = 5,
number = 4,
pages = "532--553",
abstract = {Storage management is an important component of the execution-time
environment for many higher-level languages being developed at this time.
An important technique for storage management is compaction of the active
cells toward one end of memory, leaving a single, large, unallocated block
to satisfy further allocation requests. This paper compares four 
compaction algorithms.
The methodology for algorithm comparison is that of deriving mathematical
equations for their behavior. Each of them is largely linear in  a, the
ratio of occupied memory to total memory. These equations are then
evaluated for a set of conditions similar to LISP on a DEC--10. The paper
claims that this method can easily be applied to other conditions, though
it does little to justify this claim.
The methods studied are those of LISP 2 [1], Jonkers [2], Fitch and Norman
[3], and Morris [4, 5]. The last of these is shown to be considerably
slower than the others. The LISP 2 collector is fastest by a small margin,
but requires an entire extra word in each allocated cell. This leaves two
methods, with little to choose between them; on the basis of the data, I
would choose Jonkers' method because it was slightly faster, and is
somewhat shorter and simpler to code.}
}

@inproceedings{cohn97,
title = {Predicting lifetimes in dynamically allocated memory},
author = {David Cohn and Satinder Singh},
booktitle = {Advances in Neural Information Processing Systems 9},
editor = {M. Mozer and others},
year = 1997
}

@article{coll60,
author = "George E. Collins",
title = "A Method for Overlapping and Erasure of Lists",
journal = CACM,
publisher = ACM,
volume = 3,
number = 12,
month = dec,
year = 1960,
pages = "655--657",
comment = "The classic Reference Counting reference."
}

@article{oll61,
author = "George E. Collins",
title = "Experience in Automatic Storage Allocation",
journal = CACM,
publisher = ACM,
volume = 4,
number = 10,
month = oct,
year = 1961,
pages = "436--440"
}


@techreport{coll65,
title = "{REFCO III}, a Reference Count List Processing System for the {IBM} 7094",
author = "George E. Collins",
type = "Research Report",
institution = IBM,
number = "{RC}-1436",
year = 1965,
month = may
}

@inproceedings{coln98,
author = {Dominique Colnet and Philippe Coucaud and Olivier Zendra},
title = {Compiler Support to Customize the Mark and Sweep Algorithm},
pages = {154--165},
crossref = {ISMM98},
abstract = {Mark and sweep garbage collectors (GC) are classical but
still very efficient automatic memory management systems. Although
challenged by other kinds of systems, such as copying collectors, mark
and sweep collectors remain among the best in terms of performance.

This paper describes our implementation of an efficient mark and sweep
garbage collector tailored to each program. Compiler support provides
the type information required to statically and automatically generate
this customized garbage collector. The segregation of objects by type
allows the production of a more efficient GC code. This technique,
implemented in SmallEiffel, our compiler for the object-oriented
language Eiffel, is applicable to other languages and other garbage
collection algorithms, be they distributed or not.

We present the results obtained on programs featuring a variety of
programming styles and compare our results to other high quality
garbage collectors. }
}

@article{colv95,
author = {G. Colvin},
title = {Smart Pointer for {C++} garbage Collection},
journal = {{C/C++} Users Journal},
volume = 12,
number = 12,
month = dec,
year = 1995
}

@article{comf64,
author = "W. T. Comfort",
title = "Multiword List Items",
journal = CACM,
publisher = ACM,
volume = 7,
number = 6,
month = jun,
year = 1964
}

@techreport{conr74,
title = "A Compactifying Garbage Collector for {ECL}'s Non-Homogenous Heap",
author = "W. R. Conrad",
type = "Research Report",
institution = "Center for Research in Computing Technology, Harvard",
number = "2--74",
year = 1974,
month = feb
}

@techreport{cook93,
author = "Jonathan E. Cook and Alexander L. Wolf and Benjamin G. Zorn",
title = "The Performance of Partitioned Garbage Collection in Object Databases",
institution = "University of Colorado",
type = "Computer Science Technical Report",
number = "CU-CS-653-93",
URL = "ftp://ftp.cs.colorado.edu/pub/cs/techreports/zorn/CU-CS-653-93.ps.Z",
address = "Campus Box 430, Boulder, CO 80309",
month = jun,
year = 1993,
abstract = {The automatic reclamation of storage for unreferenced objects is very
important in object databases.  Existing language system algorithms for
automatic storage reclamation have been shown to be inappropriate.  In this
paper, we describe and evaluate several improved algorithms for automatic
storage reclamation. The algorithms are based on a technique called
partitioned garbage collection, in which a subset of the entire
database is collected independently of the rest.  Our initial investigation
concerns the policy for selecting which partition to collect.  The policies
that we developed for the algorithms are based on the intuition that the
values of overwritten pointers provide good hints about where to find garbage.
Using trace-driven simulations of the algorithms, we show that our algorithms
require less I/O to collect more garbage than existing algorithms.}
}

@techreport{cook93a,
author = "Jonathan E. Cook and Alexander L. Wolf and Benjamin G. Zorn",
title = "The Design of a Simulation System for Persistent Object Storage Management",
institution = "University of Colorado",
type = "Computer Science Technical Report",
number = "CU-CS-647-93",
address = "Campus Box 430, Boulder, CO 80309",
month = mar,
year = 1993,
URL = {ftp://ftp.cs.colorado.edu/pub/cs/techreports/zorn/CU-CS-647-93.ps.Z},
abstract = {Efficient storage management of objects is an important part of any
persistent object system.  Storage management algorithms, such as those for
clustering, caching, and garbage collection, are often complex, since they
must simultaneously satisfy a number of constraints, including low CPU
overhead, minimum space usage, and low latency.  We have designed a
simulation system that can be used to evaluate a wide variety of such
algorithms.  The system is innovative in that it uses trace-driven
simulation as well as a loosely-coupled architecture that separates out
different aspects of storage management policy, machine hardware, and
simulation control into separate modules. Examples of such modules are those
for storage allocation, object connectivity, physical characteristics, and
cost modeling.  The modules communicate using message multicast (i.e.,
selective broadcast).  This approach supports rapid
prototyping and rapid evaluation of alternative storage management algorithms.}
}

@inproceedings{cook94,
author = "Jonathan E. Cook and Alexander L. Wolf and Benjamin G. Zorn",
title = "Partition Selection Policies in Object Databases Garbage Collection",
booktitle = "Proceedings of ACM SIGMOD International Conference on the Management of Data",
address = "Minneapolis",
editor = "Richard T. Snodgrass and Marianne Winslett",
publisher = ACM,
volume = "23(2)",
pages = "317--382",
month = may,
year = 1994
}

@inproceedings{cook96,
title = "Semi-automatic, Self-adaptive Control of Garbage Collection Rates in Object Databases",
author = "Jonathan E. Cook and Artur Klauser and Alexander L. Wolf and Benjamin G. Zorn",
pages = "377--388",
booktitle = "Proceedings of the 1996 ACM SIGMOD International Conference on Management of Data",
editor = "H. V. Jagadish and Inderpal Singh Mumick",
address = "Montreal, Quebec, Canada",
month = jun,
year = 1996,
note = "\emph{SIGMOD Record} 25(2), " # jun #" 1996",
}

@article{cook98,
title = {A Highly Effective Partition Selection Policy for Object Database Garbage Collection},
author = "Jonathan E. Cook and Alexander L. Wolf and Benjamin G. Zorn",
pages = "153--172",
journal = "IEEE Transactions on Knowledge and Data Engineering",
volume = 10,
number = 1,
year = 1998
}

@inproceedings{coop92,
author = "Eric Cooper and Scott Nettles and Indira Subramanian",
title = "Improving the Performance of {SML} Garbage Collection using Application-Specific Virtual Memory Management",
crossref = "LFP92",
pages = "43--52",
comment = "
Improve the performance of the SML--NJ memory system in
the presence of paging by a factor of up to 4.	The first factor of 2
was achieved by decreasing the size of the youngest generation.	 The
other factor of 2 was from a user-defined paging server that threw
away (didn't page out) useless pages and provided uninitialized new pages."
}
 
@book{copl92,
author = "James Coplien",
title = "Advanced {C++} Programming Styles and Idioms",
publisher = AW,
year = 1992,
comment = "Includes various GC matters including counted pointers."
}


@inproceedings{corp88,
title = "Reference Weight-Based Garbage Collection for Distributed Systems",
author = "H. Corporaal and T. Veldman and van de Goor, A. J.",
booktitle = "Proceedings of the {SION} Conference on Computing Science in the
Netherlands",
address = "Utrecht",
month = nov,
year = 1988
}


@techreport{corp89,
title = "Garbage Collection in Distributed Systems.",
author = "H. Corporaal",
type = "Internal report",
institution = "Technical University, Delft",
year = 1989
}


@inproceedings{corp90,
title = "Efficient, Reference Weight-Based Garbage Collection Method for 
Distributed Systems.",
author = "H. Corporaal and T. Veldman and van de Goor, A. J.",
booktitle = "{PARBASE-90}: International Conference on Databases, Parallel
Architectures, and Their Applications",
address = "{M}iami {B}each",
month = "7--9 March",
publisher = IEEE,
pages = "463--465",
year = 1990,
abstract = {A method of distributed garbage collection using reference counting
had been developed previously (see D. I. Bevan, PARLE'87).
This method is correct but has one severe
drawback = "the time overhead caused by the use of indirection cells.  In the
present work, the authors describe an alternative = "the reference weight table
method.  It is shown that this method does not suffer from as much time
overhead and offers general improvements.},
comment = "Appears to require communication to maintain the reference
weight tables."
}

@techreport{cort86,
author = "Anthony J. Cortemanche",
title = "{MultiTrash}, a Parallel Garbage Collector for {MultiScheme}",
type = "Bachelor's thesis",
institution = MIT,
month = jan,
year = 1986
}

@article{cour88,
title = "Improving Locality Of Reference In A Garbage-Collecting Memory 
Management-System",
author = "Robert Courts",
address = "Texas Instruments Inc, Data Syst Grp, Pob 2909, Ms 2201, Austin, Tx, 
78769",
journal = CACM,
publisher = ACM,
year = 1988,
volume = 31,
number = 9,
pages = "1128--1138",
abstract = {Modern Lisp systems make heavy use of a garbage-collecting style of
memory management.  Generally, the locality of reference in garbage-collected
systems has been very poor.  In virtual memory systems, this poor locality of
reference generally causes a large amount of wasted time waiting on page 
faults or uses excessively large amounts of main memory.  An adaptive memory
management algorithm, described in this article, allows substantial 
improvement in locality of reference.  Performance measurements indicate that 
page-wait time typically is reduced by a factor of four with constant memory 
size and disk technology.  Alternately, the size of memory typically can be 
reduced by a factor of two with constant performance.
Generational. Used exit tables indirecting pointers {\em out} of each
generation.
Texas Instruments Explorer.}
}

@techreport{couv89,
author = {Andr\'{e} Couvert and Aomar Maddi and Ren\'{e} Pedrono},
title = {Partage d'Objets dans les Syst\`{e}mes Distribu\'{e}s. Principes des
Ramasse-Miettes},
institution = "INRIA",
type = "Rapport de recherche",
number = 963,
month = jan,
year = 1989
}


@article{cram88,
title = "A Garbage Collection Algorithm For Shared Memory Parallel Processors",
author = "Jim Crammond",
address = "University of  London, Imperial College of Science and Technology,
Department of Computing, London SW7 2AZ,  England",
journal = "International Journal Of Parallel Programming",
year = 1988,
volume = 17,
number = 6,
pages = "497--522"
}

@inproceedings{cram95,
author = "Jim Crammond and Tim Lindholm",
title = "Memory Management in {Q}uintus {P}rolog",
booktitle = "Implementations of Logic Programming Systems, Budapest",
editor = "Kluwer",
year = 1995,
comment = "or is it ICLP Implementations workshop 1993?"
}

@article{cran75,
author = "B. Cranston and R. Thomas",
title = "A Simplified Recombination Scheme for the {F}ibonacci Buddy System",
journal = CACM,
volume = 18,
number = 6,
month = jul,
publisher = ACM,
year = 1975,
pages = "331--332"
}

@techreport{crar98,
author = {Karl Crary and David Walker and Greg Morrisett},
title = {Typed Memory Management in a Calculus of Capabilities},
month = jul,
year = 1998,
institution = CORNELL,
URL = {http://www.cs.cornell.edu/talc/papers/capabilities.ps.gz}
}

@inproceedings{craw91,
author = "S. C. Crawley",
title = "Local and Global Distributed Garbage Collection",
crossref = "OOPSLA91-gc",
}

@inproceedings{crar99,
title = {Typed Memory Management in a Calculus of Capabilities},
author = {Karl Crary and David Walker and Greg Morrisett},
crossref = {POPL99},
URL = {http://simon.cs.cornell.edu/home/jgm/papers/capabilities.ps}
}

@inproceedings{crid92,
author = "Regis Cridlig",
title = "An Optimising {ML} to {C} Compiler",
booktitle = "{ACM} {SIGPLAN} {W}orkshop on {ML} and its Applications",
address = "San Francisco",
editor = "David MacQueen",
publisher = ACM,
year = 1992,
month = jun
}

@mastersthesis{crit92,
author = "Critchlow, Terence J.",
title = "A Distributed Garbage Collection Algorithm",
month = aug,
year = 1992,
school = "Department of Computer Science, University of Utah",
note = "University of Utah Technical report CSTD--92--011",
URL = "ftp://ftp.cs.utah.edu/techreports/1992/UUCS-92-011.ps.Z",
abstract = "Concurrent Scheme extends the Scheme programming language, providing parallel
program execution on a distributed network.  The Concurrent Scheme environment
requires a garbage collector to reclaim global objects; objects that exist in
a portion of the global heap located on the node that created them.  Because a
global object may be referenced by several nodes, traditional garbage
collection algorithms cannot be used.  The garbage collector used must be able
to reclaim global objects with minimal disturbance to the user program, and
without the use of global state information.  It must operate asynchronously,
have a low network overhead, and be able to handle out-of-order messages.
This thesis describes a distributed reference counting garbage collector
appropriate for the reclamation of global objects in the Concurrent Scheme
environment."
}

@book{daco93,
author = "Michael C. Daconta",
title = "{C} Pointers and Dynamic Memory Management",
publisher = "QED Publishing",
ISBN = "0-471-56152-5",
year = 1993
}

@book{daco95,
author = "Michael C. Daconta",
title = "{C++} Pointers and Dynamic Memory Management",
publisher = Wiley,
ISBN = "0-471-04998-0",
year = 1995,
comment = {It's more about pointers than memory management.  The
pointer part is not bad, if you're a C++ beginner; the memory
management part is disappointing.
It's written in a clear style and starts from the basics ("Memory
Location: a container that can store a binary number").  The view of
OO programming is rather naive and C++-oriented.  It explains
references (slightly wrong), pointer arithmetic, malloc/free,
new/delete, constructors, destructors, set_new_handler, pointer
arrays, inheritance, templates (simple ones), and many other things.
The coverage of pointers is pretty comprehensive, but there's nothing
about automatic memory management.  The approach is rather practical,
often ignoring the subtleties of the standard.  It comes with a floppy
of source code.
There's a chapter on MM internals.  It explains the basics in simple
language, but fairly well.  It doesn't discuss sophisticated free list
structures.  There's decent debugging malloc/new replacement,
explained in detail (there's a bug in dbg_realloc, though: it can
overwrite the object when making it smaller).  There's an interview
with Arthur D. Applegate, the developer of SmartHeap, where many wise
things are said, and Lisp and Smalltalk are mentioned as doing these
things better.  Quote of the day: "I have benchmarked a _single_ call
to malloc at [...] over 20 minutes with Watcom C under OS/2."  He says
garbage collection is too slow (he worked at Inference Corp. many
years ago).
There's a chapter of the quirks of Intel x86 segmented pointers and
Mac handles.-PP}
}

@techreport{dahl63,
title = {The {SIMULA} Storage Allocation Scheme},
author = {O. J. Dahl},
institution = {Norsk Regnesentral},
year = 1963,
month = nov,
type = {NCC Document},
number = 62,
}


@article{dahl66,
author = "O. J. Dahl and K. Nygaard",
title = "Simula --- an {A}lgol-Based Simulation Language",
journal = CACM,
volume = 9,
publisher = ACM,
pages = "671--678",
year = 1966
}

@techreport{danv86,
author = "Olivier Danvy",
title = "{LILA}: a Virtual Machine for Functional and Declarative Languages",
institution = "LITP, France",
month = may,
number = "86--38",
year = 1986,
note = "Workshop on Future Directions in Computer Science and Software"
}

@techreport{danv86a,
author = "Olivier Danvy",
title = {Agir avec {LILA}: le Manuel de R\'{e}f\'{e}rence},
institution = "LITP, France",
month = may,
number = "86--40",
year = 1986
}

@techreport{danv86b,
author = "Olivier Danvy and Danielle Jean",
title = {Langage d'Imple\'{e}mentation pour Langages Applicatifs: contribution
\'{a} l'\'{e}tude d'une r\'{e}alisation informatique},
institution = "LITP, France",
month = jan,
number = "86--23",
note = {Also Bigre+Globule 48, 3e journ\'{e}es d'\'{e}tude sur les Langages Orient\'{e}s Objet},
year = 1986
}

@article{danv87,
author = "Olivier Danvy",
title = "Memory Allocation and Higher-Order Functions",
journal = sigplan,
publisher = ACM,
volume = 22,
number = 7,
pages = "241--252",
month = Jun,
year = 1987
}

@inproceedings{dau98,
author = {C. H. Daugherty and J. Morris Chang},
title = {Common List Method: A Simple, Efficient Allocator Implementation},
booktitle = {Proceedings of Sixth Annual High-Performance Computing Symposium},
address = {Boston, MA},
month = apr,
year = 1998,
pages = {180--185}
}


@article{davi84,
title = "Memory Occupancy Patterns in Garbage Collection Systems",
author = "D. Julian M. Davies",
journal = CACM,
publisher = ACM,
month = aug,
year = 1984,
volume = 27,
number = 8,
pages = "819--825"
}


@inproceedings{daws82,
author = "Jeffrey L. Dawson",
title = "Improved Effectiveness from a Real-Time {LISP} Garbage Collector",
crossref = "LFP92",
pages = "159--167",
comment = "
Described as a variation of Baker but is an incremental update scheme, similar
to Dijkstra."
}

@inproceedings{day83,
author = "J. D. Day and H. Zimmermann",
title = "The {OSI} {R}eference {M}odel",
booktitle = "Proceedings of the {IEEE}",
publisher = IEEE,
volume = 71, 
pages = "1334--1340", 
month = Dec,
year = 1983
}

@article{day94,
title = {References to Remote Mobile Objects in {T}hor},
author = {M. Day and Barbara Liskov and Umesh Maheshwari and A. Myers},
journal = {ACM Letters on Programming Languages and Systems},
volume = 2,
number = {1--4},
month = mar,
year = 1994,
URL = {http://pauillac.inria.fr/~lefessan/dgc/papers/00032-DLMM94.ps.gz}
}


@inproceedings{dayn97,
author = {Laurent Dayn{\`e}s and Malcolm P. Atkinson},
title = {Main-Memory Management to support Orthogonal Persistence for {J}ava},
booktitle = {Proceedings of the Second International Workshop on Persistence and {J}ava ({PJW2})},
address = {Half Moon Bay, CA, USA},
URL = {http://www.sunlabs.com/research/forest/COM.Sun.Labs.Forest.PJava.PJW2.9_ps.ps},
month = aug,
year = 1997,
note = {To be published.}
}


@inproceedings{dear92,
author = "Alan Dearle and di Bona, Rex  and James Farrow and Frans Henskens and Anders Lindstrom and John Rosenberg and Francis Vaughan",
title = "Grasshopper --- A Persistent Operating System for Conventional Hardware",
crossref = "IWOOOS92",
pages = {81--85}
}


@inproceedings{dear92a,
author = "Alan Dearle and others",
title = "An Examination of Operating System Support for Persistent Object System
s",
booktitle = "25th Hawaii International Conference on Systems Sciences, vol. 1",
year = 1992,
pages = {779--789},
}


@techreport{deb84,
author = "Ashoke Deb",
title = "An efficient garbage collector for graph machines",
institution = "Oregon Graduate Center",
year = 1984,
number = "CS/E-84-003"
}


@inproceedings{deb87,
author = "Ashoke Deb",
title = "Parallel Garbage Collection in a Parallel Virtual Memory 
Environment",
booktitle = "Graph Reduction: Proceedings of a Workshop at {S}anta {F}e, {N}ew {M}exico",
editor = "J. H. Fasel and R. M. Keller",
pages = "252--264",
publisher = SV,
series = LNCS,
volume =279,
address = "New York, NY",
year = "1987"
}



@inproceedings{dela92,
title = "Allocation Regions and Implementation Contracts",
author = "V. Delacour",
address = "Xerox Corporation, USA",
crossref = "IWMM92",
}


@article{dell80,
author = "C. N. R. Dellar",
title = "Removing Backing Store Administration from the {CAP} Operating 
System",
journal = "Operating System Review",
volume = 14,
number = 4,
pages = "41--49",
year = 1980
}



@inproceedings{deme90,
title = "Combining Generational and Conservative Garbage Collection: Framework and Implementations",
author = "Alan Demers and Mark Weiser and Barry Hayes and Daniel G. Bobrow and Scott  Shenker",
crossref = "POPL90",
pages = "261--269",
abstract = {Two key ideas in garbage collection are generational collection and
conservative pointer-finding.  Generational collection and conservative 
pointer-finding are hard to use together, because generational collection 
is usually expressed in terms of copying objects, while conservative 
pointer-finding precludes copying.  
We present a new framework for defining garbage collectors.
When applied to generational collection, it generalizes the notion of
younger/older to a partial order.  It can describe traditional generational 
and conservative techniques, and lends itself to combining different 
techniques in novel ways.
We study in particular two new garbage collectors inspired by this
framework.  Both these collectors use conservative pointer-finding.
The first one is based on a rewrite of an existing trace-and-sweep collector
to use one level of generation.  The second one has a single parameter,
which controls how objects are partitioned into generations;
the value of this parameter can be changed dynamically with no overhead.
We have implemented both collectors and
present measurements of their performance in practice.}
}

@inproceedings{demo96,
author = "Bart Demoen and Geert Engels and Paul Tarau",
title = "Segment Preserving Copying Garbage Collection for {WAM}-Based {P}rolog",
booktitle = "ACM Symposium on Applied Computing",
editor = "Jim Hightower",
publisher = ACM,
address = "Philadelphia",
month = feb,
year = 1996,
note = "Programming languages track"
}

@inproceedings{demo98,
author = {Bart Demoen and Konstantinos Sagonas},
title = {Memory Management for {P}rolog with Tabling},
pages = {97--106},
crossref = {ISMM98},
abstract = {Tabling can be implemented in a Prolog system by means of
SLG-WAM: consumers suspend by freezing the execution stacks. XSB is an
implementation that does so. The memory model is quite complex and
attempts to understand the notion of usefulness of data in XSB well
enough to build a precise garbage collector have failed in the past.
CAT is a recent alternative to SLG-WAM: it suspends consumers by
copying parts of the execution stacks. The memory model is simpler and
the design of a more precise garbage collector became feasible. CAT
also provided the necessary insights in the usefulness of data in the
context of the SLG-WAM. This paper describes the memory management of
tabled logic programming systems, whether based on the SLG-WAM or on
CAT.  Since CAT can perform arbitrarily worse than SLG-WAM space-wise,
also a minor garbage collection on creation of the CAT areas is
described and its effectiveness is discussed. }
}

@inproceedings{demo02,
author = {Bart Demoen},
title = {A Different Look at Garbage Collection for the {WAM}},
crossref = {ICLP02},
}

@inproceedings{demo02a,
author = {Bart Demoen and Phuong-Lan Nguyen and Ruben Vandeginste},
title = {Copying Garbage Collection for the {WAM}: To Mark or Not to Mark?},
crossref = {ICLP02},
}

@article{denn68,
author = "P. J. Denning",
title = "The Working Set Model for Program Behaviour",
journal = CACM,
publisher = ACM,
volume = 11,
pages = "323--333",
year = 1968
}

@inproceedings{denn68a,
author = "P. J. Denning",
title = {Thrashing: Its Causes and Prevention},
month = jun,
year = 1968,
booktitle = {Proceedings of AFIPS 1968 Fall Joint Computer Conference},
volume = 33,
pages = {915--922},
}

@article{denn70,
author = "P. J. Denning",
title = "Virtual Memory",
publisher = ACM,
journal = {ACM Computing Surveys},
volume = 2,
number = 3,
pages = "153-190",
month = sep,
year = 1970
}

@article{denn72,
author = "P. J. Denning and Scwartz",
title = "Properties of the Working-set Model",
journal = CACM,
publisher = ACM,
volume = 15,
number = 3,
pages = "191--198",
month = mar,
year = 1972
}

@article{denn80,
author = "Peter Denning",
title = "Working Sets Past and Present",
journal = IEEETransSWE,
publisher = IEEE,
volume = "SE-6",
number = 1,
month = jan,
year = 1980,
pages = "64--84"
}

@techreport{derb87,
author = "Margaret H. Derbyshire",
title = "Garbage Collection on the {IRM}: Report Number 6",
institution = "University of Manchester, Department of Computer Science",
type = "Departmental Research Report",
number = "FS/MU/MHD/004--87",
year = "1987",
abstract = "A mark-scan algorithm for the IRM. Flagship project"
}


@article{derb90,
author = "Derbyshire, Margaret H.",
title = "Mark Scan Garbage Collection on a Distributed Architecture",
journal = LSC,
year = 1990,
month = apr,
volume = 3,
number = 2,
pages = "135 -- 170"
}


@article{ders80,
author = "N. Dershowitz",
title = "The {S}chorr--{W}aite Marking Algorithm Revisited",
journal = IPL,
publisher = NH,
volume = 11,
number = 3,
month = Nov,
year = 1980,
pages = "141--143",
comments = "{Paper shows that imposing a depth-first marking order a simple proof of
correctness of {S}chorr-{W}aite algorithm follows naturally}",
}

@inproceedings{dete02,
title = {Automated Discovery of Scoped Memory Regions for Real-Time {J}ava},
author = {Morgan Deters and Ron Cytron},
crossref = {ISMM02},
pages = {25--35}
}

@techreport{detl90,
author = "David L. Detlefs",
title = "Concurrent Garbage Collection for {C++}",
institution = "Carnegie Mellon University",
address = "Pittsburgh, PA",
number = "CMU--CS--90--119",
month = May,
year = 1990,
abstract = "Automatic storage management, or garbage collection, 
is a feature usually associated with languages oriented toward 
'symbolic processing,' such as Lisp or Prolog; it is seldom 
associated with 'systems' languages, such as C and C++.  This 
report surveys techniques for performing garbage collection for 
languages such as C and C++, and presents an implementation of a 
concurrent copying collector for C++.  The report includes 
performance measurements on both a uniprocessor and a 
multiprocessor."
}


@inproceedings{detl90a,
author = "David L. Detlefs",
title = "Concurrent, Atomic Garbage Collection",
crossref = "OOPSLA90-gc",
}


@phdthesis{detl91,
author = "David L. Detlefs",
title = "Concurrent, Atomic Garbage Collection",
school = "Department of Computer Science, Carnegie Mellon University",
address = "Pittsburgh, PA, 15213",
number = "CMU--CS--90--177",
month = nov,
year = 1991,
abstract = {We describe a concurrent, atomic garbage collection 
algorithm for transaction-based languages, a class of languages 
intended to support reliable distributed systems.  A garbage 
collection algorithm for reliable distributed systems must be 
atomic: a crash during a garbage collection should result in no 
loss of data.  A concurrent collector allows programs to continue 
operating as their heaps are collected, minimizing delays imposed 
by collection.  A concurrent collector can be used in reliable 
distributed systems that must service interactive requests.
We introduce concurrency into an atomic collector by breaking 
collection into a series of garbage collection segments, which 
are similar to transactions, but satisfy weaker properties than 
are required by transaction semantics.  These weaker properties 
allow better performance.  Thus, our collection algorithm 
enhances the reliability of programs written in transaction-based 
languages, without necessarily imposing severe performance 
penalties.  We also describe a concurrent "mostly-copying" 
collection algorithm for C++, and present measurements of the 
performance of an implementation of this algorithm.
We survey garbage collection techniques applicable to "systems" 
languages such as C++, and show how these techniques may be 
combined with concurrent collection.  Performance measurements of 
the resulting collector (on both a uniprocessor and a 
multiprocessor) indicate that interruptions caused by concurrent 
collection are quite short, and that adequate mutator performance 
is sustained during collection.  Finally, we prove the 
correctness of most aspects of the concurrent, atomic collection 
algorithm.  The proof hinges on showing that the routines of the 
algorithm preserve a novel property called partial idempotence, 
which ensures that partial effects of routines interrupted by 
crashes can be undone or completed during recovery.}
}

@incollection{detl91a,
author = "David L. Detlefs",
title = "Concurrent Garbage Collection for {C++}",
booktitle = "Topics in Advanced Language Implementation",
editor = "Peter Lee",
publisher = MIT,
year = 1991
}


@inproceedings{detl92,
title = "Garbage Collection and Runtime Typing as a {C}++ Library",
author = "David L. Detlefs",
booktitle = "{USENIX} {C}++ Conference",
publisher = UA,
address = "Portland, Oregon",
year = 1992,
month = aug
}


@techreport{detl93,
author = "David L. Detlefs and Al Dosser and Benjamin Zorn",
title = "Memory Allocation Costs in Large {C} and {C++} Programs",
institution = "Digital Equipment Corporation and University of Colorado",
type = "Computer Science Technical Report",
number = "CU-CS-665-93",
address = "130 Lytton Avenue, Palo Alto, CA 94301 and Campus Box 430, Boulder, CO 80309",
month = aug,
year = 1993,
URL = "ftp://ftp.cs.colorado.edu:/pub/cs/techreports/zorn/CU-CS-665-93.ps.Z",
abstract = "Dynamic storage allocation is an important part of a large class of
computer programs written in C and C++.  High-performance algorithms
for dynamic storage allocation have been, and will continue to be, of
considerable interest.  This paper presents detailed measurements of
the cost of dynamic storage allocation in 11 diverse C and C++
programs using five very different dynamic storage allocation
implementations, including a conservative garbage collection
algorithm.  Four of the allocator implementations measured are
publicly-available on the Internet.  A number of the programs used in
these measurements are also available on the Internet to facilitate
further research in dynamic storage allocation.  Finally, the data
presented in this paper is an abbreviated version of more extensive
statistics that are also publically-available on the Internet."
}

@inproceedings{detl93a,
author = "David L. Detlefs",
title = "Empirical Evidence for using Garbage Collection in {C} and {C++} Programs",
crossref = "OOPSLA93-gc",
}

@article{detl94,
author = "David Detlefs and Al Dosser and Benjamin Zorn",
title = "Memory Allocation Costs in Large {C} and {C++} Programs",
institution = "Digital Equipment Corporation and University of Colorado",
journal = SPE,
publisher = Wiley,
volume = 24,
number = 6,
year = 1994
}

@inproceedings{detl95,
title = "Debugging Storage Management Problems in Garbage-Collected
Environments",
author = "Dave Detlefs and Bill Kalsow",
booktitle = "{USENIX} Conference on Object-Oriented Technologies",
month = jun,
publisher = UA,
year = 1995,
URL = {ftp://ftp.digital.com/pub/misc/detlefs/detlefs-coots95.ps},
abstract = "Garbage collection does not solve all storage management problems; programs
allocate too much garbage, requiring excess collection, and may retain too much
storage, causing heaps to grow too large. This paper discusses these problems
and presents tools implemented in the SRC Modula-3 system that help solve them."
}

@inproceedings{detl02,
title = {Concurrent Remembered Set Refinement in Generational Garbage Collection},
author = {David Detlefs and William D. Clinger and Matthias Jacob and Ross Knippel},
crossref = {JVM02},
URL = {http://www.usenix.org/events/jvm02/detlefs.html}
}

@article{detl02a,
title = {Lock-Free Reference Counting},
author = {David L. Detlefs and Paul A. Martin and Mark Moir and Guy L. Steele},
journal = {Distributed Computing},
publisher = SV,
volume = 15,
pages = {255--271},
year = 2002
}

@techreport{detr90,
author = "John DeTreville",
title = "Experience with Concurrent Garbage Collectors for {M}odula-2+",
institution = DECSRC,
number = 64,
month = Aug,
year = 1990,
comment = "Reference counting + mark-sweep.
Reference counting may give better locality than other
techniques (based on experience with the Topaz system)."
}


@techreport{detr90a,
author = "John DeTreville",
title = "Heap Usage in the {Topaz} Environment",
institution = DECSRC,
number = 63,
month = Aug,
year = 1990
}

@inproceedings{detr90b,
author = "John DeTreville",
title = "Experience with Garbage Collection for Modula-2+ in the Topaz Environment",
crossref = "OOPSLA90-gc",
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/GC90/DeTreville.ps.Z"
}

@inproceedings{deut73,
author = "L. Peter Deutsch",
title = "A {LISP} Machine with Very Compact Programs",
booktitle = "International Joint Conference on Artificial Intelligence",
address = "Stanford, CA",
year = 1973,
pages = "697--703"
}

@article{deut76,
author = "L. Peter Deutsch and Daniel G. Bobrow",
title = "An Efficient Incremental Automatic Garbage Collector",
journal = CACM,
publisher = ACM,
volume = 19,
number = 9,
month = sep,
year = 1976,
pages = "522--526",
comment = "Deferred Reference Counting, invented by Peter Deutsch and Danny Bobrow.
The idea is not to reference count the stack, which accounts for the vast
majority of references.
Halved the time cost of reference counting at the cost of 10 percent storage
overhead."
}


@incollection{deut83,
author = "L. Peter Deutsch",
title = "The {D}orado {S}malltalk-80 Implementation: Hardware
architecture's impact on software architecture",
crossref = "Smalltalk-BHWA",
pages = "113--125",
}


@inproceedings{deut84,
author = "Deutsch, Peter L. and A. M. Schiffman",
title = "Efficient Implementation of the {S}malltalk-80 System",
crossref = "POPL84",
pages = "297--302",
}


@inproceedings{deut90,
author = "A. Deutsch",
title = "On Determining Lifetime and Aliasing of Dynamically Allocated Data 
in Higher-Order Functional Specifications",
crossref = "POPL90",
pages = "157 -- 168",
abstract = {Compile-time garbage collection}
}

@inproceedings{deut94,
author = "A. Deutsch",
title = {Interprocedural May-Alias Analysis for Pointers: Beyond k-limiting},
crossref = {PLDI94},
pages = {230--241}
}

@article{dewa77,
author = "Robert B. K. Dewar and A. P. McCann",
title = "{MACRO} {SPITBOL} --- A {SNOBOL4} Compiler",
journal = SPE,
publisher = Wiley,
volume = 7,
number = 1,
pages = "95--113",
year = 1977,
comment = "Compaction using a threaded algorithm"
}

@article{dewa82,
title = "Transformational Derivation of a Garbage Collection Algorithm",
author = "Robert B. K. Dewar and Micha Sharir and Elia Weixelbaum",
journal = TOPLAS,
publisher = ACM,
year = 1982,
month = Oct,
volume = 4,
number = 4,
pages = "650--667",
abstract = {This paper is about what might be called programming by stepwise
transformation. Starting with a short high-level algorithm, the program is
successively transformed by correctness-preserving local 
transformations,
which improve efficiency but also introduce more and more low-level
details. The technique is illustrated by a garbage-collection algorithm:
starting with a 5-statement version 1, the authors eventually arrive at a
28-statement version 8 which resembles a previously known algorithm.
An interesting point is that the authors express all versions of their
program in a real programming language, SETL, a language which allows both
high-level and low-level expression. Thus all versions of the program can
be subjected to testing as well as formal reasoning.
The authors claim that their transformations required very little insight
into the problem and could largely be automated. This reviewer is not
convinced by that argument. To paraphrase a 1973 comment by Urs 
Ammann (on stepwise refinement), what we need now is to see the transformational
technique applied to a large problem which has not already been solved.}
}

@inproceedings{dhur03,
title = {Memory Safety without Runtime Checks or Garbage Collection},
author = {Dinakar Dhurjati and Sumant Kowshik and Vikram Adve and Chris Lattner},
crossref={LCTES03}
}

@article{diaz94,
author = {Manuel D\'{i}az and E. Pimentel and Jos\'{e} M. Troya},
title = {{DROL}: a Distributed and Real-Time Object-Oriented Logic Environment},
journal = CompJ,
volume = 37,
pages = {407--421},
year = 1994
}

@article{diaz97,
author = {Manuel D\'{i}az and Bartolom\'{e} Rubio and Jos\'{e} M. Troya},
title = {{DRL}: a Distributed Real-Time Logic Language},
journal = {Journal of Computing Languages, special issue on Extensions of Logic Programming},
year = 1997
}

@inproceedings{dice02,
title = {Mostly Lock-Free Malloc},
author = {Dave Dice and Alex Garthwaite},
crossref = {ISMM02},
pages = {163--174}
}

@inproceedings{dick91,
author = "Peter Dickman",
title = "Effective Load Balancing in a Distributed Object-Support Operating System",
crossref = "IWOOOS91",
}

@phdthesis{dick92,
author = "Peter Dickman",
title = "Distributed Object Management in a Non-Small Graph of Autonomous Networ
ks With Few Failures",
school = "University of Cambridge",
month = sep,
year = 1992
}

@unpublished{dick92b,
title = "Optimising Weighted Reference Counts for Scalable Fault-Tolerant 
Distributed Object-Support Systems",
author = "Peter Dickman",
year = 1992,
note = {Unpublished note},
comment = "Message failure resilience: weight >= sum remote reference 
weights. This tolerates message loss but not duplication.
Indirections avoided by using special null weight + a global tracing GC",
}

@inproceedings{dick96,
title = "Incremental, Distributed Orphan Detection and Actor Garbage Collection
Using Graph Partitioning and Euler Cycles",
author = "Peter Dickman",
URL = "http://www.dcs.gla.ac.uk/~pd/papers/wdag96.ps",
crossref = "WDAG96"
}

@unpublished{dick96a,
title = "Efficient, Incremental, Distributed Orphan Detection and Actor Garbage Collection",
author = "Peter Dickman",
note = "In preparation",
year = 1996
}

@inproceedings{dick00,
author = {Peter Dickman},
title = {Diffusion Tree Redirection for Indirect Reference Counting},
crossref = {ISMM2000},
pages = {167--177},
abstract = {
A new algorithm for distributed acyclic garbage detection is presented for
use in hybrid collectors. It is based on Piquer's Indirect Reference Counting
(IRC), but qualitatively improves the fault-tolerance. The insight that
underpins this work is the observation that the parent of a node in the IRC
diffusion tree need not remain constant. The new algorithm exploits
standard mechanisms for implementing remote references and diffusion
trees, using three low-cost techniques to dynamically restructure the IRC
diffusion trees to reduce their depth. This variant thereby reduces the
third-party dependencies which make standard IRC vulnerable to process
failure, without affecting the existing tolerance of message reordering. The
paper carefully motivates the algorithm, presents the full technical basis for
its development, provides a detailed explanation of its implementation and
includes an analysis of performance issues. }
}

@inproceedings{diec99,
title = {A Study of the Allocation Behaviour of the {SPECjvm98} {J}ava Benchmarks},
author = {Sylvia Dieckmann and Urs H\"{o}lzle},
crossref = {ECOOP98},
pages = {92--115}
}

@incollection{diec01,
title = {The Allocation Behaviour of the {SPECjvm98} {J}ava Benchmarks},
author = {Sylvia Dieckmann and Urs H\"{o}lzle},
booktitle = {Performance Evaluation and Benchmarking with Realistic Applications},
editor = {Rudolf Eigenman},
chapter = 3,
pages = {77--108},
publisher = MIT,
year = 2001
}

@unpublished{dijk75,
author = "Edsgar W. Dijkstra",
title = "Notes on a Real-Time Garbage Collection System",
note = "From a conversation with D. E. Knuth (private collection of D. E. Knuth)",
year = 1975,
comments = {These notes later evolved to paper \cite{dijk76b}}
}


@book{dijk76a,
author = "Edsgar W. Dijkstra",
title = "A Discipline of Programming",
publisher = "Prentice-Hall,  Englewood Cliffs, N. J.", 
chapter = 14,
year = 1976,
}

@incollection{dijk76b,
author = "Edsgar W. Dijkstra and Leslie Lamport and A. J. Martin and C. S. Scholten and E. F. M. Steffens",
title = "On-The-Fly Garbage Collection: An Exercise in Cooperation",
booktitle = "Lecture Notes in Computer Science, No. 46",
publisher = SV,
address = "New York", 
year = 1976,
comments = {Shared memory algorithm for parallel mark-scan with tri-colour
marking.}
}


@article{dijk78,
author = "Edsgar W. Dijkstra and Leslie Lamport and A. J. Martin and C. S. Scholten and E. F. M. Steffens",
title = "On-The-Fly Garbage Collection: An exercise in Cooperation",
journal = CACM, 
publisher = ACM,
volume = 21,
number = 11, 
month = Nov,
pages = "965--975",
year = 1978,
comments = {New version of \cite{dijk76b} with fine grain solution.
Incremental write-barrier GC.
Wilson thinks it has an advantage over Baker or Yuasa, since objects are
allocated as unreachable. If they die young, they may never be reached.}
}

@article{dijk80,
author = "Edsgar W. Dijkstra and C. S. Scholten",
title = "Termination Detection for Diffusing Computations",
journal = IPL,
publisher = NH,
volume = 11,
pages = {1--4},
month = Aug,
year = 1980
}

@article{dimp00,
author = {Robert Dimpsey and Rajiv Arora and Kean Kuiper},
title = {{J}ava Server Performance: A Case Study of Building Efficient, Scalable {JVM}s},
journal = ISJ,
volume = 39,
number = 1,
pages = {151--174},
year = 2000,
URL = {http://www.research.ibm.com/journal/sj/391/dimpsaut.html},
abstract = {The importance of the Java? platform has shifted from a client-centered paradigm to the server. In particular, the Java language has matured into a viable programming model for server applications. Correspondingly, the requirements on the Java virtual machine (Jvm) have shifted. This paper details the server-specific performance enhancements made to the core Jvm and just-in-time (JIT) compiler, which have allowed the IBM Developer Kits that implement Java code for Intel processors to become industry performance leaders. The paper focuses on synchronization implementation and granularity improvements that have greatly increased the scalability of the Java language on multiprocessor machines. Focus is also given to memory management, specifically, object allocation, garbage collection, and heap management. Details of communication and connection scaling are also provided. Finally, server-specific enhancements to the JIT compiler are discussed. All component enhancements in the paper are explained, and their performance implications are quantified with results from representative multithreaded server workloads. The paper summarizes work from across IBM. The authors' specific contributions include the three-tier spin lock, the thread local heap and freelist merge, the dynamic heap growth algorithm, bitwise sweep, compaction avoidance, and the suite of network enhancements. }
}


@inproceedings{ding99,
author = {Chen Ding and Ken Kennedy},
title = {Improving Cache Performance of Dynamic Applications through Data and Computation Reorganization at Run Time},
crossref = {PLDI99},
pages = {229--241}
}

@inproceedings{diwa91,
author = "Amer Diwan",
title = "Stack Tracing In A Statically Typed Language",
crossref = "OOPSLA91-gc",
}

@inproceedings{diwa92,
title = "Compiler Support for Garbage Collection in a Statically Typed
Language",
author = "Amer Diwan and J. Eliot B. Moss and Richard L. Hudson",
crossref = "PLDI92",
pages = "273--282",
URL = "ftp://ftp.cs.umass.edu/pub/osl/papers/sigplan92.ps.Z",
abstract = "... extend the compiler to emit tables of live pointers
and values derived from pointers at each program location where collection may
occur ...",
comment = "Goal: copying collector, no tagged data, efficiency.
Conclusion: it seems to work.  The compiler produces a set of tables
that describe what the stack and registers look like at every potential
garbage collection point.  There are various complications (weird
ways the compiler could mangle pointers), but they handle all the
cases that the gcc compiler actually produces.	Pending threads are
allowed to execute on to gc points.  Various compaction of tables gets
them down from 50 percent of code size to about 15 percent."
}

@techreport{diwa93,
title = "Memory Subsystem Performance of Programs with Intensive Heap Allocation",
author = "Amer Diwan and David Tarditi and J. Eliot B. Moss",
number = "CMU-CS-93-227",
institution = "Computer Science Department, Carnegie-Mellon University",
month = dec,
year = 1993,
URL = "ftp://reports.adm.cs.cmu.edu/usr/anon/1993/CMU-CS-93-227.ps",
note = "Also appears as Fox Memorandum CMU-CS-FOX-93-07.",
abstract = "Heap allocation with copying garbage collection is a general
storage-management technique for modern programming languages.
It is believed to have poor memory-subsystem performance.  
To investigate this, we conducted an  in-depth study of the
memory-subsystem performance of heap allocation for memory subsystems
found on many machines.   We studied the performance of mostly-functional
Standard ML programs which made heavy use of heap allocation.

We found that most machines support heap-allocation poorly. However,
with the appropriate memory-subsystem organization, heap allocation
can have good performance.  The memory-subsystem property crucial for
achieving good performance was the ability to allocate and initialize
a new object into the cache without a penalty.   This can be achieved
by having  subblock placement with a subblock size of one word with a
write-allocate policy, along with fast page-mode writes or a write
buffer.  For caches with subblock placement, the data-cache overhead
was under 9\% for a 64K of larger data cache; without subblock placement
the overhead was often higher than 50\%."
}

@inproceedings{diwa94,
title = "Memory Subsystem Performance of Programs using Copying Garbage Collection",
author = "Amer Diwan and David Tarditi and J. Eliot B. Moss",
crossref = "POPL94",
URL = "http://www.cs.cmu.edu:8001/afs/cs/project/fox-1/dtarditi/papers/cmu-tr-93-210.ps",
}

@article{diwa95,
title = "Memory Subsystem Performance of Programs with Intensive Heap Allocation",
author = "Amer Diwan and David Tarditi and J. Eliot B. Moss",
journal = TransCompSys,
volume = 13,
number = 4,
pages = "244--273",
month = aug,
year = 1995
}


@inproceedings{dolb97,
title = {Automatic Inline Allocation of Objects},
author = {Julian Dolby},
crossref = {PLDI97},
URL = {http://www-csag.cs.uiuc.edu/papers/pldi97.ps}
}

@inproceedings{dolb98,
title = {An Evaluation of Object Inline Allocation Techniques},
author = {Julian Dolby and Chien},
crossref = {OOPSLA98},
URL = {http://www-csag.cs.uiuc.edu/papers/oopsla-98.ps}
}

@inproceedings{dolb00,
author = {Julian Dolby and Chien},
title = {An Automatic Object Inlining and its Evaluation},
crossref = {PLDI00},
pages = {345--357}
}

@inproceedings{doli93,
title = "A Concurrent Generational Garbage Collector for a Multi-Threaded Implementation of {ML}",
author = "Damien Doligez and Xavier Leroy",
crossref = "POPL93",
pages = "113--123",
URL = {file://ftp.inria.fr/INRIA/Projects/cristal/Xavier.Leroy/publications/concurrent-gc.ps.gz},
comment = "Immutable objects kept in private heaps collected by a 
replication based stop-and-copy collector into a shared heap
which is collected by a Dijkstra-type collector."
}

@inproceedings{doli94,
title = "Portable, Unobtrusive Garbage Collection for Multiprocessor Systems",
author = "Damien Doligez and Georges Gonthier",
crossref = "POPL94",
URL = "ftp://ftp.inria.fr/INRIA/Projects/para/doligez/DoligezGonthier94.ps.gz"
}

@inproceedings{dols04,
title = {Imposing a Memory Management Discipline on Software Deployment},
author = {Eelco Dolstra and Eelco Visser and de Jonge, Meijn},
crossref = {ICSE04}
}

@inproceedings{doma00,
title = {A Generational On-the-fly Garbage Collector for {J}ava},
author = {Tamar Domani and Elliot Kolodner and Erez Petrank},
URL = {http://www.cs.technion.ac.il/~erez/publications.html},
crossref = {PLDI00}
}

@techreport{doma00a,
title = {A Generational On-the-fly Garbage Collector for {J}ava},
author = {Tamar Domani and Elliot Kolodner and Erez Petrank},
number = {88.385},
institution = {IBM Haifa Research Laboratory},
year = 2000,
URL = {http://www.cs.technion.ac.il/~erez/gen.ps},
note = {Fuller version of \cite{doma00}}
}

@inproceedings{doma00b,
author = {Tamar Domani and Elliot K.  Kolodner and Ethan Lewis and Elliot E. Salant and Katherine Barabash and Itai Lahan and Erez Petrank and Igor Yanover and Yossi Levanoni},
title = {Implementing an On-the-fly Garbage Collector for {J}ava},
URL = {http://www.cs.technion.ac.il/~erez/publications.html},
crossref = {ISMM2000},
abstract = {
Java uses garbage collection (GC) for the automatic reclamation of
computer memory no longer required by a running application. GC
implementations for Java Virtual Machines (JVM) are typically designed for
single processor machines, and do not necessarily perform well for a server
program with many threads running on a multiprocessor. We designed and
implemented an on-the-fly GC, based on the algorithm of Doligez, Leroy
and Gonthier~\cite{doli93,dili94} (DLG) for Java in this environment. An
{\em on-the-fly collector}, a collector that does not stop the program
threads, allows all processors to be utilized during collection and provides
uniform response times. We extended and adapted DLG for Java (e.g.,
adding support for weak references) and for modern multiprocessors
without sequential consistency, and added performance improvements (e.g.,
to keep track of the objects remaining to be traced). We compared the
performance of our implementation with stop-the-world mark-sweep GC.
Our measurements show that the performance advantage for our collector
increases as the number of threads increase and that it provides uniformly
low response times.}
}

@inproceedings{doma02,
title = {Thread-Local Heaps for {J}ava},
author = {Tamar Domani and Elliot K.  Kolodner and Ethan Lewis and Ethan Lewis and Erez Petrank and Dafna Sheinwald},
crossref = {ISMM02},
URL = {http://www.cs.technion.ac.il/~erez/publications.html},
pages = {76--87}
}

@inproceedings{dona01,
author = {Steven M. Donahue and Matthew P. Hampton and Morgan Deters and Jonathan M. Nye and Ron K. Cytron and Krishna M. Kavi},
title = {Storage Allocation for Real-Time, Embedded Systems},
crossref= {EMSOFT01},
pages = {131--147},
URL = {http://link.springer-ny.com/link/service/series/0558/bibs/2211/22110131.htm}
}
@inproceedings{dor98,
title = {Detecting Memory Errors via Static Pointer Analysis},
author = {Nurit Dor and Michael Rodeh and Mooly Sagiv},
crossref = {PASTE98}
}

@book{dorf,
title = {{C++} Memory Management},
author = {Len Dorfman and Marc J. Neuberger},
publisher = MGH,
note = {Out of print}
}


@inproceedings{doro91,
author = {M. Dorochevsky and K. Schuerman and A. V\'{e}ron and J. Xu},
title = "Contraint Handling, Garbage Collection and Execution Models in 
{E}lip{S}ys",
booktitle = "{ICLP'91} Workshop on Parallel Execution of Logic Programs",
editor = "A. Beaumont and G. Gupta",
pages = "17--28",
year = 1991,
series = LNCS,
volume = 569,
}

@inproceedings{doro92,
author = {Dorochevsky, M. and V\'{e}ron, A.},
title = "Binding Techniques and Garbage Collection for {OR}-Parallel {CLP} Systems",
crossref = "PLILP92",
pages = "39--53",
}

@article{doug91,
author = {Fred Douglis and M. Frans Kaashoek ad John K. Ousterhout and Andrew S. Tanenbaum},
title = {A Comparison of Two Distributed Operating Systems : {A}moeba and {S}prite},
journal = {Computing Systems},
volume = 4,
number = 4,
pages = {353--384}, 
month = sep,
year = 1991
}

@inproceedings{doug93,
author = "Fred Douglis",
title = "The Compression Cache: Using On-line Compression to Extend 
Physical Memory",
booktitle = "1993 Winter {USENIX} Conference",
publisher = UA,
pages = "519-529",
address = "San Diego, CA",
month = jan,
year = 1993,
}

@article{drez86,
author ={Z. Drezner and A. Barak},
title = {An Asynchronous Algorithm for Scattering Information between the Active Nodes of a Multi-Computer System},
journal = {Journal of Parallel and Distributed Computing},
volume = 3,
number = 3,
pages = {344--351},
month = sep,
year = 1986
}

@article{debu96,
author = {Danny Dub\'{e} and Marc Feeley and Manuel Serrano},
title = {Un {GC} temps r\'{e}el semi-compactant},
journal = {Journ\'{e}es Francophones des Langages Applicatifs},
month = jan,
year = 1996, 
pages = {165--181},
URL = {http://www.iro.umontreal.ca/~feeley/papers/jfla96.ps.gz}
}

@mastersthesis{duim89,
author = "Duimovich, John",
title = "Garbage Collection in a Multiprocessor {S}malltalk System",
year = 1990,
school = "Carleton University, Canada"
}

@article{duri84,
author = {Jean-Louis Durieux and Danielle Jean and Fran\,{c}oise Carr\'{e} and Patrick Sall\'{e}},
title = {Langage d'Impl\'{e}mentation pour Logique et Acteurs},
journal = "Bigre+Globule",
month = nov,
note = {2e journ\'{e}es d'\'{e}tude sur les Langages Orient\'{e}s Objet},
year = 1984
}

@inproceedings{durd91,
author = "Durdanovic, Igor",
title = "A Fast Garbage Collection Algorithm for {WAM}-Based {PROLOG}",
booktitle = "Proceedings of 4th Workshop on Computer Science Logic, Heidelberg",
series = LNCS,
number = 533,
pages = "110--127",
year = 1991,
month = oct
}

@article{dwye73,
author = "B. Dwyer",
title = "Simple Algorithms for Traversing a Tree without an Auxiliary Stack",
journal = "Inf Process. Lett.",
volume = 2,
number = 5,
month = dec,
year = 1973,
pages = "143--145",
comments = {algorithm for traversing trees without a stack or mark bits},
}


@inproceedings{dybv93,
title = "Guardians in a Generation-Based Garbage Collector",
author = "R. Kent Dybvig and Carl Bruggeman and David Eby",
crossref = "PLDI93",
pages = "207--216",
URL = "ftp://ftp.cs.indiana.edu/pub/scheme-repository/doc/pubs/guardians/ps.gz"
}

@techreport{dybv94,
title = "Don't Stop the {BIBOP}: Flexible and Efficient Storage Management for Dynamically-Typed Languages",
author = "R. Kent Dybvig and David Eby and Carl Bruggeman",
institution = "Indiana University Computer Science Department",
number = 400,
month = mar,
year = 1994,
URL = "ftp://ftp.cs.indiana.edu/pub/techreports/TR400.ps.Z"
}

@article{ecka87,
title = "Distributed Garbage Collection",
author = "J. Dana Eckart and Richard J. Leblanc",
address = "Georgia Inst Technol, Atlanta, Ga, 30332",
journal = Sigplan,
publisher = ACM,
year = 1987,
volume = 22,
number = 7,
pages = "264--273",
}

@phdthesis{ecka87a,
author = "Eckart, J. Dana",
title = "Garbage Collection for Functional Languages in a Distributed 
System",
year = 1987,
school = "Georgia Institute of Technology, 1988"
}

@mastersthesis{edel90,
author = "Daniel R. Edelson",
title = "Dynamic Storage Reclamation in {C++}",
school = "University of California at Santa Cruz",
volume = "UCSC--CRL--90--19",
month = Jun,
year = 1990,
}


@inproceedings{edel90a,
author = "Daniel R. Edelson and Ira Pohl",
title = "The Case for Garbage Collection in {C++}",
crossref = "OOPSLA90-gc",
note = "Also University of California Santa Cruz technical report 
UCSC-CRL-90-37",
abstract = "C++ is an object-oriented imperative programming 
language that provides low-level access to the machine and 
efficient run- time code.  C++ provides access to dynamically 
allocated storage in a way that allows class designers to create 
customized memory allocators and deallocators.  Unlike Eiffel and 
Modula-3, C++ does not provide garbage collection.  The benefits 
of garbage collection are substantial: rapid-prototyping and 
runtime efficiency.  However, it has not been clear that garbage 
collection could be provided for C++ in a way that is consistent 
with the language's design goals.  We argue that garbage 
collection should be an option for C++ programmers.
We cite an implementation that demonstrates that it can be 
provided in a way that is consistent with the C++ design goals 
and philosophy."
}

@inproceedings{edel91,
author = "Daniel R. Edelson and Ira Pohl",
title = "A Copying Collector for {C++}",
booktitle = "Usenix {C++} Conference Proceedings",
publisher = UA,
editor = "",
pages = "85--102",
year = 1991,
}


@inproceedings{edel92,
title = "A Mark-and-Sweep Collector for {C++}",
author = "Daniel R. Edelson",
address = "University of California, Santa Cruz",
crossref = "POPL92",
}


@inproceedings{edel92a,
title = "Precompiling {C++} for Garbage Collection",
author = "Daniel  R. Edelson",
address = "INRIA, France",
URL = "http://www-sor.inria.fr/SOR/docs/PC++GC_iwmm92.html",
crossref = "IWMM92",
}


@inproceedings{edel92b,
author = "Daniel R. Edelson",
title = "Smart Pointers: They're Smart, but They're Not Pointers",
booktitle = "USENIX C++ Conference",
publisher = UA,
URL = "http://www-sor.inria.fr/SOR/docs/SPC++_usenixC++92.html",
year = 1992
}

@techreport{edel93,
author = "Daniel R. Edelson",
title = "Comparing Two Garbage Collectors for {C++}",
institution = UCSC,
number = "UCSC-CRL-93-20",
year = 1993,
month = jan,
URL = {ftp://ftp.cse.ucsc.edu/pub/tr/ucsc-crl-93-20.ps.Z}
}

@phdthesis{edel93a,
author = "Daniel Ross Edelson",
school = UCSC,
title = "Type-Specific Storage Management",
number = "UCSC-CRL-93-26",
year = 1993,
month = may,
}

@techreport{edwa,
title = {{Lisp} {II} Garbage Collector},
author = {Daniel J. Edwards},
institution = MITAI,
type = {AI Memo},
pages = 2,
year = {Date unknown},
number = 19,
URL = {	ftp://publications.ai.mit.edu/ai-publications/0-499/AIM-019.ps},
}

@article{egud92,
author = "Egudo, R.",
title = "An Analysis of a Garbage Collection Operation",
journal = "International journal of mathematical education in science and technology",
volume = 23,
number = 1,
pages = "89-96",
month = Jan,
year = 1992
}

@article{ehn89,
title = "A Contribution to the Increase of Efficiency of On-The-Fly Garbage Collection",
author = "L. Ehn",
address = "Slovak Hydrometeoroly Inst., Department of Minicomputer Operating Systems,
Jeseniova 17,  CS--83315 Bratislava, Czechoslovakia",
journal = "Computers And Artificial Intelligence",
year = 1989,
volume = 8,
number = 1,
pages = "83--91",
abstract = {LISP interpreters consist of two processes, the mutator and the
garbage collector.  Their actions are performed on the common memory, which
contains LISP cells.  A new, more efficient operation design of the mutator and
on-the-fly garbage collector is presented.  The Dijkstra model of three colour
garbage collection system is used.  The result of this is the decrease of a
number of marked garbage cells produced by the mutator.}
}


@article{ehn89a,
title = "Performance Analysis of On-The-Fly Garbage Collection Systems",
author = "L. Ehn",
address = "Slovak Hydrometeoroly Inst., Jeseniova 17, CS--83315 Bratislava,  
Czechoslovakia",
journal = "Computers And Artificial Intelligence",
year = 1989,
volume = 8,
number = 2,
pages = "141--152"
}


@inproceedings{elha90,
author = "El-Habbash, Ahmed and Chris Horn and Neville Harris",
title = "Garbage Collection in an Object Oriented, Distributed, Persistent Environment",
crossref = "OOPSLA90-gc",
}

@article{elli88a,
author = "C. S. Ellis and T. J. Olson",
title = "Algorithms for Parallel Memory Allocation",
journal = "International Journal of Parallel Programming",
volume = 17,
number = 4,
year = 1988,
pages = "303--345"
}

@techreport{elli88,
title = "Real-Time Concurrent Collection on Stock Multiprocessors",
author = "John R. Ellis and Kai Li and Andrew W. Appel",
number = "DEC--SRC--TR--25",
institution = DECSRC,
month = feb,
year = 1988
}

@inproceedings{elli93,
author = "John R. Ellis",
title = "Put Up or Shut Up",
crossref = "OOPSLA93-gc",
}

@techreport{elli93a,
author = "John R. Ellis and David L. Detlefs",
title = "Safe, Efficient Garbage Collection for {C++}",
institution = PARC,
year = 1993,
URL = "ftp://ftp.digital.com/pub/DEC/SRC/research-reports/SRC-102.ps.Z"
}

@misc{elli95,
author = "John R. Ellis",
title = "Is Safe {C++} an Oxymoron?",
note = "Tutorial at PLDI95",
year = 1995
}

@book{ARM,
author = "Margaret A. Ellis and Bjarne Stroustrup",
title = "The Annotated {C++} Reference Manual",
publisher = AW,
year = 1990
}


@techreport{elsm95,
author = {Martin Elsman and Niels Hallenberg},
title = {An Optimizing Back-end for the {ML} {K}it Using a Stack of Regions},
type = {Student Project},
number = {95--7--8},
institution = DIKU,
month = jul,
year = 1995
}

@inproceedings{elsm03,
author = {Martin Elsman},
title = {Garbage Collection Safety for Region-based Memory Management},
pages = {123--134},
crossref = {TLDI03}
}

@book{elso75,
author = "M. Elson",
title = "Data Structures",
publisher = "Science Research Associates", 
year = 1975,
comments = {book with sections on garbage collection},
}

@manual{emacs98,
title = {{GNU} {E}macs {L}isp Reference Manual},
author = {Bil Lewis and Dan LaLiberte and Richard Stallman and the {GNU} Manual Group},
month = may,
year = 1998,
organization = {{GNU} Project},
URL = {http://www.gnu.org/manual/elisp-manual-20-2.5/html_node/elisp_661.html}
}

@inproceedings{endo97,
author = "Toshio Endo and Kenjiro Taura and Akinori Yonezawa",
title = "A Scalable Mark-Sweep Garbage Collector on Large-Scale Shared-Memory Machines",
booktitle = "Proceedings of High Performance Computing and Networking (SC'97)", 
year = 	 "1997",
URL = {ftp://ftp.yl.is.s.u-tokyo.ac.jp/pub/papers/sc97-gc-a4.ps.gz}
}

@mastersthesis{endo98,
author = "Toshio Endo",
title = "A Scalable Mark-Sweep Garbage Collector on Large-Scale Shared-Memory Machines",
school = {University of Tokyo},
year = 	 1998,
month = feb,
URL = {ftp://ftp.yl.is.s.u-tokyo.ac.jp/pub/papers/endo-mthesis-a4.ps.gz}
}

@inproceedings{endo02,
title = {Reducing Pause Time of Conservative Collectors},
author = {Toshio Endo and Kenjiro Taura and Akinori Yonezawa},
crossref = {ISMM02},
pages = {12--24}
}

@inproceedings{enge91,
author = "Steven L. Engelstad and James E. Vandendorpe",
title = "Automatic Storage Management for Systems with Real Time Constraints",
crossref = "OOPSLA91-gc",
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/GC91/engelstad.ps",
}

@inproceedings{evan96,
author = "David Evans",
title = "Static Detection of Dynamic Memory Errors",
pages = "44--53",
crossref = "PLDI96"
}

@inproceedings{evan97,
author = {Huw Evans and Peter Dickman },
title = {Garbage Collection and Memory Management},
crossref = {OOPSLA97},
pages = {138-143},
note = {Addendum to proceedings}
}

@article{even81,
title = "An On-Line Edge-Deletion Problem",
author = "Shimon Even and Yossi Shiloach",
journal = jacm, 
publisher = ACM,
volume = 28,
number = 1,
month = jan,
year = 1981,
pages = "1--4"
}


@inproceedings{fabr79,
author = "Janet Fabri",
title = "Automatic Storage Optimization",
crossref = "CC79",
pages = "83--91",
}


@incollection{falc83,
author = "J. R. Falcone and J. R. Stinger",
title = "The  {S}malltalk-80 Implementation at {H}ewlett--{P}ackard",
crossref = "Smalltalk-BHWA",
pages = "79--112",
}

@inproceedings{fark00,
author = {Keith I. Farkas and Jason Flinn and Godmar Back and Dirk Grunwald and Jennifer Anderson},
title = {Quantifying the Energy consumption of a Pocket Computer and a {J}ava Virtual Machine},
booktitle = {Proceedings of {ACM} {SIGMETRICS'00} International Conference on Measurement and Modelling of Computer Systems},
year = 2000
}

@inproceedings{farr91,
author = "Matthew Farrens and Arvin Park",
title = "Dynamic Base Register Caching:  A Technique for Reducing Address Bus Wi
dth",
booktitle = "Proc. 18th Annual Int'l Symposium on Computer Architecture",
month = May,
year = 1991,
note = "Toronto, Canada",
pages = "128--137"
}


@inproceedings{feel90,
author = "Feeley, Marc and James S. Miller",
title = "A Parallel Virtual Machine for Efficient {S}cheme Compilation",
crossref = "LFP90",
pages = "119--130"      }

@inproceedings{feel93,
author = {Marc Feeley},
title = {Polling Efficiently on Stock Hardware},
crossref = {FPCA93},
pages = {179--187},
URL = {http://www.iro.umontreal.ca/~feeley/papers/polling.ps.gz}
}

@article{feni69,
author = "Robert R. Fenichel and Jerome C. Yochelson",
title = "A {L}isp Garbage Collector for Virtual Memory Computer Systems",
journal = CACM,
publisher = ACM,
volume = 12,
number = 11,
month = nov,
year = 1969,
pages = "611--612",
comments = {The original copying (2 semi-space) garbage collector.
A variant of Minsky's 1963 algorithm (mins63).  }
}


@article{feni71,
author = "Robert R. Fenichel",
title = "List Tracing in Systems Allowing Multiple Cell Types",
journal = CACM,
volume = 14,
number = 8,
month = aug,
publisher = ACM,
year = 1971,
pages = "522--526",
}

@article{feni71a,
author = "Robert R. Fenichel",
title = "Comment on Cheney's List-Compaction Algorithm",
journal = CACM,
publisher = ACM,
volume = 14,
number = 9,
month = sep,
year = 1971,
pages = "603--604"
}

@inproceedings{fent74,
author = "J. S. Fenton and D. W. Payne",
title = "Dynamic Storage Allocations of Arbitrary Sized Segments",
booktitle = "Proceedings of IFIPS",
year = 1974,
pages = "344--348"
}

@article{ferg76,
author = "H. R. P. Ferguson",
title = "On a Generalization of the {F}ibonacci Numbers useful in Memory Allocation Schema",
journal = "The Fibonacci Quarterly",
volume = 14,
number = 3,
month = oct,
year = 1976,
pages = "233--243"
}

@article{fern92,
author = "Fernandez, Mary F. and Hanson, David R.",
address = "Princeton Univ, Princeton, NJ, USA",
title = "Garbage Collection Alternatives for {I}con",
year = 1992,
journal = SPE,
publisher = Wiley,
volume = 22,
number = 8,
month = aug,
pages = "659--672",
abstract = {Copying garbage collectors are becoming the collectors of
choice for very high-level languages and for functional and
object-oriented languages. Copying collectors are
particularly efficient for large storage regions because
their execution time is proportional only to the amount of
accessible data, and they identify and compact this data in
one pass. In contrast, mark-and-sweep collectors execute in
time proportional to the memory size and compacting
collectors require another pass to compact accessible data.
The performance of existing systems with old compacting mark-
and-sweep collectors might be improved by replacing their
collectors with copying collectors. This paper explores this
possibility by describing the results of replacing the
compacting mark-and-sweep collector in the Icon programming
language with four alternative collectors, three of which
are copying collectors. Copying collectors do indeed run
faster than the original collector, but at a significant
cost in space. An improved variant of the compacting mark-
and-sweep collector ran even faster and used little
additional space. (Author abstract)}
}

@article{ferr74,
author = "Domenico Ferrari",
title = "Improving Locality by Critical Working Sets",
journal = CACM,
volume = 17,
number = 11,
month = nov,
pages = "614--620",
publisher = ACM,
year = 1974,
abstract = {A new approach to program locality improvement via
restructuring is described. The method is particularly
suited to those systems where primary memory is managed
according to a working set strategy. It is based on the
concept of critical working set, a working set which
does not contain the next memory reference. The data
the method operates upon are extracted from a trace of
the program to be restructured. It is shown that,
except in some special cases, the method is not
optimum. However, the experimental results obtained by
using the method to restructure an interactive text
editor and the file system module of an operating
system have shown its substantial superiority over the
other methods proposed in the literature.},
}

@inproceedings{ferr90,
author = "Paulo Ferreira",
title = "Storage Reclamation",
crossref = "OOPSLA90-gc",
}

@inproceedings{ferr91,
author = "Paulo Ferreira",
title = "Garbage Collection in {C++}",
crossref = "OOPSLA91-gc",
}

@inproceedings{ferr91a,
author = "Paulo Ferreira",
title = "Reclaiming Storage in an Object-Oriented Platform Supporting
Extended {C++} and {O}bjective-{C} Applications",
crossref = "IWOOOS91",
URL = {http://cretina.inesc.pt/people/pjpf-home/iwooos91.ps}
}

@inproceedings{ferr91b,
author = "Paulo Ferreira",
title = "Garbage Collection in {C++}",
booktitle = {Workshop on Extensions to {C++}},
address = {Lisbon},
month = jun,
year = 1991
}

@mastersthesis{ferr92,
author = "Paulo Ferreira",
title = {Reciclagem Autom\'{a}tica de Mem\'{o}ria num Sistema Orientado a Objectos},
school = {Technical University of Lisbon},
month = jun,
year = 1992,
URL = {http://cretina.inesc.pt/people/pjpf-home/master.ps}
}

@inproceedings{ferr94,
author = "Paulo Ferreira and Marc Shapiro",
title = "Garbage Collection and {DSM} Consistency",
month = nov,
year = 1994,
booktitle = "First Symposium on Operating Systems Design and Implementation",
address = "Monterey, CA",
pages = "229--241",
publisher = ACM,
URL = "http://www-sor.inria.fr/SOR/docs/GC-DSM-CONSIS_OSDI94.html",
abstract = {This paper presents the design of a copying garbage
collector for persistent distributed shared objects in a loosely
coupled network with weakly consistent distributed shared memory
(DSM).
The main goal of the design for this garbage collector is to minimize
the communication overhead due to collection between nodes of the
system, and to avoid any interference with the DSM memory consistency
protocol.
Our design is based on the observation that, in a weakly consistent DSM
system, the memory consistency requirements of the garbage collector
are less strict than those of the applications. Thus, the garbage
collector reclaims objects independently of other copies of the same
objects without interfering with the DSM consistency protocol.
Furthermore, our design does not require reliable communication
support, and is capable of reclaiming distributed cycles of dead
objects.}
}

@inproceedings{ferr94a,
author = "Paulo Ferreira and Marc Shapiro",
title = "Garbage Collection of Persistent Objects in Distributed Shared Memory",
pages = "176--191",
crossref = "IWPOS94",
URL = "http://www-sor.inria.fr/SOR/docs/GC-PERS-DSM_POS94.html",
abstract = {This paper describes a garbage collection algorithm for
distributed persistent objects in a loosely coupled network of
workstations. Objects are accessed via a weakly consistent shared
distributed virtual memory with recoverable properties. We address the
specific problem of garbage collecting a large amount of distributed
persistent objects, cached on several nodes for efficient sharing.
For clustering purposes, objects are allocated within segments, and
segments are logically grouped into bunches . The garbage collection
subsystem combines three sub-algorithms: the bunches garbage collector
that cleans one bunch (possibly multiply-cached) independently of any
other, the scion cleaner that propagates accessibility information
across bunches, and the group collector aimed at reclaiming inter-bunch
cycles of dead objects.
These three sub-algorithms are highly independent. Thus, the garbage
collection subsystem has a high degree of scalability and parallelism.
On top of this, it reclaims cycles of garbage, it does not require any
particular communication support such as causality or atomicity, and is
well suited to large scale networks.}
}

@inproceedings{ferr94b,
author = {Paulo Ferreira and Marc Shapiro},
title = {Distributed Shared Memory Consistency and Garbage Collection},
booktitle = {Workshop {I}nter-{PRS}},
address = {Paris},
month = dec,
year = 1994
}

@inproceedings{ferr94c,
author = {Paulo Ferreira and Marc Shapiro},
title = {Garbage Collection of Persistent Objects in Distributed Shared Memory},
booktitle = {Workshop {F}ranco-{I}sralienne},
address = {St. Malo, France},
month = sep,
year = 1994
}


@inproceedings{ferr95,
author = "Paulo Ferreira and Marc Shapiro",
title = "Garbage Collection in the {L}archant Persistent Distributed Shared Store",
booktitle = "Fifth Workshop on Future Trends in Distributed Computing Systems",
month = aug,
year = 1995,
address = "Cheju Island, Korea",
URL = "http://www-sor.inria.fr/SOR/docs/GCLPDSS_ftdcs95.html"
}

@unpublished{ferr96,
author = "Paulo Ferreira and Marc Shapiro",
title = "Asynchronous Distributed Garbage Collection in the {L}archant Cached Shared Store",
month = may,
year = 1996,
note = "Available from Marc Shapiro"
}

@inproceedings{ferr96a,
author = "Paulo Ferreira and Marc Shapiro",
title = "Larchant: Persistence by Reachability in Distributed Shared Memory through Garbage Collection",
booktitle = "Sixteenth International Conference on Distributed Computer Systems",
address = "Hong Kong",
month = may,
year = 1996,
URL = "http://www-sor.inria.fr/SOR/docs/LPRDSMGC_icdcs96.html"
}

@phdthesis{ferr96b,
title = "Larchant: garbage collection in a cached distributed
shared store with persistence by reachability",
author = "Paulo Ferreira",
month = may,
year = 1996,
school = {Universit\'{e} Paris VI, Pierre et Marie Curie},
URL = "http://www-sor.inria.fr/SOR/docs/ferreira\%3Athesis96.html",
abstract = "The model of Larchant is that of a Shared Address Space
(spanning every site in a network including secondary storage) with
Persistence By Reachability. To provide the illusion of a shared
address space across the network, despite the fact that site memories
are disjoint, Larchant implements a distributed shared memory
mechanism. Reachability is accessed by tracing the pointer graph,
starting from the persistent root, and reclaiming unreachable objects.
This is the task of Garbage Collection (GC).
GC was until recently thought to be intractable in a large-scale
system, due to problems of scale, incoherence, asynchrony, and
performance. This thesis presents the solutions that Larchant proposes
to these problems.
The GC algorithm in Larchant combines tracing and reference-listing. It
traces whenever economically feasible, i.e., as long as the memory
subset being collected remains local to a site, and counts references
that would cost I/O traffic to trace. GC is orthogonal to coherence,
i.e., makes progress even if only incoherent replicas are locally
available. The garbage collector runs concurrently and asynchronously
to applications.  The reference-listing boundary changes dynamically
and seamlessly, and independently at each site, in order to collect
cycles of unreachable objects.
We prove formally that our GC algorithm is correct, i.e., it is safe
and live. The performance results from our Larchant prototype show that
our design goals (scalability, coherence orthogonality, and good
performance) are fulfilled."
}

@inproceedings{ferr98,
author = {Paulo Ferreira and Marc Shapiro},
title = {Modelling a Distributed Cached Store for Garbage Collection},
crossref = {ECOOP98}, 
URL = {http://cretina.inesc.pt/people/pjpf-home/ecoop98.ps}
}

@techreport{ferr98a,
author = {Paulo Ferreira and Marc Shapiro and Xavier Blondel and Olivier
Fambon and Jo\~{a}o Garcia and Sytse Kloosterman and Nicolas Richer and
Marcus Roberts and Fadi Sandakly and George Colouris and Jean Dollimore
and Paulo Guedes and Daniel Hagimont and Sacha Krakowiak},
title = {{PerDiS}: Design, Implementation and Use of a {PER}sistent
{DI}stributed {S}tore},
number = {QMW TR 752, CSTB ILC/98-1392, INRIA RR 3525, INESC RT/5/98},
institution = {QMW, CSTB INRIA and INESC},
month = oct,
year = 1998,
URL = {http://www-sor.inria.fr/publi/PDIUPDS_rr3525.html}
}

@inproceedings{ferr00,
author = {Paulo Ferreira and Marc Shapiro and Xavier Blondel and Olivier
Fambon and Jo\~{a}o Garcia and Sytse Kloosterman and Nicolas Richer and
Marcus Roberts and Fadi Sandakly and George Colouris and Jean Dollimore
and Paulo Guedes and Daniel Hagimont and Sacha Krakowiak},
title = {{PerDiS}: Design, Implementation and Use of a {PER}sistent
{DI}stributed {S}tore},
pages = {427--452},
URL = {http://link.springer.de/link/service/series/0558/papers/1752/17520427.pdf},
crossref = {krak00}
}


@inproceedings{fess97,
author = {Le Fessant, Fabrice and Ian Piumarta and Marc Shapiro},
title = {A Detection Algorithm for Distributed Cycles of Garbage},
URL = {ftp://ftp.dcs.gla.ac.uk/pub/drastic/gc/piumarta.ps},
crossref = {OOPSLA97-gc}
}

@inproceedings{fess98,
author = "Le Fessant, Fabrice and Ian Piumarta and Marc Shapiro",
title = "An Implementation for Complete Asynchronous Distributed Garbage Collection",
crossref = {PLDI98},
pages = {152--161},
URL = "http://www-sor.inria.fr/publi/ICADGC_pldi98.html",
abstract = {We expand an acyclic distributed garbage collector (the
cleanup protocol of Stub-Scion Pair Chains) with a detector of
distributed cycles of garbage. The whole result is as a complete and
asynchronous distributed garbage collector.
The detection algorithm for free distributed cycles is inspired by
Hughes. A local collector marks outgoing references with dates, which
are propagated asynchronously between spaces. A central server computes
the minimum of allowed dates, permitting cycles to be detected and
cut.
Our algorithm is both asynchronous and fault-tolerant. Moreover, it can
be adapted to large-scale systems.  Finally, it requires few resources
and it is easy to implement.}
}

@misc{fess99,
title = {Detection of Free Distributed Cycles in  Large-Scale Networks},
author = {Le Fessant, Fabrice},
month = jan,
year = 1999,
howpublished = {http://beaune.inria.fr:1976/files/00040.ps.gz}
}

@inproceedings{fess01,
title = {Detecting Distributed Cycles of Garbage in  Large-Scale Systems},
author = {Le Fessant, Fabrice},
booktitle = {Principles of Distributed Computing (PODC)},
address = {Rhodes Island},
month = aug,
year = 2001,
URL = {http://pauillac.inria.fr/~lefessan/papers/podc2001.ps.gz}
}

@book{fiel88,
author = "Anthony J. Field and Peter G. Harrison",
title = "Functional Programming",
publisher = AW,
year = "1988",
comments = "Chapter 16 looks at garbage collection algorithms"
}


@article{fish74,
author = "David A. Fisher",
title = "Bounded Workspace Garbage Collection in an Address Order Preserving List Processing Environment",
journal = IPL,
publisher = NH,
volume = 3,
number = 1,
month = Jul,
year = 1974, 
pages = "25--32",
}


@article{fish75,
author = "David A. Fisher",
title = "Copying Cyclic List Structure in Linear Time Using Bounded Workspace",
journal = CACM,
publisher = ACM,
volume = 18,
number = 5,
month = may,
year = 1975,
pages = "251--252",
comments = {algorithm for copying trees and general lists without using
a stack or mark bits.
It differs from the moving algorithms in that the altered contents of old lists
are later restored to their original values.},
}

@article{fitc78,
author = "John P. Fitch and Arthur C. Norman",
title = "A Note on Compacting Garbage Collection",
journal = CompJ,
publisher = BCS,
volume = 21,
number = 1,
month = Feb,
year = 1978, 
pages = "31--34",
}

@inproceedings{fitz00,
author = {Robert Fitzgerald and David Tarditi},
title = {The Case for Profile-Directed Selection of Garbage Collectors},
crossref = {ISMM2000},
abstract = {
Many garbage-collected systems use a single garbage collection
algorithm across all applications. It has long been known that this can
produce poor performance on applications for which that collector is
not well suited. In some systems, such as those that execute
stand-alone compiled executables, an appropriate collector for each
application can be selected from a pool of available collectors and
tuned by using profile information. In a study of 20 benchmarks and 6
collectors compiled with the Marmot optimizing Java-to-native compiler,
for every collector there was at least one benchmark that would have
been at least 15\% faster with a more appropriate collector. A detailed
analysis of storage management costs shows how they vary by application
and collector.
}
}

@inproceedings{flan96,
title = {\textit{p{H}luid}: the Design of a Parallel Functional Language Implementation on Workstations},
author = {Cormac Flanagan and Rishiyur S. Nikhil},
pages = {169--179},
crossref = {ICFP96}
}

@inproceedings{flei89,
author = "B. D. Fleisch",
title = "Mirage: A Coherent Distributed Shared Memory Design",
booktitle = "Proceedings of 12th ACM Symposium on Operating Systems Principles",
publisher = ACM,
pages = "211--213",
month = Dec,
year = 1989
}

@inproceedings{floo01,
author = {Christine Flood and Dave Detlefs and Nir Shavit and Catherine Zhang},
title = {Parallel Garbage Collection for Shared Memory Multiprocessors},
crossref = {JVM01},
URL = {http://www.usenix.org/events/jvm01/flood.html}
}

@inproceedings{fode81,
author = "John K. Foderaro and Richard J. Fateman",
title = "Characterization of {VAX} {M}acsyma",
booktitle = "1981 {ACM} Symposium on Symbolic and Algebraic Computation",
address ="Berkeley, CA",
year = 1981,
pages = "14--19",
publisher = ACM,
comment = {By the early 1980s Lisp programs spending 25--40 percent of their time marking and
sweeping, and users were waiting an average of 4.5s every 79s.}
}

@manual{fode85,
author = "John K. Foderaro and Keith Sklower and Kevin Layer and others",
title = "Franz {L}isp Reference Manual",
organization = "Franz Inc.",
year = 1985
}

@article{ford88,
author = "R. Ford",
title = "Concurrent Algorithms for Real-Time Memory Management",
journal = "IEEE Software",
publisher = IEEE,
month = sep,
year = 1988,
pages = "10--23"
}

@inproceedings{fori89,
author = "A. Forin and J. Barrera and M. Young and R. Rashid",
title = "Design, Implementation, and Performance Evaluation
of a Distributed Shared Memory Server for {Mach}",
booktitle = "Proceedings of the 1989 Winter USENIX conference",
publisher = UA,
month = Jan,
year = 1989
}

@techreport{fost88,
author = "Ian Foster",
title = "An Asynchronous Parallel Garbage Collector for a Single-Assignment Language",
institution = "Imperial College, London",
month = may,
year = 1988
}

@article{fost89,
title = "A Multicomputer Garbage Collector for a Single-Assignment Language.",
author = "Ian Foster",
journal = "International Journal of Parallel Programming",
volume = 18,
number = 3,
pages = "181--203",
year = "1989",
abstract = {An asynchronous garbage collector for a message-passing
multiprocessor (multicomputer) is described.  This combines Weighted Reference
Counting (WRC) interprocessor collection and tracing intraprocessor collection
to permit individual processors to reclaim local storage independently.  A
novel feature is the integration of Weighted Reference Counting collection and
the communication algorithms required to support a global address space in a
single assignment language.  This significantly reduces communication overhead
and space requirements attributable to garbage collection.  In addition,
techniques are described that avoid the creation of cyclic structures that
cannot be reclaimed using WRC.  Experimental studies performed in a concurrent
logic programming system that incorporates the collector confirm its efficiency
and the benefits of integrating garbage collector and language 
implementation.}
}


@techreport{fost89a,
author = "Ian Foster",
title = "Copy Avoidance through Local Reuse",
institution = "Argonne National Laboratory",
number = "MCS--P99--0989",
year = 1989
}

@inproceedings{fost91,
author = "Ian Foster and William Winsborough",
title = "Copy Avoidance through Compile-Time Analysis and Local Reuse",
booktitle = "Proceedings of International Logic Programming Sympsium",
pages = "455--469",
year = 1991
}

@book{fost68,
author = "J. M. Foster", 
title = "List Processing",
series = "Elsevier Computer Monographs",
publisher = ENH,
address = "New York", 
year = 1968,  
comments = {book with sections on garbage collection},
}

@mastersthesis{fost85,
author = "Foster, Mark H.",
title = "Design of a List-Structure Memory Using Parallel Garbage 
Collection",
year = 1985,
school = "Oregon Graduate Center"
}


@article{foth,
author = "J. A. Fotheringham",
title = "Dynamic Storage Allocation in the {A}tlas Computer Including an Automatic Use of the Backing Store",
journal = CACM,
publisher = ACM,
volume = 4,
pages = 435,
year = 1961
}

@inproceedings{frad94,
author = "Pascal Fradet",
title = "Collecting More Garbage",
crossref = "LFP94",
pages = "24--33",
URL = "ftp://ftp.irisa.fr/local/lande/pf-lisp94.ps.Z"
}

@article{fran78,
author = "Nissim Francez",
title = "An Application of a Method for Analysis of Cyclic Programs",
journal = TransSWE,
publisher = ACM,
volume = 4,
number = 5,
month = Sep,
year = 1978,
pages = "371--377",
}


@article{fran80,
title = "Distributed Termination",
author = "Nissim Francez",
journal = toplas,
publisher = ACM,
year = 1980,
month = jan,
volume = 2,
number = 1,
pages = "42--55",
}


@inproceedings{fran84,
title = "Generalized Fair Termination",
author = "Nissim Francez and Dexter Kozen",
crossref = "POPL84",
pages = "46--53",
}

@techreport{fran89,
title = {What's Different About Garbage Collection for Persistent Programming Languages},
author = {Michael Franklin and G. Copeland and G. Weikum},
institution = {Microelectronics and Computer Technology Corporation},
number = {ACA-ST-062-89},
pages = 11,
year = 1989,
abstract = {Work in garbage collection in the programming language
community dates back over twenty-five years to early work on list
processing languages. With the advent of persistent programming
languages and database systems which provide general purpose
programming capabilities, garbage collection issues are becoming more
relevant to designers of systems that manage persistent data. Although
much of the earlier work is applicable to persistent programming, there
are a number of new constraints that must be addressed in order to
provide efficient garbage collection for systems with large amounts of
persistent data. This paper describes these constraints and the
problems that they give rise to. It then proposes some techniques that
may lead toward a solution of these problems.}
}

@manual{fran88,
key = "Franz, 1988",
organization = "Franz Inc.",
title = "Allegro {CL} User Guide",
edition = "Release 3.0 (beta)",
month = apr,
year = 1988
}

@manual{fran92,
key = "Franz, 1992",
organization = "Franz Inc.",
title = "Allegro {CL} User Guide, Version 4.1",
edition = "Revision 2",
month = mar,
year = 1992
}

@article{frei75,
author = "W. F. Freiburger and U. Grenander and P. D. Sampson",
title = "Patterns in Program References",
journal = "IBM Journal of Research and Development",
volume = 19,
number = 3,
month = may,
year = 1975,
pages = "230--243"
}

@article{frie76,
author = "Daniel P. Friedman and David S. Wise",
title = "Garbage Collecting a Heap which included a Scatter Table",
journal = IPL,
publisher = NH,
volume = 5,
number = 6,
month = dec,
year = 1976,
pages = "161--164",
}


@article{frie77,
crossref = {wise77}
}


@article{frie78,
author = "Daniel P. Friedman and David S. Wise",
title = "Aspects of Applicative Programming for Parallel Processing",
journal = IEEETransComp,
publisher = IEEE,
volume = 27,
number = 4,
pages = "289--296",
month = Apr,
year = 1978
}

@article{frie79,
author = "Daniel P. Friedman and David S. Wise",
title = "Reference Counting Can Manage the Circular Environments of Mutual Recursion",
journal = IPL,
publisher = NH,
volume = 8,
number = 1,
month = jan,
year = 1979,
pages = "41--45",
}

@inproceedings{fuch95,
title = "Garbage Collection on an Open Network",
author = "Matthew Fuchs",
address = "Concurrent Engineering Research Center, West Virginia University, Mor
gantown, WV",
crossref = "IWMM95"
}

@inproceedings{furu91,
author = "Shinichi Furusou and Satoshi Matsuoka and Akinori Yonezawa",
title = "Parallel Conservative Garbage Collection with Fast Allocation",
crossref = "OOPSLA91-gc",
}


@inproceedings{gabr82,
author = "Richard P. Gabriel and L. M. Mansinter",
title = "Performance of {L}isp Systems",
crossref = "LFP82",
pages = "123--142",
}



@book{gabr85,
author = "Richard P. Gabriel",
title = "Performance and Evaluation of {Lisp} Systems",
series = "MIT Press Series in Computer Science",
publisher = "MIT Press",
address = "Cambridge, MA",
year = 1985    
}

@article{gai85,
author = "S. Gai and M. Mezzalama",
title = "Dynamic Storage Allocation: Experiments Using the {C} Language",
journal = SPE,
publisher = Wiley,
volume = 15,
number = 7,
month = jul,
year = 1985,
pages = "693--704"
}

@mastersthesis{gane94,
author = "Ravichandran Ganesan",
title = "Local Variable Allocation for Accurate Garbage Collection of {C++}",
school = "Iowa State University",
month = jul,
year = 1994,
note = "Technical Report ISUTR 94--12",
URL = "http://www.cs.iastate.edu/tech-reports/TR94-12.ps"
}


@article{gann88,
author = "D. Gannon and W. Jalby and K. Gallivan",
title = "Strategies for Cache and Local Memory Management by Global Program Transformation",
journal = "Journal of Parallel and Distributed Computing",
volume = 5,
pages = "587--616",
year = 1988
}

@techreport{gao94,
author = "Hong Gao and Kelvin Nilsen",
title = "Reliable General Purpose Dynamic Memory Management for Real-Time Systems",
institution = "Iowa State University",
number = "TR94--09",
month = jul,
year = 1994,
URL = "http://www.cs.iastate.edu/tech-reports/TR94-09.ps",
comment = "Presents an overview of a hardware-assisted real-time (copying)
garbage collector for C++, comparing its average and worst-case performance
and heap utilization with several standard non-GC allocators."
}

@inproceedings{gare72,
author = "M. R. Garey and R. L. Graham and Jeffrey D. Ullman",
title = "Worst-Case Analysis of Memory Allocation Algorithms",
booktitle = "Fourth Annual ACM Symposium on the Theory of Computing",
publisher = ACM,
year = 1972
}


@article{garn80,
author = "N. H. Garnett and Roger M. Needham",
title = "An Asynchronous Garbage Collector for the {C}ambridge File Server",
journal = "Operating Systems Review",
publisher = ACM,
volume = 14,
number = 4,
pages = "36--40",
year = 1980
}

@inproceedings{gart97,
author = {Alex Garthwaite and Scott Nettles},
title = {Concurrent Collection for the {J}ava {D}evelopment {K}it},
URL = {ftp://ftp.dcs.gla.ac.uk/pub/drastic/gc/nettles-javaGC.ps},
crossref = {OOPSLA97-gc}
}

@inproceedings{gart98,
author = {Alex Garthwaite and Scott Nettles},
title = {{TJ}ava: a Transactional {J}ava},
booktitle = {IEEE International Conference on Computer Languages},
year = 1998,
publisher = IEEE
}

@inproceedings{gay98,
author = {David Gay and Alex Aiken},
title = {Memory Management with Explicit Regions},
crossref = {PLDI98},
pages = {313--323},
URL = {http://www.acm.org/pubs/articles/proceedings/pldi/277650/p313-gay/p313-gay.pdf}
}
@techreport{gay98a,
author = {David Gay and Bjarne Steensgaard},
title = {Stack Allocating Objects in {J}ava},
institution = {Microsoft Research},
month = oct,
year = 1998,
URL = {http://research.microsoft.com/apl/stackalloc-abstract.pdf}
}

@inproceedings{gay00,
author = {David Gay and Bjarne Steensgaard},
title = {Fast Escape Analysis and Stack Allocation for Object-Based Programs},
booktitle = {International Conference on Compiler Construction (CC'2000)},
series = LNCS,
volume = 1781,
publisher = SV,
URL = {http://research.microsoft.com/copyright/accept.asp?path=/research/apl/pubs/stackalloc.ps&pub=15},
year = 2000
}

@inproceedings{gay01,
author = {David Gay and Alex Aiken},
title = {Language Support for Regions},
crossref = {PLDI01}
}


@article{gee93,
author = "Jeffrey D. Gee and Mark D. Hill and Dionisios N. Pnevmatikatos 
and Alan J. Smith",
title = "Cache Performance of the {SPEC92} Benchmark Suite",
journal = "IEEE Micro",
publisher = IEEE,
volume = 13,
number = 4,
pages = "17--27",
year = 1993
}


%check names
@inproceedings{gehr93,
author = "Edward F. Gehringer and Ellis Chang",
title = "Hardware-Assisted Memory Management",
crossref = "OOPSLA93-gc",
}

@article{gele60,
author = "H. Gelernter and J. R. Hansen and C. L. Gerberich",
title = "A {F}ortran-compiled List Processing Language",
journal = JACM,
publisher = ACM,
volume = 7,
number = 2,
month = Apr,
year = 1960,
pages = "87--101",
comment = {The earliest? paper on reference counting. Lists had owners and
users; the user was required to maintain the reference count (and therefore
decide when to delete a list). All sorts of scope for error, dangling pointers.
Collins described the method as quite useless.  }
}



@article{gele71,
author = "E. Gelenbe",
title = "The Two-Thirds Rule for Dynamic Storage Allocation under Equilibrium",
journal = IPL,
publisher = NH,
volume = 1,
year = 1971,
pages = "59--60",
}


@article{gerh79,
author = "S. L. Gerhart",
title = "A Derivation Oriented Proof of {S}chorr--{W}aite Marking Algorithm",
journal = LNCS,
publisher = SV,
address = "New York", 
volume = 69,
year = 1979, 
pages = "472--492",
comments = {proves the correctness of the link reversal algorithm by Deutsch-Schorr-Waite},
}

@inproceedings{gheo03,
title = {Interprocedural Compatibility Analysis for Static Object Preallocation},
author = {Ovidiu Gheorghioiu and Alexandru Salcianu and Martin Rinard},
crossref = {POPL03}
}

@inproceedings{ghiy01,
title = {On the Importance of Points-to Analysis and Other Memory Disambiguation Methods for {C} Programs},
author = {Rakesh Ghiya and Daniel Laverty and David Sehr},
crossref = {PLDI01}
}


@techreport{ghos94,
author = {Kaushik Ghosh},
title = {Reconfigurable Garbage Collection of Data Structures in a Speculative Real-Time System},
institution = {Georgia Institute of Technology},
number = {GIT-CC-94-57},
year = 1994,
URL = {ftp://ftp.cc.gatech.edu/pub/coc/tech_reports/1994/GIT-CC-94-57.ps.Z}
}


@misc{gill,
title = {An Introduction to Garbage Collection},
author = {Richard Gillam},
howpublished = {http://oss.software.ibm.com/icu/docs/papers/cpp\_report/an\_introduction\_to\_garbage\_collection\_part\_i.html},
URL = {http://oss.software.ibm.com/icu/docs/papers/cpp_report/an_introduction_to_garbage_collection_part_i.html}
}

@mastersthesis{gint91,
author = "Andrew Ginter",
title = "Cooperative Garbage Collection using Smart Pointers in the {C++}
Programming Language",
school = "University of Calgary",
year = 1991,
month = dec,
note = "Technical report 91/451/45",
}

@article{gira87,
author = "J.-Y. Girard",
title = "Linear Logic",
journal = "Theoretical Computer Science",
volume = 50,
pages = "1--102",
year = 1987,
comment = "Linear variables must be used exactly once hence optimising away
reference counts for instance."
}

@inproceedings{glas86,
title = "Another Implementation Technique for Applicative Languages",
author = "Hugh W. Glaser and S. Hayes",
booktitle = "Proceedings of {ESOP'86} --- European Symposium on Programming",
address = "Saarbruecken",
month = mar,
series = LNCS,
volume = 213,
publisher = SV,
pages = "70--81",
year = 1986,
abstract = {This paper will present a particularly simple data flow model which
is similar to supercombinator reduction, supporting higher order functions,
garbage collection and a form of lazy evaluation in a clear and natural 
manner.
The paper will also show how the model can be made to execute on a conventional
processor.  Such a method has shown significant speed increases over other
available methods of evaluating functional programs, and the hardware
implementation holds the promise of a machine that executes applicative
languages at a comparable speed to conventional hardware executing control flow
programs.  In addition, unlike other proposed models, the extensions to a 
multi-processor machine are natural and well defined, with the potential
of even greater speedups.}
}


@article{glas87,
author = "Hugh W. Glaser and P. Thompson",
title = "Lazy Garbage Collection",
journal = SPE,
publisher = Wiley,
volume = 17,
number = 1,
pages = "1--4",
month = jan,
year = "1987",
comments = {\cite{lins91} shows that the decrease
in main-memory access using this algorithm is not big. 
Unable to deal with cyclic structures.},
}


@techreport{glas87a,
author = "Hugh W. Glaser", 
title = "On Minimal Overhead Reference Count Garbage Collection in Distributed Systems",
institution = "Department of Computing, Imperial College, London",
year = 1987,
abstract = {In this paper we present a garbage collection scheme that does not
require any access to main memory by the garbage collection process.
We achieve this by the combination of two recently proposed garbage collection
techniques: Lazy Garbage Collection and Weighted Reference Count garbage collection...}
}


@techreport{glas89,
author = "Hugh W. Glaser and  Michael Reeve and S. Wright", 
title = "An Analysis of Reference Count Garbage Collection Schemes for 
Declarative Languages",
institution = "Department of Computing, Imperial College, London",
year = 1989,
abstract = "Considers different methods of implementing reference count
garbage collection and presents a new scheme, the Lazy/Weighted method. 
It gives a comparison of the methods based on efficiency, real-time 
operation and applicability for both centralised and distributed systems and
then uses the data gathered from experiments with the ALICE parallel machine to
quantify the comparison. The results show that the Lazy/Weighted method 
is the most promising.",
comments = "I am not convinced that the Lazy/Weighted method is any better
than the original Weighted algorithm"
}


@misc{goet03,
author = {Brian Goetz},
title = {{J}ava Theory and Practice: A Brief History of Garbage Collection},
month = oct,
year = 2003,
howpublished = {http://www-106.ibm.com/developerworks/java/library/j-jtp10283/},
URL = {http://www-106.ibm.com/developerworks/java/library/j-jtp10283/},
note = {First of a series of three articles}
}

@misc{goet03a,
author = {Brian Goetz},
title = {{J}ava Theory and Practice: Garbage Collection in the 1.4.1 {JVM}},
month = nov,
year = 2003,
howpublished = {http://www-106.ibm.com/developerworks/java/library/j-jtp11253/},
URL = {http://www-106.ibm.com/developerworks/java/library/j-jtp11253/},
note = {Second of a series of three articles}
}

@misc{goet04,
author = {Brian Goetz},
title = {{J}ava Theory and Practice: Garbage Collection and Performance},
month = jan,
year = 2004,
howpublished = {http://www-106.ibm.com/developerworks/java/library/j-jtp01274/},
URL = {http://www-106.ibm.com/developerworks/java/library/j-jtp01274/},
note = {Last of a series of three articles}
}

@misc{gogu98,
author = {Healfdene Goguen and Richard Brooksby and Rod Burstall},
title = {An Abstract Formulation of Memory Management},
month = dec,
year = 1998,
note = "draft",
URL = {http://www.dcs.ed.ac.uk/home/hhg/mm.dvi.gz}
}

@inproceedings{gogu99,
author = "Healfdene Goguen and Richard Brooksby and Rod M.~Burstall",
title = {Memory Management: An Abstract Formulation of Incremental Tracing},
booktitle = {Types for Proofs and Programs, International Workshop TYPES'99},
year = 2000,
pages  = "148--161",
publisher = {Springer}
}

@inproceedings{gont96,
author = {Georges Gonthier},
title = {Verifying the Safety of a Practical Concurrent Garbage Collector},
booktitle = {Computer Aided Verification CAV'96},
address = {New Brunswick, NJ},
editor = {R. Alur and T. Henzinger},
series = LNCS,
publisher = SV,
year = 1996
}

@inproceedings{gold74,
author = "Ron P. Goldberg and R. Hassinger",
title = "The Double Paging Anomaly",
booktitle = "AFIPS National Computer Conference",
year = 1974,
month = May,
pages = {195--199}
}

@book{gold83,
author = "Adele Goldberg and D. Robson",
title = "Smalltalk-80: The Language and its Implementation",
publisher = AW,
year = 1983,
comment = "Reference counter + second collector"
}

@inproceedings{gold89,
author = "Benjamin Goldberg",
title = "Generational Reference Counting: A Reduced-Communication Distributed Storage Reclamation Scheme",
crossref = "PLDI89",
pages = "313--320",
comment = "Claims similar communication overhead to Weighted reference counting.
However storage overheads are greater.
(Nothing to do with generational GC.)"
}


@article{gold91,
title = "Tag-Free Garbage Collection for Strongly Typed Programming Languages",
author = "Benjamin Goldberg",
address = "Courant Inst Math Sci, Department of Computer Science, New York, 10012",
journal = Sigplan,
publisher = ACM,
year = 1991,
volume = 26,
number = 6,
pages = "165--176",
comment = "For a purely statically-typed language, no per-object runtime type
information is necessary, except the types of the root set variables."
}


@inproceedings{gold92,
author = "Benjamin Goldberg and Michael Gloger",
title = "Polymorphic Type Reconstruction for Garbage Collection Without Tags",
crossref = "LFP92",
pages = "53--65",
comment = "
By doing type unifications at garbage collection time
the garbage collector can re-derive almost all type information.  And
what it cannot derive doesn't matter.  Interesting, but probably impractical."
}

@inproceedings{gold92a,
author = "Benjamin Goldberg",
title = "Incremental Garbage Collection Without Tags",
booktitle = "Proceedings ESOP92  --- European Symposium on Programming",
year = 1992,
URL = {http://www.cs.nyu.edu/goldberg/pubs/gold92.pdf}
}


@phdthesis{gold92b,
author = {Richard A. Golding},
title = {Weak-Consistency Group Communication and Membership},
school = {University of California at Santa Cruz},
month = dec,
year = 1992,
note = {UCSC- CRL-92-52}
}

@inproceedings{gold88,
author = "Goldman, Ron and Richard P. Gabriel",
title = "Preliminary Results with the Initial Implementation of {Q}lisp",
crossref = "LFP88",
pages = "143--152"
}

@techreport{gonc94,
title = "Cache Performance of Fast-Allocating Programs",
author = {Marcelo J. R. Gon\c{c}alves and Andrew W. Appel},
institution = Princeton,
number = "CS--TR--482--94",
month = dec,
year = 1994,
URL = "http://ncstrl.cs.Princeton.EDU/expand.php?id=TR-482-94"
}

@inproceedings{gonc95,
title = "Cache Performance of Fast-Allocating Programs",
author = {Marcelo J. R. Gon\c{c}alves and Andrew W. Appel},
crossref = "FPCA95",
}

@phdthesis{gonc95a,
author = {Marcelo J. R. Gon\c{c}alves},
title = "Cache Performance of Programs with Intensive Heap Allocation 
and Generational Garbage Collection",
school = PRINCETON,
month = may,
year = 1995,
}

@book{gosl97,
title = {The {J}ava Language Specification},
author = {James Gosling and Bill Joy and Guy Steele},
publisher = AW,
series = {The {J}ava Series},
ISBN = {0-201-63451-1},
pages =864,
year = 1997,
URL = {http://www.aw.com/cp/gosling-joy-etal.html}
}


@book{gotl78,
author = "C. C. Gotlieb and L. R. Gotlieb",
title = "Data Types and Structures",
publisher = PH,
year = 1978,
comments = {book with sections on garbage collection.
Presents an optimization to the copying algorithm (feni69) by moving a list into
a contiguous area of the memory space with the stack implicit in the list being
moved. Clark (clar76) shows that his algorithm is in most cases more efficient
than both Cheney's (chen70) and Reingold's (rein73).},
}

@techreport{gott82,
author = "A. Gottlieb and J. Wilson",
title = "Parallelizing the Usual Buddy Algorithm",
institution = "Courant Institute, New York University",
number = "System Software Note 37",
year = 1982
}


@inproceedings{goto79,
author = "E. Goto and I. Tetsuo and K. Hiraki and M. Susuki and N. Inada",
title = "{FLATS}, A Machine for Numerical, Symbolic and Associative Computing",
booktitle = "6th Annual Symposium on Computer Architecture",
pages = "102--110",
year = 1979,
month = apr
}

@inproceedings{goto88,
author = "Atsuhiro Goto and Y. Kimura and T. Nakagawa and T. Chikayama",
title = "Lazy Reference Counting: An Incremental Garbage Collection Method 
for Parallel Inference Machines",
crossref = "ICLP88",
pages = "1241--1256",
note = "Also ICOT Technical Report TR-354, 1988"
}

@inproceedings{gour92,
author = "Y. Gourhant and S. Louboutin and V. Cahill and A. Condon and G. Starovic and B. Tangney",
title = "Dynamic Clustering in an Object-Oriented Distributed System",
booktitle = "Proceedings of {OLDA-II} (Objects in Large Distributed Applications)",
year = 1992,
address = "Ottawa, Canada",
month = oct,
abstract = "In an O-O distributed system, object grouping is crucial in
order to optimize communications between objects and disk I/O
transfers. In this paper, we present a general purpose and
scalable object clustering method which is integrated with
garbage collection and load balancing processing. We proposed
a mixed dynamic and user-driven approach.",
URL = "ftp://ftp.dsg.cs.tcd.ie/pub/doc/dsg-24.ps.gz",
}


@incollection{goye71,
author = "P. Goyer",
title = "A Garbage Collector to be Implemented on a {CDC} 3100",
crossref = "Algol68",
pages = "303--317",
}

@mastersthesis{gray87,
author = "Gray, Stanley M.",
title = "Garbage Collection in a Parallel Processing Environment",
year = 1987,
school = "East Texas State University"
}

@techreport{gree74,
author = "Richard Greenblat",
title = "The {LISP} Machine",
institution = MITAI,
type = "Working Paper",
number = 79,
month = nov,
year = 1974,
comment = "MIT Lisp machine"
}

@incollection{gree84,
author = "Richard Greenblatt",
title = "The {LISP} Machine",
booktitle = "Interactive Programming Environments",
editor = "D. R. Barstow and H. E. Shrobe and E. Sandewall",
publisher = MGH,
year = 1984,
comment = "MIT Lisp Machines have special purpose hardware to detect pointers
into fromspace and trap to a handler.
The cost of this checking on a conventional machine is in the tens of percent
for a high performance system.
Uses Lieberman and Hewitt."
}


@article{grie77,
author = "David Gries",
title = "An Exercise in Proving Parallel Programs Correct",
journal = CACM,
publisher = ACM,
volume = 20,
number = "12",
month = dec,
year = 1977,
pages = "921--930",
comment = "Proof of correctness of Dijkstra {\it et al.}'s on-the-fly
algorithm."
}


@article{grie77a,
author = "David Gries",
title = "On Believing Programs to be Correct",
journal = CACM,
publisher = ACM,
volume = 20,
number = "1",
month = jan,
year = 1977,
pages = "49--50",
comment = "Proof of correctness of Dijkstra {\it et al.}'s on-the-fly
algorithm."
}


@article{grie79,
author = "David Gries",
title = "The {S}chorr--{W}aite Graph Marking Algorithm",
journal = ActInf,
publisher = SV,
volume = 11,
number = 3,
year = 1979,
pages = "223--232",
comments = {proves the correctness of the link reversal algorithm by Deutsch-Schorr-Waite},
}


@mastersthesis{grim89,
title = "Multiple Prefetch Adaptive Disk Caching with Strategic Data Layout",
author = "Knut S. Grimsrud",
school = "Brigham Young University",
year = 1989,
month = dec
}


@misc{gris72,
author = "R. E. Griswold",
title = "The Macro Implementation of {S}nobol 4", 
publisher = "W. H. Freeman", 
address = "San Francisco", 
year = 1972,
comment = "should find a proper reference to this work"
}

@book{gris83,
author = "R. E. Griswold and M. T. Griswold",
title = "The {Icon} Programming Language",
publisher = PH,
year = 1983
}

@article{grit81,
title = "Deleting Irrelevant Tasks in an Expression-Oriented Multiprocessor System",
author = "Dale H. Grit and Rex L. Page",
journal = toplas,
publisher = ACM,
year = 1981,
month = jan,
volume = 3,
number = 1,
pages = "49--59",
}

@inproceedings{gros02,
title = {Region-Based Memory Management in {C}yclone},
author = {Dan Grossman and Greg Morrisett and Trevor Jim and Michael Hicks and Yanling Wang and James Cheney},
crossref = {PLDI02},
pages = {282--293},
abstract = {Cyclone is a polymorphic, type-safe programming language
derived from C. The primary design goals of Cyclone are to let
programmers control data representations and memory management without
sacrificing type-safety. In this paper, we focus on the region-based
memory management of Cyclone and its static typing discipline. The
design incorporates several advancements, including support for region
subtyping and a coherent integration with stack allocation and a
garbage collector. To support separate compilation, Cyclone requires
programmers to write some explicit region annotations, but uses a
combination of default annotations, local type inference, and a novel
treatment of region effects to reduce this burden. As a result, we
integrate C idioms in a region-based framework.  In our experience,
porting legacy C to Cyclone has required altering about 8 percent of
the code; of the changes, only 6 percent (of the 8 percent) were region
annotations.}
}

@mastersthesis{grou99,
author = {Morten Grouleff},
title = {A Concurrent Garbage Collector for {BETA}},
school = {University of Aarhus},
month = dec,
year = 1999,
URL = {URL:http://www.daimi.au.dk/~grouleff/thesis.html}
}

@techreport{grun92,
author = "Dirk Grunwald and Benjamin Zorn",
title = "{CUSTOMALLOC}: Efficient Synthesized Memory Allocators",
institution = "University of Colorado",
type = "Computer Science Technical Report",
number = "CU-CS-602-92",
address = "Campus Box 430, Boulder, CO 80309",
month = jul,
year = 1992,
}

@inproceedings{grun93,
title = "Improving the Cache Locality of Memory Allocation",
author = "Dirk Grunwald and Benjamin Zorn and Robert Henderson",
crossref = "PLDI93",
pages = "177--186",
URL = {ftp://ftp.cs.colorado.edu/pub/cs/techreports/grunwald/PLDI-93-locality.ps.Z},
abstract = {The allocation and disposal of memory is a ubiquitous operation in
most programs. Rarely do programmers concern themselves with details
of memory allocators; most assume that memory allocators provided by
the system perform well.  This paper presents a performance evaluation
of the reference locality of dynamic storage allocation algorithms
based on trace-driven simulation of five large allocation-intensive C
programs.  In this paper, we show how the design of a memory allocator
can significantly affect the reference locality for various
applications.  Our measurements show that poor locality in
sequential-fit allocation algorithms reduces program performance, both
by increasing paging and cache miss rates.  While increased paging can
be debilitating on any architecture, cache misses rates are also
important for modern computer architectures.  We show that algorithms
attempting to be space-efficient by coalescing adjacent free objects
show poor reference locality, possibly negating the benefits of space
efficiency.  At the other extreme, algorithms can expend considerable
effort to increase reference locality yet gain little in total
execution performance.}
}

@article{grun93a,
author = "Dirk Grunwald and Benjamin Zorn",
title = "CustoMalloc: Efficient, Synthesised Memory Allocators",
journal = SPE,
publisher = Wiley,
volume = 23,
pages = "851--869",
year = 1993,
URL = "http://www.cs.colorado.edu/homes/grunwald/public_html/SPE93-customalloc.ps"
}


@techreport{gude93,
author = "David Gudeman",
title = "Representing Type Information in Dynamically-Typed Languages",
year = 1993,
number = "TR93-27",
institution = "University of Arizona, Department of Computer Science",
address = "Tucson, Arizona"
}

@mastersthesis{gugg94,
author = "Satish Kumar Guggilla",
title = "Generational Garbage Collection of {C++} Targeted to {SPARC} Architectures",
school = "Iowa State University",
month = jul,
year = 1994,
note = "Technical report ISUTR 94-11",
URL = "http://www.cs.iastate.edu/tech-reports/TR94-11.ps"
}

@inproceedings{gupt88,
title = "Reliable Garbage Collection in Distributed Object Oriented Systems",
author = "Aloke Gupta and W. K. Fuchs",
booktitle = "Proceedings of the Twelfth Annual International Computer 
Software  Applications Conference (COMPSAC 88)",
address = "Chicago", 
month = oct,
publisher = IEEE,
pages = "324--328",
year = 1988,
abstract = {The authors examine the problem of reliable storage reclamation in
a distributed object-oriented system.  A distributed algorithm is proposed that
utilizes a modified reference counting strategy for intermode pointers and 
mark-and-sweep for local garbage collection.  The algorithm allows nodes to fail
in a failstop manner, in which case the global garbage collection functions in 
a gracefully degraded mode of operation.  Compaction of objects is supported 
and object locality is exploited to reduce overhead.},
comment = "Fault-tolerance is achieved be entering candidate garbage into tables until
they can be removed.
Cycles handled by migration of local garbage (when of sufficient age)."
}

@mastersthesis{gupt90,
author = "Gupta, Aloke",
title = "Low Overhead Garbage Collection in a Distributed Object-Oriented System",
year = 1990,
school = "University of Illinois at Urbana-Champaign"
}

@article{gupt93,
author = "Gupta, Aloke and W. K. Fuchs",
title = "Garbage Collection in a Distributed Object-Oriented System",
journal = "IEEE Transactions on Knowledge and Data Engineering",
publisher = IEEE,
volume = 5,
number = 2,
month = apr,
year = 1993
}

@misc{gupt03,
author = {Alka Gupta},
title = {{GC} Portal},
month = jul,
year = 2003,
howpublished = {http://java.sun.com/developer/technicalArticles/Programming/GCPortal/},
URL = {http://java.sun.com/developer/technicalArticles/Programming/GCPortal/},
abstract = {The GC Portal enables analysis and performance tuning of
Java applications from a garbage collection (GC) perspective by mining
the verbose:gc logs generated by the JVM. GC Portal is a one-stop page
for GC issues and includes an extensive collection of whitepapers, case
studies and other material. The Portal is intended to be used with
HotSpot JVM from Sun Microsystems, distributed as part of Java 2,
Standard Edition (J2SE). Use of the GC Portal enables developers to
model application and JVM behaviors from a GC perspective. This article
introduces the design and features of the GC Portal, to enable
developers to use it as a tool for analyzing and tuning GC.}
}
@article{gutt95,
title = {The {VLISP} verified {S}cheme System},
author = {J.D. Guttman and J.D. Ramsdel and V. Swarup},
journal = LSC,
volume = 8,
number = {1/2},
month = mar,
year = 1995,
pages = {33-110}
}

@inproceedings{guzm90,
author = {J. C. Guzm\'{a}n and Paul Hudak},
title = "Single Threaded Polymorphic Lambda Calculus",
booktitle = "Fifth IEEE Symposium on Logic in Computer Science",
publisher = IEEE,
year = 1990
}

@article{hadd67,
author = "B. K. Haddon and  W. M. Waite",
title = "A Compaction  Procedure  for  Variable Length Storage Elements",
journal = CompJ,
publisher = BCS,
volume = 10,
month = Aug,
year = 1967,
pages = "162--165",
comments = {algorithm for compacting varisized cells},
}

@article{haga96,
author = "Tom Hagan",
title = "Not Just A Stopgap",
journal = "Information Week",
month = jan,
year = 1996,
publisher = "CMP Publications, Inc",
comment = "Two page article on Geodesic Systems Great Circle collector"
}

@inproceedings{hagg98,
author = {Daniel H\"{a}ggander and  Lars Lundberg},
title = {Optimizing Dynamic Memory Management in a Multithreaded Application Executing on a Multiprocessor},
booktitle = {Proceedings of ICPP'98 27th International Conference on Parallel Processing},
address = {Minneapolis, MN},
month = aug,
year = 1998,
URL = {http://www.ide.hk-r.se/~dha/icpp-98.ps}
}

@inproceedings{hagg99,
author = {Daniel H\"{a}ggander and  Lars Lundberg},
title = {Memory Allocation Prevented Telecommunication Application to be Parallelized for Better Database Utilization},
booktitle = {Proceedings of PART'99 6th International Australasian Conference on Parallel and Real-Time Systems},
address = {Melbourne},
month = nov,
year = 1999,
URL = {http://www.ide.hk-r.se/~dha/part-99.ps}
}

@inproceedings{hagg00,
author = {Daniel H\"{a}ggander and  Lars Lundberg},
title = {Attacking the Dynamic Memory Problem for {SMP}s},
booktitle = {Proceedings of PDCS'2000 13th International Conference on Parallel and Distributed Computing System},
year = 2000
}

@inproceedings{hagg01,
author = {Daniel H\"{a}ggander and Per Liden and Lars Lundberg},
title = {A Method for Automatic Optimization of Dynamic Memory Management in {C++}},
booktitle = {Proceedings of ICPP'01 30th International Conference on Parallel Processing},
address = {Valencia, Spain},
month = sep,
year = 2001,
URL = {http://www.ide.hk-r.se/~dha/icpp-01.ps}
}


@techreport{hall96,
author = {Niels Hallenberg},
title = {A Region Profiler for a {S}tandard {ML} Compiler Based on Region Inference},
type = {Student Project},
number = {96--5--7},
institution = DIKU,
month = jun,
year = 1996
}


@mastersthesis{hall99,
author = {N. Hallenberg},
title = {Combining Garbage Collection and Region Inference in the {ML} {K}it},
school = DIKU,
month = jun,
year = 1999,
URL = {http://www.it-c.dk/people/nh/mypapers/root260699-a4.ps.gz}
}

@inproceedings{hall02,
title = {Combining Region Inference and Garbage Collection},
author = {Niels Hallenberg and Martin Elsman and Mads Tofte},
crossref = {PLDI02},
pages = {141--152},
abstract = {This paper describes a memory discipline that combines
region-based memory management and copying garbage collection by an
extension of Cheney's copying garbage collection algorithm. The paper
presents empirical evidence that region inference very significantly
reduces the number of garbage collections; and evidence that the
fastest execution is obtained by using regions alone, without garbage
collection.
  The memory discipline is implemented for Standard ML in the
ML Kit compiler and measurements show that for a variety of
benchmarks, code generated by the compiler is as efficient,
both with respect to execution time and memory usage, as
programs compiled with a state-of-the-art Standard ML
compiler.}
}

@inproceedings{halp84,
title = "The Semantics of Local Storage, or What Makes the Free-List Free?",
author = "Joseph Y. Halpern and Albert R. Meyer and B. A. Trakhtenbrot",
crossref = "POPL84",
pages = "245--257"
}

@techreport{hals78,
author = "Robert H. Halstead",
title = "Multiple-Processor Implementations of Message Passing Systems",
institution = MITLCS,
number = "TR--198",
month = Apr,
year = 1978
}


@inproceedings{hals84,
author = "Robert H. Halstead",
title = "Implementation of {M}ultilisp: {L}isp on a Multiprocessor",
crossref = "LFP84",
}


@article{hals85,
title = "Multilisp: A Language for Concurrent Symbolic Computation",
author = "Robert H. Halstead",
journal = TOPLAS,
publisher = ACM,
year = "1985",
month = oct,
volume = 7,
number = 4,
pages = "501--538",
abstract = {MULTILISP is a dialect of LISP (actually a version of the SCHEME dialect)
with added constructs for parallel execution. MULTILISP has been
implemented on the 32-processor Concert multiprocessor. It is destined for
implementation on larger multiprocessors.
The principal language extension provided by MULTILISP is ``future (x).''
Upon executing ``future (x),'' an immediate ``undetermined'' value is
returned. The computation of ``x'' occurs in parallel and the result
replaces ``undetermined'' when complete. Of course, any use of the result
would block the parent process until the computation is finished.
The paper goes into great detail discussing the motivating issues in
parallel language design. The author includes an excellent set of
references on competing work. The author discusses the issues of lazy
evaluation, resource allocation, and implementation. The implementation
issues include intermediate instruction-set architecture (MCODE),
synchronization, implementation of futures, task management, heap
management, and garbage collection. The author also presents 
performance
analysis based on the number of processors and the granularity of the
parallelism in the algorithm (number of futures).
The paper is well written, with extensive footnotes and references. A
background in LISP fundamentals and the issues involved in distributed
processing will be helpful, but is not necessary.}
}


@inproceedings{hami92,
author = {T. Hamid and M.K. Crowe},
title = {Garbage Collection in Large Scale Distributed Object Stores},
booktitle = {Objects in Large Distributed Applications (OLDA II) --- OOPSLA'92},
year = 1992,
}

@mastersthesis{hami97,
title = {Measuring the Performance of Disk Garbage Collectors: Garbage Collecting Persistent {J}ava Stores},
author = {Craig Hamilton},
school = {University of Glasgow},
year = 1997,
URL = {http://www.dcs.gla.ac.uk/~craig/project/thesis.ps.gz}
}


@inproceedings{hami90,
author = "G. W. Hamilton and Simon B. Jones",
title = "Compile-Time Garbage Collection by Necessity Analysis",
crossref = "glasgow90",
pages = "66--70",
}

@techreport{hami90a,
author = "G. W. Hamilton and Simon B. Jones",
title = "Compile-Time Garbage Collection by Necessity Analysis",
institution = "Department of Computer Science and Mathematics, University of Stirling",
number = 67,
year = 1990
}

@phdthesis{hami93,
author = "G. W. Hamilton",
title = "Compile-Time Optimisation of Store Usage in Lazy Funtional Programs",
school = "University of Stirling",
year = 1993
}

@inproceedings{hami95,
title = "Compile-Time Garbage Collection for Lazy Functional Languages",
author = "G. W. Hamilton",
address = "Department of Computer Science, Keele University",
crossref = "IWMM95",
}

@unpublished{hamm94,
author = "Kevin Hammond and Geoff L. Burn and D. B. Howe",
title = "Spiking Your Caches",
note = "Glasgow University",
year = 1994
}

@inproceedings{hann95,
author = {J. Hannon},
title = {A Type-based Analysis for Stack Allocation in Functional Languages},
booktitle = {Proceedings of Second International Static Analysis Sumposium (SAS'95)},
series = LNCS,
volume = 983,
pages = {172--188},
mon = sep,
publisher = {Springer},
year = 1995
}


@article{hans77,
author = "David R. Hanson",
title = "Storage Management for an Implementation of {S}nobol 4",
journal = SPE,
publisher = Wiley,
volume = 7,
number = 2,
pages = "179--192",
year = "1977",
comments = {variant of Deutsch-Schorr-Waite algorithm for varisized cells.},
}

@article{hans90,
author = "David R. Hanson",
title = "Fast Allocation and Deallocation of Memory Based on Object Lifetimes",
journal = SPE,
publisher = Wiley,
volume = 20,
number = 1,
pages = "5--12",
month = jan,
year = "1990",
abstract = {This paper describes a simple algorithm that is very efficient
when there are only a few object lifetimes.
In terms of instructions executed per byte allocated, the algorithm is almost
half the cost of quick fit and less than twice the cost os stack allocation.
Space for all objects with the same lifetime is allocated from a list of large
arenas, and the entire list is deallocated at once.
An implementation in ANSI C is included}
}

@mastersthesis{hans92,
title = "The Impact of Programming Style on the Performance of {S}cheme Programs",
author = "Lars Thomas Hansen",
school = "University of Oregon",
month = aug,
year = 1992,
comment = "
My M.S. thesis asks this -- and some related -- questions for some smaller
programs (more representative of inner loops than entire applications) for
several types of garbage collectors, generational and not. The basic answer
is that given a generational collector, unless you can guarantee that the
data you're mutating lives in the youngest generation (where mutation is
cheap), consing is likely to be competitive in terms of performance. ",
URL = "ftp://ftp.cs.uoregon.edu/pub/lth"
}

@phdthesis{hans00,
author = "Lars Thomas Hansen",
title = {Older-first garbage collection in practice},
school = {North-eastern University},
month = nov,
year = 2000
}

@inproceedings{hans02,
author = {Lars Thomas Hansen and William D. Clinger},
title = {An Experimental Study of Renewal-Older-First Garbage Collection},
booktitle = {Proceedings of the 2002 {ACM} {SIGPLAN} International Conference on Functional Programming ({ICFP02})},
address = {Pittsburgh, PA},
pages = {247--258},
publisher = ACM,
series = SIGPLAN,
volume = {37(9)},
year = 2002
}

@article{hans69,
author = "Wilfred J. Hansen",
title = "Compact List Representation: Definition, Garbage Collection, and System Implementation",
journal = CACM,
publisher = ACM,
volume = 12,
number = 9,
month = sep,
year = 1969,  
pages = "499--507",
}

@article{harr99,
author = {Timothy Harris},
title = {Early storage reclamation in a tracing garbage collector},
journal = SIGPLAN,
publisher = ACM,
volume = 34,
number = 4,
pages = {46--53},
month = apr,
year = 1999,
URL = {http://www.cl.cam.ac.uk/~tlh20/partitioned-gc.ps.gz},
abstract = {This article presents a technique for allowing the early
recovery of storage space occupied by garbage data.  The 
idea is similar to that of generational garbage collection,
except that the heap is partitioned based on a static analysis
of data type definitions rather than on the approximate
age of allocated objects.  A prototype implementation is
presented, along with initial results and ideas for
future work.}
}

@inproceedings{harr00,
author = {Timothy Harris},
title = {Dynamic Adaptive Pre-Tenuring},
crossref = {ISMM2000},
abstract = {
In a generational garbage collector, a pre-tenured object is one that is
allocated directly in the old generation. Pre-tenuring long-lived objects can
reduce the number of times that they are scanned or copied during garbage
collection. Previous work has investigated pre-tenuring based on off-line
analysis of execution traces. In contrast, this paper presents a dynamic
technique in which the decision to pre-tenure a particular kind of object is
taken at run-time. This allows decisions to depend on the inputs of a
particular application run and also allows decisions to be changed as the
application enters different phases. An implementation is presented for the
Java Virtual Machine. 
}
}

@techreport{harr98,
title = {Applet Lifecycle in {N}etscape {C}ommunicator},
author = {Warren Harris},
institution = {Netscape Communications Corporation},
number = {TN-JAVA-05-9707 },
URL = {http://developer.netscape.com:80/docs/technote/java/appletlife.html},
year = 1998
}

@misc{harr98a,
title = {The Design and Implementation of the {S}port {M}odel Garbage Collector},
author = {Warren Harris},
institution = {Netscape Communications Corporation},
month = jan # "19",
year = 1998,
howpublished = "incomplete draft"
}


@article{harl87,
title = "{OBJEKT} --- A Persistent Object Store with an Integrated Garbage 
Collector",
author = "David M. Harland and Brune Beloff",
pages = "70--79",
journal = SIGPLAN,
publisher = ACM,
year = 1987,
volume = 22,
number = 4
}

@techreport{harm89,
author = "Harms, Douglas E.",
title = "Efficient Initialization and Finalization of Data Structures: Why and How",
institution = "Ohio State University, Computer and Information Science Research Center",
year = 1989,
number = "OSU-CISRC-3/89-TR11",
month = feb
}

@inproceedings{hart64,
author = "Timothy P. Hart and Thomas G. Evans",
title = "Notes on Implementing {LISP} for the {M--460} Computer",
pages = "191--203",
crossref = "berk64",
comment = "Uses a two pointer compactifying algorithm."
}


@phdthesis{hart88,
author = "Pieter H. Hartel",
title = "Performance Analysis of Storage Management in Combinator Graph 
Reduction",
school = "Department of Computer Systems, University of Amsterdam", 
address = "Amsterdam",
year = "1988",
abstract = {Fixed-set combinators slower because of the placeholders required to 
transport arguments rather than small grain size.
Cycles in Turner combinator machines are caused more by recursive function 
definitions than by cyclic data structures.
Fewer than 10 percent nodes shared (average RC = 1.2) }
}


@article{hart90,
title = "A Comparison Of 3 Garbage Collection Algorithms",
author = "Pieter H. Hartel",
address = "University of Amsterdam, Department of Computer Systems, Netherlands",
journal = "Structured Programming",
year = 1990,
volume = 11,
number = 3,
pages = "117--127",
abstract = {Compares RC, MS and Copying. Claims it is unnecessary to reclaim cycles as few
are cyclic data structures, most are recursive definitions (Turner m/c).
RC best for snug fit (store = =number of objects), all 3 the same for 2*size,
MS slightly faster than copying, more store doesn't necessarily improve
matters.  Not terribly interesting }
}

@inproceedings{hart94,
author = {Pieter H. Hartel and Marc Feeley and Martin Alt and 
	  Lennart Augustsson and Peter Baumann and Marcel Beemster and
	  Emmanuel Chailloux and Christine H. Flood and Wolfgang Grieskamp and
	  John H. G. van Groningen and Kevin Hammond and Bogumi\l Hausman and
	  Melody Y. Ivory and Peter Lee and Xavier Leroy and
	  Sandra Loosemore and Niklas R\"{o}jemo and Manuel Serrano and
	  Jean-Pierre Talpin and Jon Thackray and Pierre Weis and
	  Peter Wentworth},
title = "Pseudoknot: A Float-Intensive Benchmark for Functional Compilers",
booktitle = "6th Implementation of Functional Languages",
editor = "J. R. W. Glauert",
publisher = "School of Information Systems, University of East Anglia, Norwich, UK",
month = Sep,
year = 1994,
pages = "13.1--13.34",
URL = "ftp.fwi.uva.nl:pub/computer-systems/functional/packages/pseudoknot.tar.Z"
}

@article{hart96,
author = {Pieter H. Hartel and Marc Feeley and Martin Alt and 
	  Lennart Augustsson and Peter Baumann and Marcel Beemster and
	  Emmanuel Chailloux and Christine H. Flood and Wolfgang Grieskamp and
	  John H. G. van Groningen and Kevin Hammond and Bogumi\l Hausman and
	  Melody Y. Ivory and Richard Jones and Peter Lee and Xavier Leroy and
	  Rafael Lins and Sandra Loosemore and Niklas R\"{o}jemo and
	  Manuel Serrano and Jean-Pierre Talpin and Jon Thackray and
	  Stephen P. Thomas and Pierre Weis and Peter Wentworth},
title = {Benchmarking Implementations of Functional Languages with `{P}seudoknot',
a Float-Intensive Benchmark},
journal = JFP,
publisher = CUP,
year = 1996,
volume = 6,
number = 4
}

@inproceedings{harv98,
title = {Compiler-Controlled Memory},
author = {T. Harvey and K. Cooper},
crossref = {ASPLOS98}
}

@inproceedings{hast92,
author = "Reed Hastings and Bob Joyce",
title = "Fast Detection of Memory Leaks and Access Errors",
booktitle = "Proceedings of the Winter '92 {USENIX} conference",
publisher = UA,
pages = "125--136",
year = 1992,
URL = "http://www.pureatria.com/products/purify/fast_detection.html",
comment = "Purify leak detector"
}

@manual{hat,
title = "Java Heap Analysis Tool ({HAT})",
key = "HAT",
organization = "Sun Microsystems",
note = {http://java.sun.com/people/billf/heap/},
URL = {http://java.sun.com/people/billf/heap/},
comment = {Tool for reading -Xhprof files}
}

@article{hatt87, 
title = "{AI} Machine",
author = "A. Hattori and H. Masuzawa and H. Hayashi",
journal = "Fujitsu Scientific and Technical Journal",
volume = 23,
number = 4,
pages = "369--378",
year = 1987,
abstract = {The paper describes the system configuration of the FACOM alpha
Lisp machine and compares the FACOM alpha architecture with that of a 
general-purpose computer.  It also covers CPU performance and the interaction 
between the garbage collector and the virtual memory system.  The paper also 
describes a parallel AI machine developed to operate according to a new parallel
inference method called KABU-WAKE.  The important features of this method and a
performance evaluation of the experimental machine are presented.  Tests
indicate that, for large problems, it is possible to obtain a level of
performance proportional to the number of processor elements used.}
}

@mastersthesis{haug99,
author = {Scott Haug},
title = {Automatic Storage Optimization via Garbage Collection},
school = {Washington University, St Louis},
year = 1999
}

@techreport{have97,
author = {Klaus Havelund and N. Shankar},
title = {A Mechanized Refinement Proof for a Garbage Collector},
institution = {Aalborg University},
year = 1997,
note = {Submitted to Formal Aspects of Computing},
URL = {http://ic-www.arc.nasa.gov/ic/projects/amphion/people/havelund/Publications/gc-refine-report.ps}
}

@inproceedings{have99,
author = {Klaus Havelund},
title = {Mechanical Verification of a Garbage Collector},
booktitle = {FMPPTA'99},
year = 1999,
URL = {http://ic-www.arc.nasa.gov/ic/projects/amphion/people/havelund/Publications/gc-fmppta99.ps}
}
@techreport{haya,
author = "H. Hayashi and A. Hattori and H. Akimoto",
title = "{ALPHA}: High-Performance {L}isp Machine equipped with a New Stack 
Structure and Real-Time Garbage Collection System",
institution = "Fujitsu Laboratories",
type = "Draft report",
comment = "cited by Moon84"
}


@inproceedings{haye90,
author = "Barry Hayes",
title = "Open Systems Require Conservative Garbage Collectors",
crossref = "OOPSLA90-gc",
}


@inproceedings{haye91,
author = "Barry Hayes",
title = "Using Key Object Opportunism to Collect Old Objects",
crossref  = "OOPSLA91",
pages = {33--46},
comment = "Objects may tend to survive or die in groups in memory."
}


@inproceedings{haye92,
title = "Finalization of the Collector Interface",
author = "Barry Hayes",
address = "Stanford University, USA",
crossref = "IWMM92",
}

@phdthesis{haye93,
author = "Barry Hayes",
title = "Key Objects in Garbage Collection",
school = "Stanford University",
month = mar,
year = 1993
}

@inproceedings{haye97,
title = {Ephemerons: A New Finalization Mechanism},
author = "Barry Hayes",
pages = {176--183},
crossref = {OOPSLA97}
}

@inproceedings{heck92,
title = "An Implementation of an Applicative File System",
author = "Brian C. Heck and David S. Wise",
address = "Indiana University, USA",
crossref = "IWMM92",
pages = {248--263}
}


@phdthesis{hede88,
title = "Compile-time Garbage Collection Using Reference Count Analysis",
author = "Lucy Hederman",
school = "Rice University",
month = Aug,
year = 1988,
note = "Also Rice University Technical Report TR88--75 but,
according to Rice University's technical report list, this report is no longer
available for distribution",
abstract = "Storage management overhead accounts for a 
considerable proportion of execution time in straightforward 
implementations of languages with dynamic storage allocation.  
Our approach to reducing this overhead is to shift some of the 
work to compile time.  With static reference count analysis, we 
determine when an object becomes inaccessible, and insert 
explicit deallocation code into the program at those points.  
This will reduce the frequency and number of garbage collections 
at run time.  We discuss previous approaches to storage analysis 
and show that reference count analysis can allow more precise 
modeling of storage accessibility that other approaces.
The analysis is extended to the interprocedural case.  It is 
formulated as a set of path problems on a specially designed 
summary graph.  The effectiveness of our implemented optimization 
on a variety of programs is presented.",
}


@mastersthesis{hede88a,
title = "Compile Time Garbage Collection",
author = "Lucy Hederman",
school = "Rice University",
address = "Houston, Texas",
year = 1988
}

@techreport{heeb91,
author = "Beat Heeb and Cuno Pfister",
title = "Oberon Technical Notes: An Integrated Heap Allocator/Garbage Collector",
pages = "30--39",
month = mar,
URL = "ftp://neptune.inf.ethz.ch/doc/tech-reports/1991/156.ps.Z",
year = 1991,
type = "ETH Technical Report",
number = 156,
institution = {ETH Eidgen\"{o}ssische Technische Hochschule Z\"{u}rich}
}

@inproceedings{heil00,
author = {Timothy Heil and James  E. Smith},
title = {Concurrent Garbage Collection using Hardware Assisted Profiling},
crossref = {ISMM2000},
abstract = {
Virtual machines (VMs) execute programs coded in one instruction set
architecture (ISA), the virtual ISA (V-ISA), on hardware directly
supporting another implementation ISA (I-ISA). Co-designed VMs are
designed together with the underlying hardware to provide high
performance in a general-purpose environment. The I-ISA and
micro-architecture evolve together with the VM to aid those tasks the VM
must perform. Conversely, the VM is designed to improve processor
performance through dynamic recompilation, instruction hint bits, and
pipeline tuning. Unlike the single-threaded execution common today, VMs
have the potential to provide many service threads of execution. VM tasks
such as profile collection and analysis, dynamic optimization, and garbage
collection are conceptually parallel to program execution. Instead of
stopping the application to perform these tasks, service threads execute
these tasks concurrently. Hardware assisted profiling, in addition to playing
an important role in dynamic optimization, provides the communication
mechanism that holds the system together. A robust profiling mechanism
enables VM service threads to remotely monitor application execution
without impacting application performance. The Relational Profiling
Architecture (RPA) was designed from the top down to serve this purpose.
RPA is analogous to a relational database. Instructions selected for profiling
produce a record of information. A simple query engine examines these
records for patterns, and performs simple actions on matching records. The
power and flexibility of RPA is demonstrated by developing a concurrent
generational garbage collector for Java. Detailed execution driven
simulations show that this collector has an average runtime overhead of
0.6\%. The short pauses in the application required for synchronization with
the GC are typically less than 0.1ms, given a 1GHz clock frequency. 
}
}

@inproceedings{hein01,
author = {Nevin Heintze and Olivier Tardieu},
title = {Demand-Driven Pointer Analysis},
crossref = {PLDI01}
}

@inproceedings{hein01a,
author = {Nevin Heintze and Olivier Tardieu},
title = {Ultra-fast Aliasing Analysis  using {CLA}: A Million Lines of {C} Code in a Second},
crossref = {PLDI01}
}

@inproceedings{hend95,
author = "Fergus Henderson and Thomas Conway and Zoltan Somogyi",
title = "Compiling logic programs to {C} using {GNU} {C} as a portable assembler",
booktitle = "{ILPS'95} Postconference Workshop on Sequential Implementation Technologies for Logic Programming",
address = "Portland, Or",
pages = "1--15", 
URL = "http://www.cs.mu.oz.au/mercury/papers/mercury_to_c.ps.gz",
year = 1995
}

@inproceedings{hend02,
title = {Accurate Garbage Collection in an Uncooperative Environment},
author = {Fergus Henderson},
crossref = {ISMM02},
pages = {150--156}
}

@phdthesis{hend90,
author = "Laurie J. Hendren",
title = "Parallelizing Programs with Recursive Data Structures",
year = 1990,
month = apr,
comment = "Not about memory allocation per se, but the analysis is
useful for that application",
school = CORNELL
}

@mastersthesis{heng88,
author = "Seng-Lai Heng",
title = "Performance Evaluation of Numerous Garbage Collections by Real-Time Simulation",
school = "University of Texasat Austin",
year = 1988
}

@inproceedings{henn93,
author = "Wade Hennessey",
title = "Real-Time Garbage Collection in a Multimedia Programming Language",
crossref = "OOPSLA93-gc",
}

@book{henn96,
author = "John L. Hennessy and David A. Patterson",
title = "Computer Architecture: A Quantitative Approach",
publisher = "Morgan Kaufman",
edition = "Second",
year = 1996
}

@article{henni98,
title = {Binding, Migration and Scalability in {CORBA}},
author = {Michi Henning},
journal = CACM,
number = 10,
volume = 41,
month = oct,
year = 1998,
pages = {62--71},
comment = {Brief account of some of the issues facing GC in CORBA}
}

@inproceedings{henr94,
author = "Roger Henriksson",
title = "Scheduling Real-Time Garbage Collection",
booktitle = "Proceedings of NWPER'94",
address = "Lund, Sweden",
year = 1994,
URL = "http://www.dna.lth.se/Research/ProgEnv/Papers/LU-CS-TR:94-129.ps"
}

@mastersthesis{henr96,
author = "Roger Henriksson",
title = "Scheduling Real-Time Garbage Collection",
school = "Department of Computer Science, Lund University",
year = 1996,
type = "Licentiate thesis",
URL = "http://www.dna.lth.se/Research/ProgEnv/Abstracts/Thesis.RH.abs.html",
note = "Lund technical report LU-CS-TR:96-161"
}

@techreport{henr96a,
author = "Roger Henriksson",
title = "Adaptive Scheduling of Incremental Copying Garbage Collection for Interactive Applications",
institution = Lund,
number = "96--174",
URL="ftp://mjolner.dna.lth.se/HD/ftp/pub/papers/LU-CS-TR.96-174.ps",
year = 1996
}

@inproceedings{henr97,
author = {Roger Henriksson},
title = {Predictable Automatic Memory Management for Embedded Systems},
URL = {ftp://ftp.dcs.gla.ac.uk/pub/drastic/gc/henriksson.ps},
crossref = {OOPSLA97-gc}
}

@phdthesis{henr98,
author = {Roger Henriksson},
title = {Scheduling  Garbage Collection in Embedded Systems},
school = {Lund Institute of Technology},
month = jul,
year = 1998,
URL = {http://www.dna.lth.se/home/Roger_Henriksson/}
}

@techreport{herl90,
author = "Herlihy, Maurice and Moss, J. Eliot B",
title = "Non-Blocking Garbage Collection for Multiprocessors",
institution = "DEC Cambridge Research Laboratory",
number = "CRL 90/9",
year = 1990
}

@article{herl92,
author = "Herlihy, Maurice and Moss, J. Eliot B",
title = "Lock-Free Garbage Collection for Multiprocessors",
journal = "IEEE Transactions on Parallel and Distributed Systems",
publisher = IEEE,
volume = 3,
number = 3,
month = may,
year = 1992
}

@inproceedings{hert02,
title = {Error-Free Garbage Collection Traces: How to Cheat and Not Get Caught},
author = {Matthew Hertz and Steve M. Blackburn and K. S. McKinley and J. Eliot B. Moss and Darko Stefanovic},
booktitle = {Proceedings of the International Conference on Measurements and Modeling of Computer Systems},
address = {Marina Del Rey, CA},
month = jun,
year = 2002,
URL = {ftp://ftp.cs.umass.edu/pub/osl/papers/sigmetrics-2002-merlin.ps.gz}
}

@article{hess01,
author = {Wim H. Hesselink and  Jan Friso Groote},
title = {Wait-Free Concurrent Memory Management by Create and Read until Deletion ({CaRuD})},
journal = {Distributed Computing},
volume = 14,
number = 1,
pages = {31--39},
year = 2001
}

@article{hewi77,
author = "Carl Hewitt",
title = "Viewing Control Structures as Patterns of Passing Messages",
journal = "Journal of Artificial Intelligence", 
volume = 8,
number = 3,
pages = "323--364",
month = Jun,
year = 1977
}


@article{heym91, 
title = "A Comprehensive Analytical Model for Garbage Collection Algorithms",
author = "J. Heymann",
journal = Sigplan,
publisher = ACM,
year = 1991,
volume = 26,
number = 8,
pages = "50--59"
}

@inproceedings{hibi80,
author = "Y. Hibino",
title = "A Practical Parallel Garbage Collection Algorithm and its 
Implementation",
booktitle = "7th Annual Symposium on Computer Architecture",
pages = "113--120",
year = 1980,
month = may
}


@article{hick84,
title = "Performance Analysis of On-The-Fly Garbage Collection",
author = "Tim Hickey and Jacques Cohen",
journal = CACM,
publisher = ACM,
year = 1984,
month = nov,
volume = 27,
number = 11,
pages = "1143--1154",
comment = "Comparision of Dijkstra, Kung \& Song and classical mark-scan.
Upper limit on speedup was 150 percent."
}

@inproceedings{hick93,
title = "Experiences with Compiler-Directed Storage Reclamation", 
author = "James Hicks", 
address = "Motorola Cambridge Research Center",
crossref = "FPCA93",
}

@inproceedings{hick97,
title = {The Measured Cost of Copying Garbage Collection Mechanisms},
author = {Michael W. Hicks and Jonathan T. Moore and Scott M. Nettles},
pages = {292--305},
crossref = {ICFP97},
URL = {http://www.cis.upenn.edu/~oscar/icfp97.ps}
}

@inproceedings{hick98,
author = {Michael Hicks and Luke Hornof and Jonathan T. Moore and Scott Nettles },
title = {A Study of {L}arge {O}bject {S}paces},
pages = {138--145},
crossref = {ISMM98},
URL = {http://www.cis.upenn.edu/~oscar/ismm98.ps},
abstract = {Using a separate non-copy collected space for large objects
can result in significant performance improvements for copying garbage
collectors. Such collectors are a specific instance of a broad class of
collectors that mix copying and non-copying collection. Unfortunately
the published literature provides limited guidance about how to design
a large object space (LOS).
This paper surveys the LOS design space, and identifies a wide variety
of issues that might affect its design. It then places the literature
into this framework.
The main contribution of the paper is an examination of some LOS design
issues using the Oscar GC testbed. For this work, we have extended
Oscar to support a number of possible LOS designs. Our experiments are
run on benchmark heap snapshots, with varying policies for selecting
``large'' objects, as well as varying the non-copying GC technique used
for collecting them.
Our selection policies include varying size thresholds, as well as
whether or not the large objects may contain pointers. We also compare
a treadmill collector with a mark-and-sweep collector for the large
object space. Our benchmark heaps include those taken from instrumented
SML/NJ and JDK runtimes, and are run on Pentium II-based Linux
platforms.
Our initial experimental results indicate that in fact, there is a
tradeoff point for the hybrid collectors.  At least in some cases, as
the ``large'' objects become smaller, the benefits of avoiding copies
become unimportant. These findings are not substantially changed by
allowing pointer-containing large objects, although the tradeoff point
shifts, and our results suggest that pointer-full objects should be
included in the LOS. Our result are not sensitive to the collection
technique used for the LOS. }
}


@inproceedings{hick04a,
title = {Experience with Safe Manual Memory-Management in {C}yclone}, 
author = {Michael Hicks and Greg Morrisett and Dan Grossman and Trevor Jim},
crossref = {ISMM04}
}


@article{hieb90,
title = "Representing Control in the Presence of First-Class Continuations",
author = "R. Hieb and R. K. Dybvig and C. Bruggeman",
journal = SIGPLAN,
publisher = ACM,
volume = 25,
number = 6,
pages = "66--77",
year = 1990
}

@phdthesis{hiep91,
author = {Van Nguyen Hiep},
title = {Compilation et Environment d'Execution d'un Langage \`{a} Base d'Objects},
school = {Institut National Polytechnique de Grenoble},
month = feb,
year = 1991
}

@article{higu02,
author = {Teresa Higuera and Valerie Issarny and Michel Banatre and Gilbert Cabillic and Jean-Philippe Lesot and Frederic Parain},
title = {Memory Management for Real-Time {J}ava: an Efficient Solution using Hardware Support},
journal = {Real-Time Systems Journal},
year = 2002,
URL = {http://www-rocq.inria.fr/arles/doc/doc.html}
}

@phdthesis{hill87,
author = "Mark D. Hill",
title = "Aspects of Cache Memory and Instruction Buffer Performance",
school = UCB,
month = nov,
year = 1987,
note = "Also UCB/CSD Technical report 87/381"
}

@article{hill88,
author = "Hill, Mark D.",
title = "A Case for Direct-Mapped Caches",
journal = "IEEE Computer",
publisher = IEEE,
volume = 21,
number = 12,
month = Dec,
year = 1988,
pages = "25--40"       
}


@article{hill89,
author = "Hill, Mark D. and Alan Jay Smith",
title = "Evaluating Associativity in {CPU} Caches",
journal = IEEETransComp,
publisher = IEEE,
volume = 38,
number = 12,
month = Dec,
year = 1989,
pages = "1612--1629" 
}

@article{hind75,
author = "J. A. Hinds",
title = "An Algorithm for Locating Adjacent Storage Blocks in the Buddy System",
journal = CACM,
volume = 18,
number = 4,
year = 1975,
publisher = ACM,
month = apr,
pages = "221--222"
}

@inproceedings{hind01,
title = {Pointer Analysis: Haven't We Solved This Problem Yet?},
author = {Michael Hind},
booktitle = {2001 ACM SIGPLAN-SIGSOFT Workshop on Program Analysis for Software Tools and Engineering (PASTE'01)},
address = {Snowbird, UT},
month = jun,
year = 2001,
URL = {http://www.research.ibm.com/people/h/hind/paste01.ps},
abstract = {During the past twenty-one years, over seventy-five papers
and nine Ph.D. theses have been published on pointer analysis. Given
the tomes of work on this topic one may wonder, ``Haven't we solved
this problem yet?'' With input from many researchers in the field, this
paper describes issues related to pointer analysis and remaining open
problems.}
}

@article{hirs73,
author = "D. S. Hirschberg",
title = "A Class of Dynamic Memory Allocation Algorithms",
journal = CACM,
publisher = ACM,
month = oct,
year = 1973,
volume = 16,
number = 10,
pages = "615--618"
}

@inproceedings{hirz00,
author = {Martin Hirzel and Amer Diwan},
title = {On the Type Accuracy of Garbage Collection},
crossref = {ISMM2000},
abstract = {
We describe a novel approach to obtaining type-accurate information for
garbage collection in a hardware and language independent way. Our
approach uses a run-time analysis to propagate pointer/non-pointer
information from significant type events (such as allocation, which
always returns a pointer). We use this technique to perform a detailed
comparison of garbage collectors with different levels of accuracy and
explicit deallocation on a range of C programs. We take advantage of
the portability of our approach to conduct our experiments on three
hardware platforms, Alpha/Digital UNIX 4.0D, Pentium/Linux 2.2, and
SPARC/Solaris 2. We find that the choice of hardware platform (which
includes the architecture, operating system, and libraries) greatly
affects whether or not type-accuracy enhances a garbage collector's
ability to reclaim objects.  }
}

@mastersthesis{hirz00a,
author = {Martin Hirzel},
title = {Effectiveness of Garbage COllection and Explicit Deallocation},
school = {University of Colorado},
year = 2000,
URL = {http://csel.cs.colorado.edu/~hirzel/papers/index.htm}
}

@inproceedings{hirz01,
author = {Martin Hirzel and Amer Diwan and Tony Hosking},
title = {On the Usefulness of Liveness for Garbage Collection and Leak Detection},
crossref = {ECOOP01}
}

@inproceedings{hirz02,
title = {Understanding the Connectivity of Heap Objects},
author = {Martin Hirzel and Johannes Henkel and Amer Diwan and Michael Hind},
crossref = {ISMM02},
pages = {36--49}
}

@article{hirz02a,
title = {On the Usefulness of Type and Liveness for Garbage Collection and Leak Detection},
author = {Martin Hirzel and Amer Diwan and Johannes Henkel},
journal = TOPLAS,
publisher = ACM,
volume = 24,
number = 6,
month = nov,
year = 2002,
pages = {593--624}
}

@inproceedings{hirz03,
title = {Connectivity-based Garbage Collection}, 
author = {Martin Hirzel and Amer Diwan and Matthew Hertz},
crossref = {OOPSLA03}
}

@article{hoar69,
author = "C. A. R. Hoare",
title = "An Axiomatic Basis for Computer Programming",
journal = CACM,
volume = 12,
publisher = ACM,
month = oct,
year = 1969
}

@article{hoar74,
author = "C. A. R. Hoare",
title = "Optimisation of Store Size for Garbage Collection",
journal = IPL,
publisher = NH,
volume = 2,
number = 6,
month = Apr,
year = 1974,
pages = "165--166",
}

@inproceedings{hofm03,
title = {Static Prediction of Heap Usage for First-Order Functional Programs},
author = {Martin Hofman and Steffen Jost},
crossref = {POPL03}
}

@techreport{hoge93,
author = "Hogen, Guido and Loogen, Rita",
title = "A New Stack Technique for the Management of Runtime Structures in Distributed Implementations",
institution = "{RWTH} {A}achen",
year = 1993,
address = "{A}hornstr. 55, 52056 {A}achen, {G}ermany",
URL = "file://ftp.informatik.rwth-aachen.de/pub/reports/1993/93-03.ps.gz",
number = "93-3",
type = "{A}achener {I}nformatik-{B}erichte"
}

@inproceedings{hoge94,
author = "Hogen, Guido and Loogen, Rita",
title = "Efficient Organization of Control Structures in Distributed Implementations",
year = 1994,
URL = "ftp://ftp.informatik.rwth-aachen.de/pub/reports/others/cc94.ps.gz",
editor = "Fritzson, Peter A.",
pages = "98--112",
publisher = SV,
series = LNCS,
volume =  786,
booktitle = "Compiler Construction"
}

@techreport{hoge94a,
author = "Hogen, Guido and Loogen, Rita",
institution = "{RWTH} {A}achen",
title = "Parallel Functional Implementations: Graphbased vs. Stackbased Reductions",
year = 1994,
address = "ghogen@zesu.informatik.rwth-aachen.de, lllgen@informatik.uni-marburg.de"
}

@techreport{holl80,
author = "Jack Holloway and Guy L. Steele and Gerald Jay Sussman and Alan Bell",
title = "The {SCHEME}--79 Chip",
institution = "MIT AI Laboratory",
type = "AI Memo",
number = 559,
month = jan,
year = 1980,
comment = "Danvy says 80 per cent of time spent in GC."
}

@inproceedings{holm83,
title = "A Simple and Efficient Way to Handle Large Datastructures in Applicative Languages",
author = {S. Holmstr\"{o}m},
booktitle = "Joint {SERC}/{C}halmers Workshop on Declarative Programming, {U}niversity {C}ollege, {L}ondon",
year = 1983
}

@article{holt61,
author = "Anatol W. Holt",
title = "Program Organization and Record Keeping for Dynamic Storage Allocaton",
journal = CACM,
publisher = ACM,
volume = 4,
number = 10,
month = oct,
year = 1961
}

@inproceedings{holz91,
author = {Urs H\"{o}lzle},
title = "The Myth of High Object Creation Rates",
crossref = "OOPSLA91-gc",
}

%also available from http://www.cs.ucsb.edu/oocsb/papers/write-barrier.html
@inproceedings{holz93,
author = {Urs H\"{o}lzle},
title = "A Fast Write Barrier for Generational Garbage Collectors",
crossref = "OOPSLA93-gc",
URL = "ftp://self.stanford.edu/pub/papers/write-barrier.ps.Z"
}

@inproceedings{holz95,
author = {Urs H\"{o}lzle and David Ungar},
title = "Do Object-Oriented Languages Need Special Hardware Support?",
crossref = "ECOOP95",
}

@book{horo77,
author = "E. Horowitz and  S. Sahni",
title = "Fundamentals of Data Structures",
publisher = "Computer Science Press",
address = "Woodland Hills, CA", 
year = 1977,
comments = {book with sections on garbage collection},
}


@article{hors87,
title = "Analysis and Development of Demand Prepaging Policies",
author = "R. Nigel Horspool and Ronald M. Huberman",
journal = "Journal of Systems and Software",
year = 1987,
volume = 7,
pages = "183-194" 
}


@inproceedings{horw89,
author = "S. Horwitz and P. Pfeiffer and T. Reps",
title = "Dependence Analysis for Pointer Variables",
crossref = "PLDI89",
pages = "28--40",
}


@inproceedings{hosk91,
author = "Anthony L. Hosking",
title = "Main Memory Management for Persistence",
crossref = "OOPSLA91-gc",
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/GC91/hosking.ps"
}


@inproceedings{hosk92,
author = {Anthony L. Hosking and J. Eliot B. Moss and Darko Stefanovi\'{c}},
title = "A Comparative Performance Evaluation of Write Barrier Implementations",
crossref = "OOPSLA92",
pages = "92--109",
URL = "ftp://ftp.cs.umass.edu/pub/osl/papers/oopsla92.ps.Z"
}

@inproceedings{hosk93,
author = "Antony L. Hosking and Richard L. Hudson",
title = "Remembered Sets Can Also Play Cards",
crossref = "OOPSLA93-gc",
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/GC93/hosking.ps"
}

@inproceedings{hosk93a,
title = "Object Fault Handling for Persistent Programming Languages: A Performance Evaluation",
author = "Anthony L. Hosking and J. Eliot B. Moss",
crossref = "OOPSLA93",
URL = {ftp://ftp.cs.umass.edu/pub/osl/papers/oopsla93.ps.Z}
}

@inproceedings{hosk93b,
title = "Protection Traps and Alternatives for Memory Management of an Object-Oriented Language",
author = "Antony L. Hosking and J. Eliot B. Moss",
crossref = "SOSP93",
pages = {106--119},
URL = {ftp://ftp.cs.umass.edu/pub/osl/papers/sosp93.ps.Z}
}

@techreport{hosk95,
title = {Lightweight write detection and checkpointing for fine-grained persistence},
author = {Antony L. Hosking and J. Eliot B. Moss},
institution = {Purdue University},
number = {95-084},
year = 1995,
UTL = {ftp://ftp.cs.purdue.edu/pub/hosking/papers/tods.ps.gz}
}

@inproceedings{hosk97,
author = {Antony L. Hosking and Aria P. Novianto},
title = {Reachability-based Orthogonal Persistence for {C}, {C++} and Other Intransigents},
URL = {ftp://ftp.dcs.gla.ac.uk/pub/drastic/gc/hoskings.ps},
crossref = {OOPSLA97-gc}
}

@inproceedings{hosk98,
title = {Optimizing the Read and Write Barrier for Orthogonal Persistence},
author = {Antony L. Hosking and Nathaniel Nystrom and Quintin Cutts and Kumar Brahnmath},
crossref = {IWPOS98},
URL = {ftp://ftp.cs.purdue.edu/pub/hosking/papers/pos98.ps.gz}
}

@inproceedings{hosk99,
title = {Mostly-Copying Reachability-Based Orthogonal Persistence},
author = {Antony L. Hosking and Jiawan Chen},
crossref = {OOPSLA99},
pages = {382--398},
comment = {Reachability-based orthogonal persistent system outperforms C++ one}
}


@inproceedings{hoso98,
author = {Haruo Hosoya and Akinori Yonezawa},
title = {Garbage Collection via Dynamic Type Inference --- A Formal Treatment},
booktitle = {Proceedings of the Second Workshop on Types in Compilation},
URL = {ftp://ftp.yl.is.s.u-tokyo.ac.jp/pub/papers/tigc98.ps.gz},
year = 1998,
pages = {215--239}
}

@misc{hotspot01,
author = {SUN Microsystems},
title = {The {J}ava {H}ot{S}pot {V}irtual {M}achine},
year = 2001,
note = {Technical White Paper}
}

@inproceedings{huan04,
author = {Huang, Xianlong and Blackburn, Stephen M. and McKinley, Kathryn S. and  Moss, J. Eliot B. and Wang, Z. and Cheng, Perry},
title = {The Garbage Collection Advantage: Improving Program Locality},
booktitle = "Proceeding of the {ACM} Conference on Object-Oriented Systems, Languages and Applications",
address = {Vancouver, BC, Canada},
month = oct,
year = 2004,
URL = {http://cs.anu.edu.au/~Steve.Blackburn/pubs/abstracts.html#oor-oopsla-2004},
abstract = {As increases in processor speed continue to outpace increases in
cache and memory speed, programs are losing more performance to poor locality.
Because copying garbage collectors move objects, they have the opportunity to
improve locality for languages such as Java. This paper introduces a new dynamic,
online class analysis for finding and exploiting locality in a copying collector.
The analysis exploits method sampling in a JIT (just-in-time) optimizing compiler.
For each hot (frequently accessed) method, object reordering analysis marks the
class fields that the method accesses as hot. Then at garbage collection time,
the collector copies referents of hot fields together with their parent.
Enhancements to this basic technique include heuristics that decay heat to respond
to phase changes, group objects of hot classes together in a separate copy space,
and static analysis to exclude cold basic blocks from the reordering analysis. In
experiments with Jikes RVM using MMTk on a range of Java programs, the overhead of
dynamic class reordering is on average negligible and at most 1.9\%. We compare
class reordering with a number of static class oblivious orderings (e.g., breadth
and depth first). The overall time variation between static orderings can be up
to 25\% and there is no consistent winner. In contrast, dynamic class reordering
always matches or improves over the best static ordering since its history-based
copying order tunes memory layout to program traversal.}
}

@techreport{huda81,
author = "Paul R. Hudak",
title = "Call-graph reclamation: an alternative storage reclamation scheme",
type = "{AMPS} Technical Memorandum",
number = 4,
institution = "University of Utah",
month = aug,
year = 1981
}

@inproceedings{huda82,
author = "Paul R. Hudak and R. M. Keller",
title = "Garbage Collection and Task Deletion in Distributed Applicative 
Processing Systems",
crossref = "LFP82",
pages = "168--178",
comment = "Deletes both unwanted objects and garbage tasks in a distributed
applicative system. Processing can continue during marking.",
}


@phdthesis{huda82a,
title = "Object and Task Reclamation in Distributed Applicative Processing Systems",
author = "Paul R. Hudak",
school = "University of Utah",
address = "Salt Lake City, Utah",
year = 1982
}


@techreport{huda83,
author = "Paul R. Hudak",
title = "Distributed Graph Marking",
institution = "University of Yale",
type = "Departmental Research Report",
number = 268,
year = 1983
}


@inproceedings{huda83a,
author = "Paul R. Hudak",
title = "Distributed Task and Memory Management",
booktitle = "ACM Symposioum on the Principles of Distributed Computing",
publisher = ACM,
month = aug,
year = 1983,
pages = "277--89"
}


@inproceedings{huda84,
author = "Paul Hudak and Adrienne Bloss",
title = "The Aggregate Update Problem in Functional Programming Systems",
year = 1985,
pages = "300--314",
crossref = "POPL84",
}


@inproceedings{huda86,
author = "Paul R. Hudak",
title = "A Semantic Model of Reference Counting and its Abstraction (detailed summary)",
crossref = "LFP86",
pages = "351--363",
abstract = {Compile-time garbage collection}
}

@incollection{huda87,
author = "Paul R. Hudak",
title = "A Semantic Model of Reference Counting and its Abstraction",
booktitle = "Abstract Interpretation of Declarative Languages",
editor = "Samson Abramsky and Chris Hankin",
publisher = "Ellis Horward",
pages = "45--62",
year = 1987,
abstract = "Compile-time garbage collection"
}

@article{huda92,
author = "Paul Hudak and Peyton Jones, Simon L. and Phillip Wadler",
title = "Report on the Programming Language {H}askell, a Non-strict Purely Functional Language (Version 1.2)",
journal = SIGPLAN,
publisher = ACM,
volume = 27, 
number=5,
month = may,
year = 1992
}

@inproceedings{huds90,
author = "Richard L. Hudson and Amer Diwan",
title = "Adaptive Garbage Collection for {M}odula-3 and {S}malltalk",
crossref = "OOPSLA90-gc",
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/GC90/Hudson.ps.Z"
}



@techreport{huds91,
title = "A Language-Independent Garbage Collector Toolkit",
author = "Hudson, Richard L. and J. Eliot B. Moss and Amer Diwan and Christopher F. Weight",
institution = "University of Massachusetts at Amherst, Department  of Computer and Information Science",
year = 1991,     
number = "COINS 91-47",
month = sep,
URL = {ftp://ftp.cs.umass.edu/pub/osl/papers/tr9147.ps.Z},
abstract = "We describe a memory management toolkit for language 
implementors.  It offers efficient and flexible generation 
scavenging garbage collection.  In addition to providing a core 
of language-independent algorithms and data structures, the 
toolkit includes auxiliary components that ease implementation of 
garbage collection for programming languages.  We have detailed 
designs for Smalltalk and Modula-3 and are confident the toolkit 
can be used with a wide variety of languages.  The toolkit 
approach is itself novel, and our design includes a number of 
additional innovations in flexibility, efficiency, accuracy, and 
cooperation between the compiler and the collector."
}

@inproceedings{huds91a,
author = "Richard L. Hudson",
title = "Finalization in a Garbage Collected World",
crossref = "OOPSLA91-gc",
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/GC91/hudson.ps"
}

@inproceedings{huds92,
title = "Incremental Garbage Collection for Mature Objects",
author = "Richard L. Hudson and J. Eliot B. Moss",
address = "University of Massachusetts, USA",
crossref = "IWMM92",
URL = {ftp://ftp.cs.umass.edu/pub/osl/papers/iwmm92.ps.Z},
abstract = "
We present a garbage collection algorithm
that extends generational scavenging to collect large older
generations ({\em mature objects}) non-disruptively.  The algorithm's
approach is to process bounded-size pieces of mature object space at
each collection; the subtleties lie in guaranteeing that it eventually
collects any and all garbage. The algorithm does not assume any
special hardware or operating system support, e.g., for forwarding
pointers or protection traps. The algorithm copies objects, so it
naturally supports compaction and reclustering."
}

@inproceedings{huds97,
title = {Garbage Collecting the World: One Car at a Time},
author = {Richard L. Hudson and Ron Morrison and J. Eliot B. Moss and David S. Munro},
crossref = {OOPSLA97},
URL = {http://www.dcs.st-and.ac.uk/research/publications/download/HMM+97b.pdf}
}

@techreport{huds97a, 
title = {Training Distributed Garbage: The {DMOS} collector},
author = {Richard L. Hudson and Ron Morrison and J. Eliot B. Moss and David S. Munro},
institution = {University of St. Andrews},
URL = {http://www.dcs.st-and.ac.uk/research/publications/download/HMM+97a.pdf},
year = 1997
}

@inproceedings{huds98, 
title = {Where Have All The Pointers Gone?},
author = {Richard L. Hudson and Ron Morrison and J. Eliot B. Moss and David S. Munro},
booktitle = {Proceedings of 21st Australasian Computer Science Conference},
address = {Perth},
pages = {107--119},
URL = {http://www.dcs.st-and.ac.uk/research/publications/download/HMM+98.pdf},
year = 1998
}

@inproceedings{huds00,
author = {Richard L. Hudson and J.  Eliot B. Moss and Sreenivas Subramoney and Weldon Washburn},
title = {Cycles to Recycle: Garbage Collection on the {IA}-64},
crossref = {ISMM2000},
abstract = {
The IA-64, Intel's 64-bit instruction set architecture, exhibits a number of
interesting architectural features. Here we consider those features as they
relate to supporting garbage collection (GC). We aim to assist GC and
compiler implementors by describing how one may exploit features of the
IA-64. Along the way, we record some previously unpublished object
scanning techniques, and offer novel ones for object allocation (suggesting
some simple operating system support that would simplify it) and the Java
"jsr" problem. We also discuss ordering of memory accesses and how the
IA-64 can achieve publication safety efficiently. While our focus is not on
any particular GC implementation or programming language, we draw on
our experience designing and implementing GC for the Intel Java Virtual
Machine for the IA-64. 
}
}

@inproceedings{huds01,
title = {Sapphire: Copying {GC} Without Stopping The World},
author = {Richard L. Hudson and J. Eliot B. Moss},
booktitle = {Joint ACM Java Grande --- ISCOPE 2001 Conference},
address = {Stanford University, CA},
month = jun,
year = 2001,
URL = {ftp://ftp.cs.umass.edu/pub/osl/papers/jgrande-2001.ps.gz}
}

@article{huds92a,
author = "Hudson, S. and Hannah, J. M.",
address = "Roke Manor Research Ltd, Romsey, England",
title = "Structured Knowledge Manipulation System for Real-Time Engineering Applications",
year = 1992,
journal = "IEE Proceedings, Part E: Computers and Digital Techniques",
volume = 139,
number = 1,
month = jan,
pages = "59--63",
abstract = {A structured knowledge manipulation system (SKMS), which
incorporates a relational processing unit based on a
structured knowledge representation, providing real-time
relational accesses of a knowledge base, is described.
Direct hardware support is provided for set operations and
'between bounds' matching. Additionally, 'garbage
collection' is performed concurrently, with no memory
overheads and very little speed penalty. Experimental
results and projected performance figures are presented,
which demonstrate the suitability of the SKMS approach for
realtime applications. (Author abstract)}
}

@inproceedings{huel93,
author = "Lorenz Huelsbergen and James R. Larus",
title = "A Concurrent Copying Garbage Collector for Languages that Distinguish (Im)mutable Data",
crossref = "PPoPP93",
pages = "73--82",
comment = "Replication-based copying."
}

@inproceedings{huel98,
author = {Lorenz Huelsbergen and Phil Winterbottom},
title = {Very Concurrent Mark-\&-Sweep Garbage Collection without Fine-Grain Synchronization},
pages = {166--175},
crossref = {ISMM98},
abstract = {We describe a new incremental algorithm for the concurrent
reclamation of a program's allocated, yet unreachable, data. Our
algorithm is a variant of mark-\&-sweep collection that - unlike prior
designs - runs mutator, marker, and sweeper threads concurrently
without explicit fine-grain synchronization. A global, but infrequent,
synchronization coordinates the per-object coloring marks used by the
three threads; fine-grain synchronization is achieved without locking
via the basic memory consistency guarantees commonly provided by
multiprocessor hardware. We have implemented two versions of this
algorithm (called VCGC): in the Inferno operating system and in the
SML/NJ ML compiler. Measurements, compared to a sequential generational
collector, indicate that VCGC can substantially reduce worst-case pause
latencies as well as reduce overall memory usage. We remark that the
degrees of freedom on the rates of marking and sweeping enable
exploration of a range of resource tradeoffs, but makes ``optimal''
tuning for even a small set of applications difficult. }
}


@techreport{hugh83,
author = "R. John M. Hughes",
title = "Reference Counting with Circular Structures in Virtual Memory 
Applicative Systems",
institution = "Programming Research Group, Oxford",
type = "Internal paper",
year = "1983"
}


@article{hugh82a,
title = "A Semi-Incremental Garbage Collection Algorithm",
author = "R. John M. Hughes",
journal = SPE,
publisher = Wiley,
year = 1982,
month = Nov,
volume = 12,
number = 11,
pages = "1081--1084"
}


@inproceedings{hugh85,
author = "R. John M. Hughes",
title = "A Distributed Garbage Collection Algorithm",
crossref = "FPCA85",
pages = "256--272",
comment = "Uses time-stamps so that each local GC contributes to global GC.
Can take a long time for a GC to complete.
Not real-time.",
}


@techreport{hugh87,
author = "R. John M. Hughes",
title = "Managing Reduction Graphs with Reference Counts",
institution = "University of Glasgow",
type = "Departmental Research Report",
number = "CSC/87/R2",
month = mar,
year = "1987",
comments = {Based on \cite{bobr80}. Suitable for referentially
transparent languages}
}

@phdthesis{hugh91,
author = "Simon Hughes",
title = "Static Analysis of Store Use in Functional Programs",
school = "Imperial College, University of London",
year = 1991
}

@article{hugh92,
author = "Simon Hughes",
title = "Compile-Time Garbage Collection for Higher-Order Functional Languages",
journal = "Journal of Logic and Computation",
note = "Special Issue on Abstract Interpretation",
volume = 2,
number = 4,
pages = "483--509",
month = aug,
year = 1992,
}

@inproceedings{huit90,
author = "S. {Le Huitouze}",
title = "A New Data Structure for Implementing Extensions to {P}rolog",
booktitle = "International Workshop on Programming Languages Implementation 
and Logic Programming",
series = LNCS,
volume = 456,
editor = {P. Deransart and J. Maluszy\'{n}ski},
year = 1990,
comment = "Some variable may be come irreversibly substituted.
Variable shunting.",
}

@inproceedings{hump97,
title = {A Framework for Storage Management Evaluation in Persistent Object Systems},
author = {Thorna O. Humphries and Alexander L. Wolf and Benjamin G. Zorn},
URL = {ftp://ftp.dcs.gla.ac.uk/pub/drastic/gc/zorn.ps},
crossref = {OOPSLA97-gc}
}

@techreport{hump00,
title = {{POSSE} Trace Format, Version 1.0},
author = {Thorna O. Humphries and Artur W. Klauser and Alexander L. Wolf and Benjamin G. Zorn},
number = {CU-CS-897-00},
institution = {University of Colorado, Boulder, CO},
month = jan,
year = 2000
}


@phdthesis{hutc87a,
author = "Norman Hutchinson",
title = "Emerald: An Object-Based Language for Distributed Programming",
school = "University of Washington",
month = Jan,
year = 1987
}

@techreport{hutc87b,
author = "Norman Hutchinson and R. K. Raj and Andrew P. Black and Henry M. Levy and Eric Jul",
title = "The {E}merald Programming Language Report",
number = "87--10--07", 
institution = "University of Washington", 
month = Oct,
year = 1987
}

@inproceedings{ichi90,
author = "Ichisuki, Yuuji and Akinori Yonezawa",
title = "Distributed Garbage Collection Using Group Reference Counting",
crossref = "OOPSLA90-gc",
abstract = "Reference counting schemes are suitable to garbage 
collection on distributed systems because they do not require 
global information to find garbage.  However, reference counting 
schemes have a serious drawback: they cannot reclaim garbage 
which form cyclic structures.  In this paper, we propose an 
extension of the traditional reference counting scheme, group 
reference counting, which alleviates the drawback.  This scheme 
is able to reclaim circularly referenced objects which are 
contained in object groups.  We describe how this scheme can be 
implemented on distributed object-oriented concurrent systems.
The overhead of this scheme does not depend on the number of 
nodes.  Thus this scheme works efficiently on distributed systems 
containing large number [sic] of nodes.",
URL = {ftp://ftp.yl.is.s.u-tokyo.ac.jp/pub/papers/sse89-grc-a4.ps.Z}
}

@techreport{ichi90a,
author = "Ichisuki, Yuuji and Akinori Yonezawa",
title = "Distributed Garbage Collection Using Group Reference Counting",
institution = "University of Tokyo",
number = "90--014",
year = 1990
}

@article{illi62,
author = "J. K. Iliffe and J. G. Jodeit",
title = "A Dynamic Storage Allocation Scheme",
journal = COMPJ,
volume = 5,
number = 3,
month = oct,
year = 1962,
pages = "200--209"
}

@mastersthesis{ilso01,
author = {Peer M{\o}ller Ils{\o}e and Simon Hem Pedersen},
title = {Garbage Collection in a gbeta Virtual Machine with the Train Algorithm},
month = jun,
year = 2001,
school = {Aalborg University}, 
abstract = {In this project a virtual machine, gbvm, with a unique
train algorithm garbage collector is implemented for the programming
language gbeta. The main focus of this thesis is memory management
using the train algorithm and experiments with the implementation.
Firstly, this thesis introduces relevant theories and work including an
introduction to gbeta, a overview of virtual machine architectures, and
descriptions of garbage collection concepts, properties, and
algorithms. Secondly, the design and implementation details of gbvm are
presented Thirdly, experiments investigating the performance of both
parameter but also algorithm changes of the train algorithm are
conducted and discussed. The experimental framework implemented for
this thesis allows for further experiments with gbvm. Finally, it is
concluded that it is difficult to find a fixed general setting, which
is both time and space efficient with all the tested programs.}
}


@techreport{imai90,
author = "Imai, Akira and Hirata, Keiji and Taki, Kazuo",
title = "A Parallel Copying Garbage Collection for KL1 on a Shared Memory Multiprocessor",
institution = "Institute for New Generation Computer Technology",
year = 1990,
type = "ICOT technical memorandum",
number = "TM-0967",
month = Nov,
abstract = "We propose an efficient parallel copying GC which is 
an extension of Baker's sequential algorithm on a shared memory 
multiprocessor."
}


@techreport{imai91,
author = "Imai, Akira and Tick, Evan",
title = "Evaluation of Parallel Copying Garbage Collection on a Shared-Memory Multiprocessor",
institution = "Institute for New Generation Computer Technology",
year = 1991,
type = "ICOT technical report",
number = "TR-650",
month = May,
abstract = "A parallel copying garbage collection algorithm for 
symbolic languages executing on shared-memory multiprocessors is 
proposed. The algorithm is an extension of Baker's sequential 
algorithm with a novel method of heap allocation to prevent 
fragmentation and facilitate load distribution during garbage 
collection.  An implementation of the algorithm within a 
concurrent logic programming system, VPIM, has been evaluated and 
the results, for a wide selection of benchmarks, are analyzed 
here.
We show (1) how much the algorithm reduces the contention for 
critical sections during garbage collection, (2) how well the 
load-balancing strategy works and its expected overheads, and 
(3) the expected speedup achieved by the algorithm."
}

@techreport{imai91a,
author = "Imai, Akira and Tick, Evan",
title = "A Shared-Memory Multiprocess or [sic] Garbage Collector and its Evaluation for Committed-Choice Logic Programs",
institution = "Institute for New Generation Computer Technology",
year = 1991,
type = "ICOT technical report",
number = "TR-653",
month = Jun,
abstract = "A parallel copying garbage collection algorithm for 
symbolic languages executing on shared-memory multiprocessors is 
proposed.  The algorithm is an extension of Baker's sequential 
algorithm with a novel  method of heap allocation to prevent 
fragmentation and facilitate load distribution during garbage 
collection.  An implementation of the algorithm  within a 
concurrent logic programming system, VPIM, has been evaluated and 
the results, for a wide selection of benchmarks, are analyzed 
here.  We show (1) how much the algorithm reduces the contention 
for critical sections during garbage collection, (2) how well the 
load-balancing strategy works and its expected overheads, and (3) 
the expected speedup achieved by the algorithm."
}

@article{inou88,
title = "Analysis of Functional Programs to Detect Run-Time Garbage Cells",
author = "Inoue, Katsuro and Seki, Hiroyuki and Yagi, Hikaru",
pages = "555--578",
journal = TOPLAS,
publisher = ACM,
year = 1988,
month = Oct,
volume = 10,
number = 4,
abstract = {We propose a method for detecting the generation of garbage cells
by analyzing a source text written in a functional programming language which
uses ordinary linked lists to implement list-type values.  For a subexpression
such as F(G(.  .  .  )) in a program where the function values of F and G are
of list type, if a cell c is created during the computation of G and if c does
not appear in a list-type value of F, then c becomes a garbage cell at the 
end of the computation of F. We discuss this problem on the basis of formal
languages derived from the functional program text and show some sufficient
conditions that predict the generation of garbage cells.  Also, we give an
efficient algorithm to detect at compile time the generation of garbage cells
which are linearly linked.  We have implemented these algorithms in an
experimental LISP system.  By executing several sample programs on the system,
we conclude that our method is effective in detecting the generation of 
garbage cells.}
}

@article{inou91,
author = "Katsuro Inoue and K. Torii",
title = "Implementation and Analysis of Compile-Time Garbage Collection",
journal = "New Generation Computing",
volume = 10,
number = 1,
pages = "101--119",
year = 1991
}

@inproceedings{iosi00,
author = {R. Iosif and R. Sisto},
title = {Using Garbage Collection in Model Checking},
booktitle = {Proceedings of 7th International {SPIN} Workshop on Model Checking of Software}, 
series = LNCS,
volume = 1885, 
address = {Stanford, CA}, 
month = sep,
year = 2000, 
pages = {20--33},
URL = {http://www.dai-arc.polito.it/dai-arc/auto/papers/papers190.shtml}
}

@mastersthesis{irel89,
author = "E. Ireland",
title = "Writing Interactive and File-Processing Functional Programs",
school = "Victoria University of Wellington",
year = 1989,
month = mar,
comment = {Generational GC with a "paradoxical area" for all updatable 
objects, scanned at each minor collection. Reportedly unconvincing 
performance} 
}

@mastersthesis{ishi83,
author = "Ishii, Carol Y.",
title = "A Comparative Study of Garbage Collection and Compaction Algorithms",
year = 1983,
school = "Emory University"
}

@article{isod71,
author = "S. Isoda and E. Goto and I. Kimura",
title = {An Efficient Bit Table Technique for Dynamic Storage Allocation of $2^{n}$-Word Blocks},
journal = CACM,
publisher = ACM,
volume = 14,
number = 9,
year = 1971,
month = sep,
pages = "589--592"
}

@inproceedings{ito97,
author = {Takayasu Ito and Toshihiro Asai},
institution = {Tokyo University},
title = {Timed-{GC} for a Real-Time {L}isp System},
booktitle = {Workshop on Languages, Compilers, and Tools for Real-Time Systems (LCT-RTS97)},
publisher = ACM,
series = SIGPLAN,
address = {Las Vegas, Nevada},
month = jun,
year = 1997
}

@phdthesis{iyen92,
author = "Arun Iyengar",
title = "Dynamic Storage Allocation on a Multiprocessor",
school = "MIT Laboratory for Computer Science",
note = "Technical Report MIT/LCS/TR-560",
year = 1992
}

@inproceedings{iyen93,
author = "Arun K. Iyengar",
title = "Parallel Dynamic Storage Allocation Algorithms",
booktitle = "Fifth {IEEE} Symposium on Parallel and Distributed Processing",
publisher = IEEE,
year = 1993
}

@manual{j2ee,
title={{J}ava 2 Platform, Enterprise Edition ({J2EE}), 1.4 Specification},
year=2002,
organization = "Sun Microsystems",
URL = {http://java.sun.com/j2ee/j2ee-1_4-pfd3-spec.pdf},
}


@inproceedings{jack91,
author = "Frank Jackson",
title = "Garbage Collection Bugs That {I} Have Known",
crossref = "OOPSLA91-gc",
}

@inproceedings{jack98,
author = {Paul Jackson},
title = {Verifying a Garbage Collection Algorithm},
booktitle = {Proceedings of 11th International Conference on Theorem Proving in Higher Order Logics TPHOLs'98},
address = {Canberra},
series = LNCS,
volume = 1479,
pages = {225--244},
publisher = SV,
month = sep,
year = 1998
}

@inproceedings{jaco89,
author = "D. Jacobs and A. Langen",
title = "Accurate and Efficient Approximation of Variable Aliasing in Logic Programs",
booktitle = "North American Conference on Logic Programming",
pages = "154--165",
year = 1989
}

@inproceedings{jaga94,
title = "Dali: A High Performance Main Memory Storage Manager",
author = "H. V. Jagadish and Daniel Lieuwen and Rajeev Rastogi and Avi Silbersch
atz",
booktitle = "20th International Conference on Very Large Data Bases",
year = 1994
}

@article{jans86,
title = "Message Passing and Graph Transformations: a Model of {A}ctor 
Computation.",
author = "D. Janssens",
journal = "Microprocessing and Microprogramming",
volume = 18,
number = "1--5",
other = "Twelfth EUROM ICRO Symp on Microprocess and Microprogram, 
Venice, Italy, Sep 15--18 1986",
pages = "307--318",
year = "1986",
abstract = {
Actor systems are a model of massively parallel computation.  In an
actor system a computation is performed by a number of independent active
elements, called actors.  Communication between these actors happens by
asynchronous message passing.  The aim of this paper is to develop a
comprehensive description of actor systems, based on techniques from the 
area of graph grammars.}
}


@phdthesis{jans90,
author = "G. Janssens",
title = "Deriving Run-Time Properties of Logic Programs by Means of Abstract Interpretation",
school = "Katholieke University of Leuven, Belgium",
year = 1990
}

@article{janss92,
author = "G. Janssens and Maurice Bruynooghe",
title = "Deriving Descriptions of Possible Values of Program Variables by Means of Abstract Interpretation",
journal = "Journal of Logic Programming",
month = jul,
number = "2, 3",
pages = "205--258",
volume = 13,
year = 1992
}

@manual{java02,
title={Java 2 Platform, Standard Edition, v 1.4.0: API Specification},
year=2002,
organization = "Sun Microsystems",
URL = {http://java.sun.com/j2se/1.4/docs/api/},
comment="Citation for java.lang.ref.WeakReference, PhantomReference, etc"
}

@Manual{javarmi,
key={Java RMI},
title =        {{J}ava {R}emote {M}ethod {I}nvocation Specification},
organization =  "{Sun Microsystems}",
year =         1996,
number =       "Rev 1.1",
month =        nov
}


@article{jaza81,
title = "Space-Efficient Storage Management in an Attribute Grammar Evaluator",
author = "Medhi Jazayeri and Diane Pozefsky",
pages = "388--404",
journal = toplas,
publisher = ACM,
year = 1981,
month = oct,
volume = 3,
number = 4
}


@article{jeff85,
author = "D. R. Jefferson",
title = "Virtual Time",
journal = toplas,
publisher = ACM,
volume = 7,
number = 3,
month = jul,
year = 1985,
pages = "404--425" 
}


@inproceedings{jeff87,
author = "D. R. Jefferson and others",
title = "Distributed Simulation and the {T}ime {W}arp Operating System",
booktitle = "11th {ACM} Symposium on Operating Systems Principles",
publisher = ACM,
month = nov,
year = 1987     }


@inproceedings{jens90,
author = "Thomas P. Jensen and Torben Mogensen",
title = "A Backwards Analysis for Compile-Time Garbage Collection",
booktitle = "{ESOP'90} 3rd {E}uropean Symposium on Programming, 
{C}openhagen, {D}enmark, {M}ay 1990.  (Lecture Notes in Computer Science, vol. 
432)",
year = 1990,
editor = "Neil D. Jones",
pages = "227--239",
publisher = SV,
abstract = {Compile-time garbage collection}
}


@mastersthesis{jens90a,
author = "Thomas P. Jensen",
title = "Context Analysis of Functional Programs",
school = DIKU,
year = "1990",
month = Jan,
comment = "Contexts are introduced as a means for describing
the use of a data structure. A backwards analysis
for determining contexts is developed and used to
optimise the use of storage in functional programs.",
keywords = "backwards analysis, compile-time garbage collection"
}

@phdthesis{jesc95,
title = "An Architecture for Parallel Symbolic Processing based on Suspending Construction",
author = "Eric R. Jeschke",
school = "Indiana University",
month = apr,
year = 1995,
URL = "ftp://ftp.cs.indiana.edu/",
comment = "GC based on distributed mark-compact"
}

@mastersthesis{jew87,
author = "Jew, Yanni K.",
title = "Distributed Garbage Collection",
year = 1987,
school = "Carleton University, Canada"
}

@manual{jinsight,
key = {Jinsight},
organisation = {IBM Research},
title = {Jinsight},
URL = {http://www.research.ibm.com/jinsight/},
note = {Visualisation tools for {J}ava}
}

@manual{JNI97,
key = {Sun JNI, 1997},
organisation = {JavaSoft},
title = {Java Native Interface},
year = 1997,
URL = {http://java.sun.com/products/jdk/1.2/docs/guide/jni/index.html},
note = {Javasoft's Native Interface for Java}
}

@inproceedings{joha02,
title = {Memory Architectures for Concurrent Lanugages using Message Passing},
author = {Erik Johansson and Konstantinos Sagonas and Jesper Wilhelmsson},
crossref = {ISMM02},
pages = {88-99}
}

@techreport{john88,
author = "Douglas Johnson",
title = "Trap Architectures for {Lisp} Systems",
number = "UCB/CSD/88/470",
institution = UCB,
month = nov,
year = 1988,
absstract = 
"Recent measurement of Lisp systems show a dramatic
skewing of operation frequency. For example, small
integer (fixation) arithmetic dominates most programs,
but other number types can occur on almost any
operation. Likewise, few memory references trigger
special banding for garbage collection, but nearly all
memory operations could trigger such special handling.
Systems like SPARC and SPUR have shown that small
amounts of special hardware can significantly reduce
the need for inline software checks by trapping when an
unusual condition is detected. A system's trapping
architecture now becomes key to performance. In most
systems, the trap architecture now becomes key to
performance. In most systems, the trap architecture is
intended to handle errors (e.g., address faults). The
requirements for Lisp traps are quite different. In
particular, the trap frequency is higher, processing
time per trap is shorter, and must need to be handled
in the user's address space and context. This paper
looks at these requirements, evaluates current trap
architectures, and proposes enhancements for meeting
those requirements. These enhancements increase
performance for Lisp 9-32 percent at cost of about 1.4 percent more
CPU logic."
}

@article{john91, 
title = "The Case for a Read Barrier",
author = "Douglas Johnson",
address = "Texas Instruments Inc, Dallas, Tx, 75265",
journal = Sigplan,
publisher = ACM,
year = 1991,
volume = 26,
number = 4,
pages = "279--287",
comment = "Lisp Machines have special purpose hardware to detect pointers
into fromspace and trap to a handler.
The cost of this checking on a conventional machine is in the tens of percent
for a high performance system."
}

@inproceedings{john91a,
author = "Douglas Johnson",
title = "Comparing Two Garbage Collectors",
crossref = "OOPSLA91-gc",
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/GC91/johnson.ps"
}

@inproceedings{john94,
author = {Eric E. Johnson and Jiheng Ha},
title = {{PDATS}: Lossless address space compression for reducing file size and access time},
booktitle = {Proceedings of 1994 IEEE International Phoenix Comference on Computers and Communication},
month = apr,
year = 1994
}

@inproceedings{john99,
author = {Eric E. Johnson},
title = {{PDATS} {II}: Improved compression of traces},
booktitle = {1999 IEEE International Performance, Computing and Communications Conference},
month = feb,
year = 1994
}


@article{john92, 
title = "Reducing the Latency of a Real-Time Garbage Collector",
author = "Ralph E. Johnson",
journal = "{L}etters on Programming Languages and Systems",
publisher = ACM,
volume = 1,
number = 1,
pages = "46--58",
month = mar,
year = 1992,
comment = "Variation of Appel, Ellis, Li using lazier copying of objects to fromspace."
}

@techreport{john85,
author = "Steven D. Johnson",
title = "Storage Allocation for List Processing",
number = 168,
institution = "Indiana University",
month = mar,
year = 1985
}

@phdthesis{john87,
author = "Thomas Johnsson",
title = "Compiling Lazy Functional Languages",
school = "Chalmers University of Technology",
year = 1987,
comment = "The G-machine compiler for LML"
}

@techreport{john91b,
title = "A Concurrent Fast Fit Memory Manager",
author = "Theodore Johnson",
institution = "University of Florida",
number = "91-009",
year = 1991
}

@article{johns92a,
author = "Theodore Johnson and D. Sasha",
title = "Parallel Buddy Memory Management",
journal = "Parallel Processing Letters",
volume = 2,
number = 4,
year = 1992,
pages = "391--398"
}

@misc{john92b,
author = "Theodore Johnson and Tim Davis",
title = "Space Efficient Parallel Buddy Memory Management",
year = 1992
}

@inproceedings{john97,
title = {The Memory Fragmentation Problem: Solved?},
author = {Mark S. Johnstone and Paul R. Wilson},
URL = {ftp://ftp.dcs.gla.ac.uk/pub/drastic/gc/wilson.ps},
crossref = {OOPSLA97-gc}
}

@phdthesis{john97a, 
title = {Non-Compacting Memory Allocation and Real-Time Garbage Collection},
author = {Mark S. Johnstone},
school = {University of Texas at Austin},
month = dec,
year = 1997,
URL = {ftp://ftp.cs.utexas.edu/pub/garbage/johnstone-dissertation.ps.gz},
abstract = {
Dynamic memory use has been widely recognized to have profound effects
on program performance, and has been the topic of many research studies
over the last forty years.  In spite of years of research, there is
considerable confusion about the effects of dynamic memory allocation.
Worse, this confusion is often unrecognized, and memory allocators are
widely thought to be fairly well understood.

In this research, we attempt to clarify many issues for both manual and
automatic non-moving memory management. We show that the traditional
approaches to studying dynamic memory allocation are unsound, and
develop a sound methodology for studying this problem. We present
experimental evidence that fragmentation costs are much lower than
previously recognized for most programs, and develop a framework for
understanding these results and enabling further research in this area.
For a large class of programs using well-known allocation policies, we
show that fragmentation costs are near zero. We also study the locality
effects of memory allocation on programs, a research area that has been
almost completely ignored. We show that these effects can be quite
dramatic, and that the best allocation policies in terms of
fragmentation are also among the best in terms of locality at both the
cache and virtual memory levels of the memory hierarchy.

We extend these fragmentation and locality results to real-time garbage
collection. We have developed a hard real-time, non-copying
generational garbage collector which uses a write-barrier to coordinate
collection work only with modifications of pointers, therefore making
coordination costs cheaper and more predictable than previous
approaches. We combine this write-barrier approach with implicit
non-copying reclamation, which has most of the advantages of copying
collection (notably avoiding both the sweep phase required by
mark-sweep collectors, and the referencing of garbage objects when
reclaiming their space), without the disadvantage of having to actually
copy the objects. In addition, we present a model for non-copying
implicit-reclamation garbage collection. We use this model to compare
and contrast our work with that of others, and to discuss the tradeoffs
that must be made when developing such a garbage collector. }
}

@inproceedings{john98,
author = {Mark S. Johnstone and Paul R. Wilson},
title = {The Memory Fragmentation Problem: Solved?},
pages = {26--36},
crossref = {ISMM98},
abstract = {We show that for 8 real and varied C and C++ programs, several
conventional dynamic storage allocators provide near-zero
fragmentation, once overheads due to implementation details (headers,
alignment, etc.) are properly accounted for. This substantially
strengthens our previous results showing that the memory
fragmentation problem has generally been misunderstood, and that
good allocator policies can provide good memory usage for most
programs. The new results indicate that for most programs, excellent
allocator policies are readily available, and efficiency of
implementation is the major challenge. While we believe that our
experimental results are state-of-the-art and our methodology is
superior to most previous work, more work should be done to identify
and study unusual problematic program behaviors not represented in
our sample.}
}

@article{joki89, 
title = "Customizable Garbage Collectors",
author = "M. O. Jokinen",
pages = "115--118",
journal = IPL,
publisher = NH,
month = feb,
year = 1989,
volume = 30,
number = 3,
abstract = {Conventional garbage collectors retain components of data
structures as long as the structure itself is accessible.  In some
applications, however, the components of a data structure are useful only if
they are referred by external pointers.  Recognition and deletion of useless
components requires co-operation between the garbage collector and the user
program = "the analysis of accessibility is carried out by the garbage collector
but user-defined routines are necessary to remove obsolete components from the
structure.  Two different co-operation mechanisms are discussed; the first 
can be used with garbage collectors based on reference counters, the other 
with mark-and-sweep collector.}
}

@incollection{jone81,
author = "Neil D. Jones and Steven S. Muchnick",
title = "Flow Analysis and Optimization of {LISP}-like Structures",
booktitle = "Program Flow Analysis: Theory and Applications",
pages = "102--131",
publisher = PH,
year = 1981
}

@techreport{jone92,
author = "Richard E. Jones and Rafael D. Lins", 
title = "Cyclic Weighted Reference Counting without Delay",
institution = UKC,
number = "28--92", 
URL = "ftp://unix.hensa.ac.uk/pub/misc/ukc.reports/comp.sci/reports/28-92.ps.Z",
month = dec,
year = 1992,
comments = {Improves on \cite{lins91c} by allowing processors to
continue to perform useful work in all circumstances.}
}

@article{jone92a,
title = "Tail recursion without space leaks",
author = "Richard Jones",
pages = "73--79",
journal = jfp,
month = jan,
year = 1992,
volume = 2,
number = 1
}


@inproceedings{jone93,
author = {Richard E. Jones and Rafael D. Lins}, 
title = {Cyclic Weighted Reference Counting without Delay},
crossref = {PARLE93},
pages = {712--515},
comments = {briefer version of \cite{jone92}}
}

@book{jone96,
author = "Richard E. Jones and Rafael Lins",
title = "Garbage Collection: Algorithms for Automatic Dynamic Memory Management",
publisher = Wiley,
address = {Chichester},
month = jul,
year = 1996,
pages = 403,
ISBN = "0--471--94148--4",
URL = "http://www.cs.ukc.ac.uk/people/staff/rej/gcbook/gcbook.html",
comment = {Reprinted February 1997, November 1997, January 1999, April 2000.}
}

% note = "With a chapter on Distributed Garbage Collection by R. Lins.",

@misc{jone95a,
title = "Bounds Checking for {C}",
author = "Richard Jones and Paul Kelly",
howpublished = "http://www-ala.doc.ic.ac.uk/~pjhk/BoundsChecking.html",
URL = "http://www-ala.doc.ic.ac.uk/~phjk/BoundsChecking.html",
}

@inproceedings{jone88,
author = {Simon B. Jones and le M\'{e}tayer, D.},
title = "Optimisation of Storage Management in Functional Languages by Static Analysis of Programs",
crossref = "glasgow88",
pages = "87--100",
}


@inproceedings{jone89,
author = {Simon B. Jones and D. le M\'{e}tayer},
title = "Compile-Time Garbage Collection by Sharing Analysis",
crossref = "FPCA89",
pages = "54--74",
abstract = "This paper describes an analysis technique to reduce the cost in 
processing time of the storage management operations implied by a program
(possibly to zero)."
}


@inproceedings{jone90,
title = "Is Compile Time Garbage Collection Worth the Effort",
author = "Simon B. Jones and M. White",
crossref = "glasgow90",
pages = "172--176",
}

@inproceedings{jone93a,
title = "The Implementer's Dilemma: A Mathematical Model of Compile-Time Garbage Collection",
author = "Simon B. Jones and Andrew S. Tyas",
crossref = "glasgow93",
pages = "139--144",
URL = "file://ftp.cs.stir.ac.uk/pub/tr/cs/1994/TR118.ps.Z",
abstract = "Optimization by compile time garbage collection is one
possible weapon in the functional language implementer's armoury for
combatting the excessive memory allocation usually exhibited by functional
programs. It is an interesting idea, but the practical question of whether
it yields benefits in practice has still not been answered convincingly
one way or the other.

In this short paper we present a mathematical model of the performance
of straightforward versions of mark-scan and copying garbage collectors
with programs optimized for explicit deallocation. A mark-scan heap
manager has a free list, whereas a copying heap manager does not ---
herein lies the dilemma, since a copying garbage collector is usually
considered to be faster than a mark-scan, but it cannot take advantage
of this important optimization.

For tractability we consider only heaps with fixed cells.

The results reported show that the garbage collection scheme of choice
depends quite strongly on the heap occupancy ratio: the proportion of
the total heap occupied by accessible data structures averaged over the
execution of the program. We do not know what typical heap occupancy
ratios are, and so are unable to make specific recommendations, but
the results may be of use in tailoring applications and heap management
schemes, or in controlling schemes where the heap size varies dynamically.

An important result arising from the work reported here is that when
optimizing for explicit deallocation, a very large proportion of cell
releases must be optimized before very much performance benefit is
obtained."
}

@techreport{jone95,
author = "Simon B. Jones",
title = "An Experiment in Compile Time Garbage Collection",
institution = {Programming Methodology Group, G\"{o}teborg University and Chalmers University of Technology},
number = 84,
month = jan,
year = 1995,
URL = "file://ftp.cs.stir.ac.uk/pub/tr/cs/1994/TR127.ps.Z",
comments = "Performs sharing analysis of strict, first-order functional programs.
A non-trivial Haskell program is adapted to run as a strict, first-order LML
program and re-use optimisation is applied.
The results are disappointing. 
Bytes allocated: -8 percent
GC time: -8 percent (but GC is only 10 percent of total exection time)
Cell allocation time not improved,
Locality: slightly improved
Cache penalty: -3 percent
Total time: -4.5 percent",
abstract = "This report presents the details and conclusions of an
experiment designed to assess the potential benefits to be obtained
from a particular proposal for optimizing the execution of functional
programs by compile time garbage collection. The optimizations proposed
comprise the compile time insertion of code to directly re-use heap cells
which are released and can be statically reallocated immediately. The
optimizations are determined by the static sharing analysis of
strict, first order functional programs using list (tree-like) data
structures. The method is powerful enough to detect many places in
programs where the optimization can be applied, but the effect on the
performance of ``typical'' programs has not been practically assessed
before. In this experiment a non-trivial Haskell program is adapted to run
as a strict, first order LML program. Re-use optimization is performed
(simple deallocation is not possible in LML as it has no free list in
the heap), and the performance of the unoptimized and optimized versions
are compared. The results turn out to be (surprisingly) disappointing:
although the number of bytes allocated from the heap is reduced by about
8\% and the time for garbage collections reduces by about 15\%, the cell
allocation time itself is not improved, and the garbage collection time
amounts to only 10\% of the total program execution time. There is a
slight improvement in the locality of memory references, reducing the
cache penalty overhead by about 3\%. The total time reductions are of
the order of 4.5\% --- which is not encouraging."
}


@article{jonk92,
author = "Jonker, J. E.",
title = "On-The-Fly Garbage Collection for Several Mutators",
journal = "Distributed computing",
volume = 5,
number = 4,
pages = "187-200",
month = apr,
year = 1992
}

@article{jonk79,
author = "H. B. M. Jonkers",
title = "A Fast Garbage Compaction Algorithm",
journal = IPL,
publisher = NH,
volume = 9,
number = 1,
month = Jul,
year = 1979,
pages = "25--30",
}


@book{jonk83, 
title = "Abstraction, Specification and Implementation Techniques: With an 
Application to Garbage Collection",
author = "H. B. M. Jonkers",
publisher = "Mathematical Centre, Amsterdam, the Netherlands",
year = 1983,
pages = "317",
ISBN = "90--6196--263--3"
}

@article{jord78,
author = "M. J. Jordan",
title = "SLP: A Paged Processor for Compact Lists",
journal = SPE,
publisher = Wiley,
volume = 8,
number = 3,
year = 1978,
pages = "285--301"
}

@inproceedings{joup90,
author = "Jouppi, Norman P.",
title = "Improving Direct-Mapped Cache Performance by the Addition of a
Small Fully-Associative Cache and Prefetch Buffers",
booktitle = "17th Annual International Symposium on Computer Architecture",
month = may,
pages = "346--373",
year = 1990,
comment = "Cost of cache miss may rise to 100 cycles"
}

@inproceedings{joup93,
author = "Jouppi, Norman P.",
title = "Cache Write Policies and Performance",
crossref = "ISCA93",
pages = "191--201"
}


@book{joy00,
author = {Bill Joy and Guy Steele and James Gosling and Gilad Bracha},
title = {The Java Language Specification},
edition = {Second Edition},
publisher = AW,
month = jun,
year = 2000
}

@manual{jpda,
title = "Java Platform Debugger Architecture ({JPDA})",
key = "JPDA",
organization = "Sun Microsystems",
note = {http://java.sun.com/j2se/1.3/docs/guide/jpda/},
URL = {http://java.sun.com/j2se/1.3/docs/guide/jpda/},
comment = {Debugger architecture for {J}ava. Includes:
Java Virtual Machine Debugger Interface (JVMDI) which defines the services a 
VM must provide for debugging;
Java Debug Wire Protocol (JDWP) which defines the format of information and 
requests transferred between the process being debugged and the debugger 
front end that implements the
Java Debug Interface  (JDI) which defines information and requests at the
user code level}
}

@manual{jprobe,
title = "The JProbe Profiler",
key = "JProbe",
organization = "Sitraka Inc.",
note = {http://www.jprobe.com},
URL = {http://www.jprobe.com},
comment = {Profiling and debugging tools for {J}ava}
}

@phdthesis{juli85,
author = "Danielle Julien",
title = {Etude et R\'{e}alisation de la Machine Virtuelle {LILA} Adapt\'{e}e \`{a} l'\'{E}criture d'Interpr\`{e}tes},
school = {Universit\'{e} Paul Sabatier, Toulouse, France},
month = may,
year = 1985
}

@inproceedings{jul87,
author = "Eric Jul and Henry Levy and Norman Hutchinson and Andrew Black",
title = "Fine-Grained Mobility in the {E}merald System",
booktitle = "Eleventh {ACM} Symposium on Operating Systems Principle",
publisher = ACM,
pages = "105--106",
year = 1987,
month = dec,
note = "See also \cite{jul88}."
}



@article{jul88,
title = "Fine-Grained Mobility in the {E}merald System",
author = "Eric Jul and Henry Levy and Norman Hutchinson and Andrew Black",
pages = "109--133",
journal = TransCompSys,
publisher = ACM,
year = 1988,
month = jan,
volume = 6,
number = 1,
abstract = {Emerald is an object-based language and system designed for the
construction of distributed programs.
--- From the Authors' Abstract
This paper is divided into five sections. In Section 1, the introduction,
the authors recall the advantages of process migration and fine grain
mobility. Section 2 is an overview of Emerald. Using examples coded in
Emerald, the authors show how an Emerald object is described and how
abstract types are defined. They explain the set of mobility primitives
and a new parameter passing scheme (call-by-move), and give a 
description of a process attached to an object.
Section 3, titled ``Implementing Mobility in Emerald,'' is devoted to the
description of the data structures, algorithms, and protocols involved in
the kernel. Some significant differences between Emerald and other systems
are given below. There are three object implementations (global, local, and
direct) with separate addressing options. Emerald uses an algorithm for
object searching based on Fowler's forwarding address, modified for
efficiency. It uses direct pointers (as opposed to indirect references as
in Smalltalk). Process moving is possible without code copying. Emerald
uses machine registers for efficiency (and has an algorithm for moving
them). There are two garbage collectors, local and distributed, which can
work in parallel with Emerald processes.
Section 4 covers performance. At the time this paper was written, the
system worked on a network of MicroVAXes connected by a 10 megabit/second
Ethernet. A newer version runs on Sun workstations. Tables summarize
the execution times for the mobility primitives and the network traffic in
the Emerald Mail System. Section 5 is a summary of the paper.
This paper is well written. It contains many references covering a large
amount of work in the area. The authors discuss the implementation choices
and include comparisons with other schemes. There are examples and figures,
and the text is clear. Nevertheless, some knowledge in the fields of
distributed computing and object-oriented languages and their
implementation is desirable. This paper should be read by anyone involved
in the construction of distributed systems. Other papers about Emerald 
have already been published.}
}


@phdthesis{jul88a,
author = "Eric Jul",
title = "Object Mobility in a Distributed Object-Oriented System",
school = "Department of Computer Science, University of Washington",
address = "Seattle, Washington",
month = dec,
year = 1988,
note = "Technical Report 88-12-6. Also {DIKU} Report (Blue Series) 89/1, 
Department of Computer Science, University of Copenhagen, Denmark",
}



@inproceedings{juul90,
author = "Nils Christian Juul",
title = "Report on the 1990 Workshop on Garbage Collection in Object-Oriented Systems",
crossref = "OOPSLA90",
note = "Addendum",
URL = "ftp://ftp.diku.dk/pub/GC90",
year = 1990
}


@inproceedings{juul90a,
author = "Nils Christian Juul",
title = "A Distributed, Faulting Garbage Collector for {E}merald",
crossref = "OOPSLA90-gc",
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/GC90/Juul.ps.Z"
}

@inproceedings{juul92,
title = "Comprehensive and Robust Garbage Collection in a Distributed System",
author = "Neils-Christian Juul and Eric Jul",
crossref = "IWMM92",
comment = "Concurrent, tri-colour mark-sweep scheme. Uses faulting a la Appel.
2 sets of collectors: (a) local, expedient, non-comprehensive; (b) global,
aims to be comprehensive."
}


@phdthesis{juul92a,
author = "Niels Christian Juul",
title = "Comprehensive, Concurrent, and Robust Garbage Collection in the 
Distributed, Object-Based System, {E}merald",
school = DIKU,
year = 1992,
}

@manual{jvmpi,
title = "Java Virtual Machine Profiling Interface ({JVMPI})",
key = "JVMPI",
organization = "Sun Microsystems",
note = {http://java.sun.com/j2se/1.3/docs/guide/jvmpi/},
URL = {http://java.sun.com/j2se/1.3/docs/guide/jvmpi/},
comment = {Profiling interface for {J}ava}
}

@article{kaas89,
author = "M. Frans Kaashoek and Andrew Tanenbaum and S. Hummel and Henri E. Bal",
title = "An Efficient Reliable Broadcast Protocol",
journal = "Operating Systems Review",
publisher = ACM,
volume = 23,
number = 4,
pages = "5--19", 
month = Oct,
year = 1989
}


@mastersthesis{kabu92,
author = "Kaburlasos, Nikos",
title = "Hardware Support for Garbage Collection in the {C} Programming Language",
year = 1992,
school = "University of Texas at Austin"
}


@article{kaeh81,
author = "Kaehler, Ted",
title = "Virtual Memory for an Object-Oriented Language",
journal = "Byte",
volume = 6,
number = 8,
month = aug,
year = 1981,
pages = "378--387"
}


@incollection{kaeh83,
author = "Kaehler, Ted and Glenn Krasner",
title = "{LOOM} --- Large Object-Oriented Memory for {S}malltalk-80 Systems",
crossref = "Smalltalk-BHWA",
pages = "251--271",
}



@inproceedings{kaeh86,
author = "Kaehler, Ted",
title = "Virtual Memory on a Narrow Machine for an Object-Oriented Language",
crossref = "OOPSLA86",
pages = "87--106"
}

@inproceedings{kafu90,
author = "Dennis Kafura and Doug Washabaugh and Jeff Nelson",
title = "Garbage Collection of Actors",
crossref = "OOPSLA90",
pages = "126--134"
}

@article{kafu95,
author = "Dennis Kafura and Manibrata Mukherji and Doug Washabaugh",
title = "Concurrent and Distributed Garbage Collection of Active Objects",
journal = "IEEE Transactions on Parallel and Distributed Systems",
volume = 6,
number = 4,
month = apr,
year = 1995
}

@inproceedings{kage97,
author = "Andreas Kagedal and Saumya K. Debray",
title = "A Practical Approach to Structure Reuse of Arrays in Single Assignment Languages",
booktitle = "International Conference on Logic Programming",
pages = "18--32",
year = "1997",
url = "http://citeseer.nj.nec.com/agedal97practical.html" 
}

@inproceedings{kagi91,
title = "Adaptive Storage Management for Very Large Virtual/Real Storage Systems",
author = "T. Kagimasa and K. Takahashi and S. Yoshizumi",
crossref = "ISCA91",
pages = "372--379"
}


@article{kain69,
author = "Y. Kain",
title = "Block Structures, Indirect Addressing,  and  Garbage  Collection",
journal = CACM,
publisher = ACM,
volume = 12,
number = 7,
month = Jul,
year = 1969, 
pages = "395--398",
}

@manual{kals89,
author = "Bill Kalsow and Eric Muller",
title = "{SRC} {M}odula-3, Version 1.2",
organisation = DECSRC,
month = dec,
year = 1989
}

@article{kala03,
title = {Mash That Trash --- Incremental Compaction in the {IBM} {JDK} Garbage Collector:
How to minimize pause times and free the heap from dark matter},
author = {Aruna Kalagnanam and Sripathi Kodi},
journal = {IBM developerWorks},
month = jun,
year = 2003,
abstract = {This article discusses incremental compaction, a new
feature in the memory management component of IBM JDK 1.4.0.
Incremental compaction is a way of spreading compaction work across
different garbage collection cycles, thereby reducing pause times. The
authors discuss the need for incremental compaction, the compaction
phases at a high level, and some runtime parameters. They also explain
how to interpret changes in the verbosegc output.},
URL = {http://www-106.ibm.com/developerworks/ibm/library/i-incrcomp}
}

@inproceedings{kakk98,
author = {Sheetal V. Kakkad and Mark S. Johnstone and Paul R. Wilson },
title = {Portable Run-Time Type Description for Conventional Compilers},
pages = {146--153},
crossref = {ISMM98},
abstract = {Many useful programming language extensions and support
libraries require knowledge of the locations of fields within objects
at run time. Examples include orthogonal persistent object stores,
precise garbage collectors, data structure picklers and parameter
marshaling schemes.

For clean and efficient implementation as libraries, these systems
require run-time knowledge of in-memory layouts of data objects, which
is unavailable in most traditionally-compiled and linked programming
languages, such as C, C++, and Ada. Even C++'s recently-standardized
run-time type identification (RTTI) feature is insufficient, because it
describes language-level features of the type hierarchy and not
compiler-dependent object layout decisions.

We present a facility for run-time type description or RTTD, which
extracts low-level layout information from debugging information
generated by conventional compilers, and makes it available to user
programs. We believe this to be the simplest and most portable approach
to run-time type description, requiring no changes to existing
compilers. In this paper, we describe the basic strategies and present
details of our implementation for C++. We also sketch some extensions
that we have implemented, including special treatment of C++'s virtual
function table pointers to match persistent or foreign data objects
with the actual code in a particular application.

Our implementation of run-time type description is freely available. It
is in regular use with multiple operating systems and compilers, in
both free and commercial products, including a high-performance
persistent object storage system for C++ and a real-time garbage
collector. }
}


@article{kaku86,
title = "Parallel Reference Counting Algorithm.",
author = "K. Kakuta and H. Nakamura and S. Iida",
journal = IPL,
publisher = NH,
volume = 23,
number = 1,
pages = "33--37",
year = "1986",
comments = {Presents a parallel architecture based on reference counting.
Unable to recycle all cyclic structures in parallel.}
}


@inproceedings{kama93,
author = "Tomio Kamada and Satoshi Matsuoka and Akinori Yonezawa",
title = "Efficient Parallel Global Garbage Collection on Massively Parallel Computers",
crossref = "OOPSLA93-gc",
}

@inproceedings{kama94,
author = "Tomio Kamada and Satoshi Matsuoka and Akinori Yonezawa",
title = "Efficient Parallel Global Garbage Collection on Massively Parallel Computers",
booktitle = "Supercomputing'94",
pages = "79--88",
publisher = IEEE,
editor = "G.M. Johnson",
year = 1994, 
URL = "http://www.computer.org/p3/kamadat.ps",
}

@inproceedings{kand87,
title = "Network Simulation of Synchronous Garbage Collection Algorithm",
author = "B. Kandu and S. Heng and C. Wu and Nader Bagherzadeh",
pages = "215--222",
booktitle = "Simulation of computer networks1987 Symposium on the 
simulation of computer networks, Colorado Springs, Aug. 4--7, 1987",
editor = "P. Roth",
publisher = IEEE,
year = "1987",
isbn = "0--8186--0782--3"
}

@mastersthesis{katz86,
author = "M. J. Katz",
title = "{ParaTran}:  A Transparent, Transaction Based Runtime
Mechanism for Parallel Execution of {S}cheme",
school = MIT,
month = jun,
year = 1986 
}

@inproceedings{kapl02,
title = {Adaptive Caching for Demand Prepaging},
author = {Scott Kaplan and Lyle McGeoch and Megan Cole},
crossref = {ISMM02},
pages = {114--126}
}

@article{kauf84,
title = "Tailored-List and  Recombination-Delaying Buddy Systems",
author = "Arie Kaufman",
journal = TOPLAS,
publisher = ACM,
volume = 6,
number = 4,
year = 1984,
pages = "118--125"
}


@inproceedings{kawa86,
title = "Scalable Dataflow Structure Store",
author = " K. Kawakami and J. R. Gurd",
booktitle = "13th Annual International Symposium on Computer 
Architecture --- Conference Proceedings. Tokyo, 1986 Jun 2--5",
publisher = IEEE,
year = 1986,
abstract = {A design for a highly parallel data structure store for the
prototype Manchester Dataflow Computer is presented.  The main design objective
is to allow all storage functions to be performed concurrently.  The functions
include space allocation and garbage collection, as well as operations for
reading and writing the store.  The resulting design is scalable in that an
incremental increase in performance for any function can be achieved by adding
appropriate hardware modules to the system.  A relative balance in performance
between the different functions can therefore be achieved.  In the hardware
structure store, the logical and the physical function units are designed
separately.  This increases flexibility for configuring multiprocessor 
dataflow systems.  A single hardware module performing all the functions has
been constructed and attached to the prototype Manchester Dataflow Machine.  
The performance of this configuration is discussed.}
}

@article{kenn91,
author = "K. B. Kenny and K. Lin",
title = "Flexible Real-Time Systems Using the {F}lex Language",
journal = IEEETransComp,
publisher = IEEE,
pages = "70--78",
month = may,
year = 1991
}


@inproceedings{kenn91a,
title = "The Features of the Object Oriented Abstract Type Hierarchy
({OATH})",
author = "Brian Kennedy",
booktitle = "Proceedings of the {U}senix {C++} Conference",
editor = "",
pages = "41--50",
year = 1991,
publisher = "Usenix Association",
month = apr,
comment = "Uses accessors rather than smart pointers in order to avoid the
dangers of raw pointers leaking out. But accessors still suffer from many
of the same problems as smart pointers."
}

@inproceedings{kerm95,
author = "A. M. Kermarrec and G. Cabillic and A. Gefflaut and C. Morin and Isabbelle Puaut",
title = "A Recoverable Distributed Shared Memory Integrating Coherence and 
Recoverability",
booktitle = "Twenty-Fifth Annual International Symposium on Fault-Tolerant Computing",
year = 1995
}


@inproceedings{kess89,
author = "Kessler, Richard and Richard Jooss and Alvin Lebeck and Mark D.
Hill",
title = "Inexpensive Implementations of Set-Associativity",
booktitle = "16th Annual International Symposium on Computer Architecture",
month = jun,
year = 1989,
publisher = "IEEE-ACM",
address = "Jerusalem, Israel",
pages = "131--139"      }

@inproceedings{kess89a,
author = "Richard E. Kessler and M. Livny",
title = "An Analysis of Distributed Shared Memory Algorithms",
booktitle = "Proceedings of the 9th International Conference on Distributed Computing Systems",
month = Jun,
year = 1989
}

@article{kess92,
author = "Kessler, Richard and H. Carr and L. Stoller and M. Swanson",
title = "Implementing {C}oncurrent {S}cheme for the {M}ayfly Distributed Parallel Processing System",
journal = LSC,
publisher = "Kluwer",
volume = 5,
number = 1,
pages = "73--93",
month = may,
year = 1992
}

@inproceedings{kim98,
author = "Jin-Soo Kim and Xiaohan Qin and Yarsun Hsu",
title = "Memory Characterization of a Parallel Data Mining Workload",
booktitle = "Proc. Workload Characterization: Methodology and Case Studies",
publisher = IEEE,
year = 1998,
month = nov,
URL = "http://www.computer.org/proceedings/wwc/0450/04500060abs.htm",
abstract = {
This paper studies a representative of an important class of emerging
applications, a parallel data mining workload.  The application,
extracted from the {IBM} {I}ntelligent {M}iner, identifies groups of
records that are mathematically similar based on a neural network
model called self-organizing map.  We examine and compare in details
two implementations of the application: (1) temporal locality or
working set sizes; (2) spatial locality and memory block utilization;
(3) communication characteristics and scalability; and (4) TLB
performance.

First, we find that the working set hierarchy of the application is
governed by two parameters, namely the size of an input record and the
size of prototype array; it is independent of the number of input
records.  Second, the application shows good spatial locality, with
the implementation optimized for sparse data sets having slightly
worse spatial locality.  Third, due to the batch update scheme, the
application bears very low communication.  Finally, a 2-way set
associative TLB may result in severely skewed TLB performance in a
multiprocessor environment caused by the large discrepancy in the
amount of conflict misses.  Increasing the set associativity is more
effective in mitigating the problem than increasing the TLB size.
}
}

@inproceedings{kim00a,
author = "Jin-Soo Kim and Yarsun Hsu",
title = "Memory System Behavior of {J}ava Programs: Methodology and Analysis",
booktitle = "Proceedings of the International conference on measurements and modeling of computer systems",
pages = {264--274},
year = 2000,
month = jul,
URL = "http://dev.acm.org/pubs/citations/proceedings/metrics/339331/p264-kim/"
}

@inproceedings{kim99,
title = {Scheduling Garbage Collector for Embedded Real-Time Systems},
author = {Taehyoun Kim and Naehyuck Chang and Namyun Kim and Heonshik Shin},
pages = {55--64},
crossref = {LCTES99}
}

@inproceedings{kim00,
title = {Bounding Worst Case Garbage Collection Time for Embedded Real-Time Systems},
author = {Taehyoun Kim and Naehyuck Chang and Heonshik Shin},
booktitle = {Proceedings of the Sixth IEEE Real Time Technology and Applications Symposium (RTAS 2000)},
year = 2000,
URL = {http://computer.org/Proceedings/rtas/0713/07130046abs.htm},
abstract = {Execution of programs with various data structures often
requires dynamic memory management based on garbage collection for
better productivity, robustness, and program integrity. In spite of its
benefits, garbage collection has not been widely used in embedded
real-time systems partly because it often causes unpredictable
pause delay. Guaranteeing real-time operations with garbage
collection aims to bound and estimate the worst case computation
time of garbage collector as well as application tasks. We
introduce a new technique for bounding and estimating the worst
case garbage collection time in light of task scheduling. Since
the worst case live memory is the dominant factor to determine the
worst case garbage collection time, we quantify the worst case
live memory using the states of periodic tasks. We also present a
predictable real-time copying collection algorithm in order to
assess the effectiveness of the proposed approach. Performance
evaluation shows that the proposed approach provides a safe and
effective bound on the garbage collection time, thus reducing the
upper bound of live memory size by up to 35x \% compared with the
trivial bound. It also demonstrates that our algorithm can
accomplish 7-14\% reduction in the memory requirement.}
}

@article{kim01,
author = {Taehyoun Kim and Naehyuck Chang and Heonshik Shin},
title = {Joint Scheduling of Garbage Collector and Hard Real-time Tasks for
Embedded Applications},
journal = {Journal of Systems and Software},
pages = {247--260},
publisher = ES,
volume = 58,
number = 3,
month = sep,
year = 2001
}


@inproceedings{kimu87,
author = "Y. Kimura and K. Nishida and N. Miyauchi and T. Chikayama",
title = "Realtime {GC} by Multiple Reference Bit in {KL1}",
booktitle = "Proceedings of the Data Flow Workshop",
pages = "215--222",
year = 1987,
month = oct,
note = "In Japanese"
}

@article{king91,
author = "H. Kingdon and David R. Lester and Geoffrey L. Burn",
title = "The {HDG}-Machine: A Highly Distributed Graph Reducer
for a transputer network",
journal = CompJ,
publisher = BCS,
volume = 34,
numbner = 4,
pages = "290--301",
month = Sep,
year = 1991
}

@inproceedings{king02,
title = {Removing {GC} Synchronisation},
author = {Andy C. King},
crossref = {OOPSLA02},
pages = {112--113 (Companion)}
}

@techreport{kist99,
author = {Thomas Kistler and Michael Franz.},
title = {The Case for Dynamic Optimization: Improving Memory-Hierarchy
Performance by Continuously Adapting the Internal Storage Layout of Heap Objects at Run-Time},
institution = {University of California, Irvine},
number = {99--21},
month = may,
year = 1999,
URL = {http://caesar.ics.uci.edu/kistler/papers/ics-tr-99-21.ps}
}

@techreport{kist98,
author = {Thomas Kistler and Michael Franz.},
title = {Automated Layout of Data Members for Type-Safe Languages},
institution = {University of California, Irvine},
number = {98--22},
month = may,
year = 1998,
URL = {http://caesar.ics.uci.edu/kistler/papers/ics-tr-98-22.ps}
}

@inproceedings{kjel95,
title = "Memory Management in Flash-Memory Disks with Data Compression",
author = "Morten Kjelso and Simon Jones",
address = "Department of Electronic \& Electrical Engineering, Loughborough University
 of Technology",
crossref = "IWMM95",
}

@inproceedings{klai91,
author = "Klaiber, Alexander C. and Henry M. Levy",
title = "An Architecture for Software-Controlled Data Prefetching",
booktitle = "18th Annual International Symposium on Computer Architecture",
publisher = "Association for Computing Machinery",
year = 1991,
month = may,
pages = "43--53",
address = "Toronto, Ontario, Canada"   
}


@mastersthesis{kluk89,
author = "Kluk, Mark G.",
title = "A Study of Garbage Collection Schemes for List Processors",
year = 1989,
school = "Lehigh University"
}

@inproceedings{kluz88,
author = {F. Klu\'{z}niak},
title = "Compile-Time Garbage Collection for Ground {P}rolog",
booktitle = "5th International Conference and Symposium on Logic Programming",
pages = "1490--1505",
year = 1988
}

@techreport{knig74,
author = "Tom Knight",
title = "{CONS}",
institution = MITAI,
type = "Working Paper",
number = 80,
month = nov,
year = 1974,
comment = "MIT Lisp machine"
}

@article{know65,
title = "A Fast Storage Allocator",
author = "Kenneth C. Knowlton",
journal = CACM,
publisher = ACM,
volume = 8,
number = 10,
month = oct,
year = 1965,
pages = "623--625"
}

@inbook{knut73,
author = "Donald E. Knuth",
title = "The Art of Computer Programming", 
volume = "I: Fundamental Algorithms",
publisher = AW,
edition = "Second",
year = 1973, 
commments = {section 2.3.5 is the most comprehensive description and analysis of
algorithms that appeared prior to 1968. Standard reference for these algorithms
before cohe81},
chapter = 2,
}


@inproceedings{koch90,
title = "Cache Coherence and Storage Management in a Persistent Object System",
author = "B. Koch and T. Schunke and A. Dearle and F. Vaughan and C. Marlin and
R. Fazekerley and C. Barter",
crossref = "IWPOS90",
pages = {99--109}
}

@inproceedings{koga97,
author = {Dmitry Kogan and Assaf Schuster},
title = {Remote Reference Counting: Distributed Garbage Collection with 
Reduced Memory and Communication Overhead},
booktitle = {Proceedings of Fifth European Symposium on Algorithms},
address = {Graz},
pages = {308--325},
month = sep,
year = 1997,
URL = {http://www.cs.technion.ac.il/Labs/Millipede}
}

@inproceedings{koga97a,
author = {Dmitry Kogan and Assaf Schuster},
title = {Collecting Garbage Pages in a Distributed Shared Memory System},
booktitle = {Proceedings of Fifth European Symposium on Algorithms},
address = {Graz},
pages = {308--325},
month = sep,
year = 1997,
URL = {http://www.cs.technion.ac.il/Labs/Millipede}
}

@mastersthesis{koid93,
author = "Hiroshi Koide",
title = "Hybrid Garbage Collection",
school = "University of Electro-Communications, Tokyo",
year = 1993,
}

@article{koid93a,
author = "Hiroshi Koide and K. Noshita",
title = "On the Copying Garbage Collection which Preserves the Genetic Order",
journal = "Transaction of Information Processing (IPSJ)",
volume = 34,
number = 11,
pages = "2395--2400",
month = nov,
year = 1993,
note = "In Japanese"
}

@inproceedings{koll96,
title = "Blue --- A Language for Teaching Object-Oriented Programming",
author = {Michael K\"{o}lling and John Rosenberg},
booktitle = "Proceedings of the 27th SIGCSE Technical Symposium on Computer Science Education", 
month = mar,
year = 1996,
pages = "190--194",
URL = "ftp://ftp.cs.su.oz.au/mik/papers/blue_paper.ps.Z",
abstract = "Teaching object-oriented programming has clearly become an
important part of computer science education. We agree with many others
that the best place to teach it is in the CS1 introductory course. Many
problems with this have been reported in the literature. These mainly
result from inadequate languages and environments. Blue is a new
language and integrated programming environment, currently under
development explicitly for object-oriented teaching. We expect clear
advantages from the use of Blue for first year teaching compared to
using other available languages. This paper describes the design
principles on which the language was based and the most important
aspects of the language itself.",
comment = "Uses GC"
}



@techreport{kolo87,
author = "Elliot K. Kolodner",
title = "Recovery Using Virtual Memory",
institution = "MIT Laboratory for Computer Science",
type = "Technical Memo",
number = "MIT/LCS/TM--404",
month = jul,
year = 1987,
URL = "ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/listings/abstracts/TM-404.html"
}

@article{kolo89,
title = "Atomic Garbage Collection:  Managing a Stable Heap",
author = "Elliot K. Kolodner and Barbara Liskov and  W. Weihl",
pages = "15--25",
note = "Proceedings of 1989 ACM SIGMOD International Conference on Management of Data",
journal = "SIGMOD Record",
editor = "James Clifford and Bruce G. Lindsay and David Maier",
publisher = ACM,
month = jun,
year = 1989,
volume = 18,
number = 2
}


@inproceedings{kolo91,
title = "Atomic Incremental Garbage Collection and Recovery for Large Stable
Heap, Implementing Persistent Object Bases: Principles and Practice",
author = "Elliot K. Kolodner",
address = "IBM Science and Technology, Israel and MIT Lab. MA, USA",
crossref = "IWPOS90"
}

@phdthesis{kolo92,
author = "Kolodner, Elliot K.",
title = "Atomic Incremental Garbage Collection and Recovery for a Large Stable Heap",
school = MIT,
year = 1992,
note = "MIT/LCS/TR  534"
}

@inproceedings{kolo92a,
title = "Atomic Incremental Garbage Collection",
author = "Elliot K. Kolodner and W. E. Weihl",
address = "IBM Science and Technology, Israel and MIT Lab. MA, USA",
crossref = "IWMM92",
}

@inproceedings{kolo93,
title = "Atomic Incremental Garbage Collection and Recovery for Large Stable
Heap",
author = "Elliot K. Kolodner and William E. Weihl",
booktitle = "Proceedings of 1993 ASM SIGMOD International Conference on the Management of Data",
address = "Washington, DC",
editor = "Peter Buneman and Sushil Jajodia",
pages = "177--186",
month = may,
year = 1993,
note = "Also MIT/LCS/TR-534, February, 1992",
URL = "ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/listings/abstracts/TM-534.html"
}

@techreport{kolo98,
author = {Elliot K. Kolodner and Erez Petrank},
title = {Parallel Copying Garbage Collection using Delayed Allocation},
institution = "IBM Haifa Research Lab.",
number = "88.384",
month = nov,
year = 1999,
URL = {http://www.cs.technion.ac.il/~erez/publications.html},
}

@inproceedings{koop90,
title = "Cache Performance of Combinator Graph Reduction",
author = "Philip J. Koopman and Peter Lee and Daniel P. Siewiorek",
crossref = "PLDI89",
pages = "110--119",
}

@article{koop92,
title = "Cache Behavior of Combinator Graph Reduction",
author = "Philip J. Koopman and Peter Lee and Daniel P. Siewiorek",
pages = "265--297",
journal = toplas,
publisher = ACM,
year = 1992,
month = apr,
volume = 14,
number = 2
}


@techreport{kord92,
author = "Kordale, R. and John Shilling and Mustaque Ahamad",
title = "Garbage Collection in Distributed Shared Memory Systems",
institution = "Georgia Institute of Technology",
number = "TR GIT-CC-92/45",
year = 1992
}

@inproceedings{kord93,
author = "R. Kordale and Mustaque Ahamad",
title = "A Scalable Cyclic Garbage Detection Algorithm for Distributed Systems",
crossref = "OOPSLA93-gc",
}

@inproceedings{kord93a,
author = "Kordale, R. and Mustaque Ahamad and John Shilling",
title = "Distributed/Concurrent Garbage Collection in Distributed Shared Memory Systems",
crossref = "IWOOOS93",
}

@inproceedings{korn85,
author = "David G. Korn and Kiem-Phong Vo",
title = "In Search of a Better Malloc",
booktitle = "Proceedings of the Summer 1985 {USENIX} Conference",
publisher = UA,
year = 1985,
pages = "489--506"
}


@article{kowa79,
author = "T. Kowaltowski",
title = "Data Structures and Correctness of Programs",
journal = JACM,
publisher = ACM,
volume = 26,
number = 2,
month = apr,
year = 1979,
pages = "283--301",
comments = {proves the correctness of the link reversal algorithm by Deutsch-Schorr-Waite},
}

@proceedings{krak00, 
key="krak00",
title = {Recent Advances in Distributed Systems},
editor = {S. Krakowiak and S.K. Shrivastava},
series = LNCS,
volume = 1752,
chapter = 5,
month = feb,
year = 2000,
URL = {http://link.springer.de/link/service/series/0558/tocs/t1752.htm}
}

@inproceedings{kran86,
author = "Kranz, David A. and Richard Kelsey and Jonathan Rees and Paul Hudak an
d James Philbin and Norman Adams",
title = "{ORBIT}:  An Optimizing Compiler For {S}cheme",
crossref = "CC86",
pages = "219--233"    
}


@phdthesis{kran88,
author = "David A. Kranz",
title = "{ORBIT}:  An Optimizing Compiler For {S}cheme",
school = "Yale University",
year = 1988,
month = feb    
}


@inproceedings{kran89,
author = "David A. Kranz and Robert H. Halstead and E. Mohr",
title = "Mul--{T}: A High-Performance Parallel {L}isp",
crossref = "PLDI89",
pages = "81--90"
}

%book{Smalltalk-BHWA,
% in cross-references section

@inproceedings{krie93,
author = "E. Ulrich Kriegel",
title = "A Conservative Garbage Collector for an {EuLisp} to {ASM}/{C} Compiler",
crossref = "OOPSLA93-gc",
}

@inproceedings{krie90,
author = "O. Krieger and Michael Stumm",
title = "An Optimistic Approach for Consistent Replicated Data for Multicomputers",
booktitle = "Proc. HICCSS",
year = 1990
}

@article{krog73,
author = "S. Krogdahl",
title = "A Dynamic Storage Allocation Problem",
journal = IPL,
publisher = NH,
volume = 2,
year = 1973,
pages = "96--99"
}

@incollection{krue89,
author = "Steven Krueger",
title = "VLSI-Appropriate Garbage Collection Support",
booktitle = "VLSI for artificial intelligence",
editor = "Delgado-Frias, Jose G and Moore, Will R.",
publisher = "Kluwer Academic Publishers",
year = 1989,
series = "The Kluwer international series in engineering and computer science"
}


@techreport{kuec91,
author = {K\"{u}chlin, Wolfgang and Nevin, Nicholas J.},
title = "On Multi-Threaded List-Processing and Garbage Collection",
institution = "Ohio State University",
year = 1991,
number = "OSU-CISRC-3/91-TR11",
month = Mar,
abstract = "We present the S-threads system for multi-threaded 
list-processing in C, and we discuss its unique techniques of 
parallel garbage collection.  The system is implemented on top of 
C Threads on an Encore Multimax running Mach.  It was developed 
for the parallelization of the SAC-2 Computer Algebra system, but 
S-threads is general enough to support the parallelization of 
other C based list-processing systems.  An S-thread is a C Thread 
extended by a private heap segment with a private list of 
available cells.  Private heaps are dynamically allocated by 
claiming pages of cells from a global shared heap.  S-threads can 
thus concurrently cons list cells and the application library can 
build other parallel list-processing on top.
Our main discovery is that the exclusive use of the portable C 
Threads system has profound implications for garbage collection.  
We can no  longer efficiently stop all processing at a barrier, 
which precludes us from using many popular parallel garbage 
compaction algorithms. However, threads can now perform 
preventive garbage collection upon exiting, where they free their 
private heap segment at the small cost of copying their results.  
This proves very effective in our experience, and appears 
especially promising for real-time symbolic computation.  Under 
some restrictions, threads can also run a sequential garbage 
collection algorithm, such as mark-and-sweep, on their private 
heaps.
On separate threads, multiple garbage collections and ordinary 
processing can then occur concurrently.  Under a largely 
functional style of programming, there is then no need for a new 
parallel garbage collection algorithm, which is important for 
full upward compatibility of sequential software.  We present 
empirical results from testing our garbage collection techniques 
on a parallel algorithm for polynomial g.c.d. calculation."
}

@inproceedings{kuec91a,
author = {K\"{u}chlin, Wolfgang and Nevin, Nicholas J.},
title = "On Multi-Threaded List-Processing and Garbage Collection",
booktitle = "Proceedings of Third {IEEE} Symposium on Parallel and Distributed Processing",
pages = "894--897",
month = dec,
publisher = IEEE,
year = 1991
}

@inproceedings{kuec91b,
author = {K\"{u}chlin, Wolfgang},
title = "A Space-Efficient Parallel Garbage Collection Algorithm",
booktitle = "Proceedings of Fifth {ACM} International Conference on Supercomputing",
pages = "40--46",
publisher = ACM,
month = jun,
year = 1991
}

@inproceedings{kuma02,
title = {Dynamic Memory Management for Programmable Devices},
author = {Sanjeev Kumar and Kai Li},
crossref = {ISMM02},
pages = {139--149}
}

@inproceedings{kung77,
author = "H. T. Kung and S. W. Song",
title = "An Efficient Parallel Garbage Collection System and its Correctness 
Proof",
booktitle = "{IEEE} Symposium on Foundations of Computer Science",
publisher = IEEE,
year = "1977",
pages = "120--131",
comments = {Presents a variant of the on-the-fly garbage collection algorithm 
\cite{dijk78} that uses four colours and does not trace
the free-list.}
}

@techreport{kung77a,
author = "H. T. Kung and S. W. Song",
title = "Performance Analysis of a Parallel Garbage Collection System",
institution = CMU,
type = "Department of Computer Science Report",
year = 1977,
month = aug
}

@techreport{kung77b,
author = {Kung, H. T. and Song, S. W.},
title = {An Efficient Parallel Garbage Collection System and its Correctness Proof.},
institution = CMU,
type = "Department of Computer Science Report",
year = 1977,
month = sep
}

@mastersthesis{kung83,
author = "Kung, Delphine T. H",
title = "Garbage Collection of Linked Data Structures: An Example in a Network Oriented Database Management System",
year = 1983,
school = "Rochester Institute of Technology"
}


@inproceedings{kuri90,
author = "Satoshi Kurihara and Mikio Inari and Norihisa Doi and Kazuki Yasumatsu and Takemi Yamazaki",
title = "{SPiCE} Collector : The Run-Time Garbage Collector for
{S}malltalk-80 Programs Translated into {C}",
crossref = "OOPSLA90-gc",
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/GC90/Kurihara.ps.Z"
}

@inproceedings{kuro75,
author = "T. Kurokawa",
title = "New Marking Algorithms for Garbage Collection",
booktitle = "Proceedings of the  2nd USA--Japan Computer Conference", 
year = 1975, 
pages = "585--584",
comments = {marking algorithm which use a fixed-length stack and a tag bit to
deal with stack overflow},
}

@article{kuro81,
author = "T. Kurokawa",
title = "A New Fast and Safe Marking Algorithm",
journal = SPE,
publisher = Wiley,
volume = "11",
pages = "671--682",
year = 1981,
institution = "Toshiba R\&D Center, Kawasaki 210, Japan",
abstract = {A new marking algorithm for garbage collection is presented.
Although the method is a variation of the usual simple stacking algorithm,
in practice this algorithm has quite improved both in stack space and processing
time. One significant modification is to stack a node only when both the
sublists are unmarked.
The other innovation is a `stacked-node-checking' method invoked after each 
stack-overflow...},
}


@inproceedings{kuse91,
title = "Generational Garbage Collection for {C}-Based Object-Oriented
Languages",
author = "Kazushi Kuse and Tsutomu Kamimura",
crossref = "OOPSLA91-gc",
comment = "Reference found in Detlefs92, but not in the archive?"
}

@article{lakh00,
author = {M.K. Lakhamraju and R. Rastoji and S. Seshadri and S. Sundarshan},
title = {On-line Reorganization in Object Databases},
journal = {{SIGMOD} Record},
volume = 28,
month = may,
year = 2000, 
publisher = ACM,
note = {Proceedings of {ACM} {SIGMOD} International Conference on the Management of 
Data, Dallas, Texas},
comment = {includes IRA, an agorithm that can be appiled to copying
collectors, online clustering and other contexts in which it is
necessary to move objects in presence of concurrent access to those
objects}
}

@phdthesis{ladi89,
author = "Ladin, Rivka",
title = "A Method for Constructing Highly Available Services and a 
Technique for Distributed Garbage Collection",
year = 1989,
school = MIT
}

@inproceedings{ladi92,
title = "Garbage Collection of a Distributed Heap",
author = "Rivka Ladin and Barbara Liskov",
booktitle = "International Conference on Distributed Computing Systems",
address = "Yokohama",
month = jun,
year = 1992,
comment = "Simplifies and corrects \cite{lisk86}, adopting Hughes' algorithm."
}


@inproceedings{lam91,
author = "Monica S. Lam and others",
title = "The Cache Performance and Optimizations of Blocked Algorithms",
crossref = "ASPLOS91",
pages = "63--74"
}


@inproceedings{lam92,
title = "Object Type Directed Garbage Collection to Improve Locality",
author = "Michael S. Lam and Paul R. Wilson and Thomas G. Moher",
booktitle = "Proceedings of International Workshop on Memory Management",
address = "St Malo, France",
publisher = SV,
series = LNCS,
volume = 637,
month = "16--18~" # sep,
year = 1992
}

@phdthesis{lam92a,
author = "Lam, Michael S.",
title = "Improving Locality via Garbage Collection",
year = 1992,
school = "University of Illinois at Chicago"
}

@article{lamb91,
author = "Charles Lamb and Gordon Landis and Jack Orenstein and Dan Weinreb",
title = "The {ObjectStore} Database System",
journal = cacm,
publisher = ACM,
year = 1991,
volume = 34,
number = 10,
month = oct,
pages = {50--63}
}

@techreport{lamp75,
author = "Lamport Leslie",
title = "On-The-Fly Garbage Collection: Once More with Rigor",
institution = "Computer Associates",
number = "CA-7508-1611",
year = 1975,
month = aug,
address = "Wakefield, MA",
}

@inproceedings{lamp76,
author = "Leslie  Lamport",
title = "Garbage Collection With Multiple Processes: an Exercise in 
Parallelism",
booktitle = "Proceedings of the 1976 International Conference on Parallel Processing",
year = 1976,
pages = "50--54",
comment = "Generalisation of Dijkstra's algorithm to multiple processes."
}

@techreport{lamp76a,
author = "Lamport Leslie",
title = "Garbage Collection With Multiple Processes: an Exercise in Co-operation",
institution = "Computer Associates",
number = "CA-7602-2511",
year = 1976,
month = aug,
address = "Wakefield, MA",
}

@article{lamp79,
title = "A New Approach to Proving the Correctness of Multiprocess Programs",
author = "Leslie Lamport",
journal = toplas,
publisher = ACM,
year = 1979,
month = jul,
volume = 1,
number = 1,
pages = "84--97"
}

@techreport{lamp91,
author = "Leslie Lamport",
title = "The Temporal Logic of Actions",
institution = DECSRC,
type = "Research Report",
number = 79,
year = 1991
}

@techreport{lamp83,
author = "Butler W. Lampson",
title = "A Description of the {C}edar Language: A {C}edar Language 
Reference Manual",
institution = PARC,
number = "CLS--83--15",
year = 1983
}


@techreport{lang72,
author = "Bernard Lang and B. Wegbreit",
title = "Fast Compactification",
number = "25--72",
institution = "Harvard University",
address = "Cambridge, MA",
month = Nov,
year = 1972,
}


@inproceedings{lang87,
title = "Incremental Incrementally Compacting Garbage Collection",
author = "Bernard Lang and Francis Dupont",
crossref = "SIIT87",
pages = "253--263",
}

@inproceedings{lang92a,
author = {Bernard Lang and Christian Quenniac and Jos\'{e} Piquer},
title = "Garbage Collecting the World",
pages = "39--50",
crossref = "POPL92",
URL = "file://ftp.inria.fr/INRIA/Projects/icsla/Papers/gc.ps.gz",
comment = "Local Mark-sweep, plus inter-node reference counting in a manner
similar to \cite{lins91c}. Fault tolerance by dynamic grouping of nodes",
abstract = "Distributed symbolic computations involve the existence of
{\em remote references} allowing an object, local to a processor, to
designate another object located on another processor. To reclaim
inaccessible objects is the non trivial task of a distributed Garbage
Collector (GC).  We present in this paper a new distributed GC algorithm
which
\begin{enumerate}
\item is fault-tolerant,
\item is largely independent of how a processor garbage collects its
      own data space,
\item does not need centralized control nor global stop-the-world
      synchronization,
\item allows for multiple concurrent active GCs,
\item does not require to migrate objects from processor to processor and
\item eventually reclaims all inaccessible objects including
      distributed cycles.
\end{enumerate}

These results are mainly obtained through the concept of a {\em group}
of processors (or processes).
Processors of a same group cooperate together to a GC inside this group;
this GC is conservative with respect to the outside of the group.
A processor contributes to the global GC of all groups to which it
belongs. Garbage collection on small groups reclaims quickly locally
distributed garbage clusters, while garbage collection on large groups
ultimately reclaims widely distributed garbage clusters, albeit more
slowly.
Groups can be reorganized dynamically, in particular to tolerate
failures of some member processors.
These properties make the algorithm usable on very large and evolving
networks of processors.
Other than distributed symbolic computations, possible applications
include for example distributed file or database systems."
}

@inproceedings{lang91,
title = "{FRATS}: A Parallel Reduction Strategy for Shared Memory",
author = "Koen G. Langendoen and Willem G. Vree",
booktitle = "3rd international Symposium on Programming Language Implementation ans Logic Programming, Passau, Germany",
editor = "M. Wirsing and J. Maluszynski",
publisher = SV,
series = LNCS,
volume = 528,
pages = "99--110",
month = aug,
year = 1991,
}

@inproceedings{lang92,
title = "Memory Management for Parallel Tasks in Shared Memory",
author = "Koen G. Langendoen and Henk Muller and Willem G. Vree",
address = "University of Amsterdam, Netherland",
crossref = "IWMM92",
}

@inproceedings{laro98,
author = {Martin Larose and Marc Feeley},
title = {A Compacting Incremental Collector and its Performance in a Production Quality Compiler},
pages = {1--9},
crossref = {ISMM98},
URL = {http://citeseer.nj.nec.com/larose98compacting.html},
abstract = {We present a new near-real-time compacting collector and its
implementation in a production quality Scheme compiler (Gambit-C).
Our goal is to use this system as a base for an implementation of Erlang
for writing soft real-time telecommunication applications. We start
with a description of Gambit-C's memory organisation and its
blocking collector. The design and integration of the incremental
collector within Gambit-C are then explained. Finally we measure the
performance of the incremental collector and compare it to the original
blocking collector. We found that the overhead of the incremental
collector is high (a factor of 1.3 to 5) but nevertheless the collection
pauses and the compute power left for the mutator are compatible with
typical soft real-time requirements. }
}

@article{lars77,
author = "Richard G. Larson",
title = "Minimizing  Garbage Collection as A Function of Region Size",
journal = "{SIAM} Journal of Computing",
volume = 6,
number = 4,
month = Dec,
year = 1977,
pages = "663--668",
comment = {
Richard Larson's 1977 paper dealt with increasing the efficiency of a copy
collector by simply increasing the semispace ("region") sizes, and
therefore decreasing the frequency with which you must copy all of the
live objects from one region of memory to another.  This was 10 years
before Appel's much-better-known paper; not only that, but Larson's paper
gives a mathematical treatment of the tradeoff between basic efficiency
and locality issues.  (He overlooked the pathological behavior of LRU
replacement combined with a simple gc's cyclic memory reuse, though.)
}
}

@inproceedings{lars98,
author = {Paul {Per-\o{A}ke Larson} and Murali Krishnan},
title = {Memory Allocation for Long-Running Server Applications},
pages = {176--185},
crossref = {ISMM98},
abstract = {Prior work on dynamic memory allocation has largely neglected
long-running server applications, for example, web servers and mail
servers. Their requirements differ from those of one-shot applications
like compilers or text editors. We investigated how to build an allocator
that is not only fast and memory efficient but also scales well on SMP
machines. We found that it is not sufficient to focus on reducing lock
contention. Only limited improvement can be achieved this way; higher
speedups require a reduction in cache misses and cache invalidation
traffic. We then designed and prototyped a new allocator, called
Lkmalloc, targeted for both traditional applications and server
applications. LKmalloc uses several subheaps, each one with a
separate set of free lists and memory arena. A thread always allocates
from the same subheap but can free a block belonging to any subheap.
A thread is assigned to a subheap by hashing on its thread ID. We
compared its performance with several other allocators on a
server-like, simulated workload and found that it indeed scales well
and is quite fast but could use memory more efficiently.}
}

@inproceedings{laru88,
author = "James R. Larus and Paul N. Hilfinger",
title = "Detecting Conflicts Between Structure Accesses",
crossref = "PLDI88",
pages = "21--34",
}

@article{laye91,
title = "Lisp Systems in the 1990s",
author = "D. K. Layer and C. Richardson",
address = "Franz Inc., 1995 University Avenue, Berkeley, Ca, 94704",
journal = CACM,
publisher = ACM,
year = 1991,
volume = 34,
number = 9,
pages = "48--57"
}

@article{lea93,
author = {Doug Lea},
title = {The {GNU} {C++} Library},
journal = {The {C++} Report},
publisher = {ACM SIGS Publications},
year = 1993,
URL = {http://gee.cs.oswego.edu/dl/libg++paper/libg++/libg++.html}
}

@misc{lea97,
author = {Doug Lea},
title = {A Memory Allocator},
howpublished = {http://gee.cs.oswego.edu/dl/html/malloc.html},
year = 1997,
comment = {Description of Doug Lea's excellent allocator, available from
ftp://gee.cs.oswego.edu/pub/misc/malloc.c}
}
 


@phdthesis{lehu88,
author = "Serge {Le Huitouze}",
title = "Mise en Oeuvre de {P}rolog{II}/{MALI}",
school = {Universit\'{e} de Rennes I},
year = 1988,
comment = "MALI uses copying for lists of goals."
}

@inproceedings{lehu90,
author = "Serge {Le Huitouze}",
title = {A New Data Structure for Implementing Extensions to {P}rolog},
booktitle = "International Symposium on Programming Language Implementati
on and Logic Programming",
address = {Link\"{o}ping, Sweden},
pages = {136--150},
year = 1990
}

@inproceedings{lese92,
title = "Incremental Multi-Threaded Garbage Collection on Virtually Shared Memory Architectures",
author = "Thierry {Le Sergent} and Bernard Barthomieu",
address = "CNRS, France",
crossref = "IWMM92",
URL = "ftp://laas.laas.fr/pub/lcs/reports/iwmm92.ps.Z",
}

@mastersthesis{lee88,
author = "Lee, Elgin Hoe-Sing",
title = "Object Storage and Inheritance for {SELF}, a Prototype-Based Object-Ori
ented Programming Language",
school = "Stanford University",
address = "Palo Alto, CA",
month = dec,
year = 1988,
type = "Engineer's thesis"     
}

@inproceedings{lee97,
title = {Bytecode Instrumentation as an Aid in Understanding the Behaviour of {J}ava Persistent Stores},
author = {Han Bok Lee and Benjamin G. Zorn},
URL = {ftp://ftp.dcs.gla.ac.uk/pub/drastic/gc/zorn2.ps},
crossref = {OOPSLA97-gc}
}

@article{lee80,
author = "K. P. Lee",
title = "A Linear Algorithm for Copying Binary Trees Using Bounded Workspace",
journal = CACM, 
publisher = ACM,
volume = 23,
number = 3,
month = mar,
year = 1980,
pages = "159--162",
comments = {algorithm for traversing trees without a stack or mark bits},
}

@article{lee89,
author = "T. Paul Lee and R. E. Barkley",
title = "Design and Evaluation of a Watermark-based Lazy Buddy System",
journal = "Performance Evaluation Review",
volume = 17,
number = 1,
month = may,
year = 1989
}

@inproceedings{lee79,
author = "S. Lee and W. P. {De Roever} and S. Gerhart",
title = "The Evolution of List Copying Algorithms",
booktitle = "6th ACM Symposium on Principles of Programming Languages",
address = "San Antonio, Texas",
publisher = ACM,
month = jan,
year = 1979,
pages = "53--56",
comments = {proves the correctness of the link reversal algorithm by Deutsch-Schorr-Waite},
}

@inproceedings{lee00,
author = {Woo Hyong Lee and J. Morris Chang and Yusuf Hasan},
title = {Dynamic Memory Measuring Tool for {C++} Programs},
booktitle = {Proceedings of The Third IEEE Symposium on Application-Specific Systems and Software Engineering Technology (ASSET 2000)},
address = {Richardson, TX},
month = mar,
year = 2000
}

@inproceedings{lee00a,
author = {Woo Hyong Lee and J. Morris Chang and Yusuf Hasan},
title = {Evaluation of a High-performance Object Reuse Dynamic Memory Allocation Policy for {C++} Programs},
booktitle = {Proceedings of Fourth IEEE International Conference on High Performance Computing in Asia-Pacific Region},
address = {Beijing, China},
month = may,
year = 2000,
pages = {386--391}
}

@inproceedings{lerm86,
author = "C.-W. Lermen and Dieter Maurer",
title = "A Protocol for Distributed Reference Counting",
crossref = "LFP86",
pages = "343--350",
comment = "Avoids problem of premature deletion of objects at a cost of three
messages per operation.",
}


@inproceedings{lest89,
title = "An Efficient Distributed Garbage Collector Algorithm",
author = "David Lester",
crossref = "PARLE89",
}

@inproceedings{lest92,
author = "David Lester",
title = "Distributed Garbage Collection of Cyclic Structures",
booktitle = "4th International Workshop on the Parallel Implementation of
Functional Languages",
address = "Aachen",
month = sep,
year = 1992,
note = "Available from Herbert Kuchen, Lehrstuhl Informatik II, RWTH Aachen,
Ahornstr. 55, W-51000 Aachen. 
Also Glasgow Functional Programming Workshop 1993."
}

@techreport{leva99,
author = {Yossi Levanoni and Erez Petrank},
title = {A Scalable Reference Counting Garbage Collector},
number = {CS--0967},
institution = {Technion --- Israel Institute of Technology},
address = {Haifa, Israel},
month = nov,
year = 1999,
URL = {http://www.cs.technion.ac.il/users/wwwb/cgi-bin/tr-info.cgi?1999/CS/CS0967},
}

@inproceedings{leva01,
author = {Yossi Levanoni and Erez Petrank},
title = {An On-the-Fly Reference Counting Garbage Collector for {J}ava},
URL = {http://www.cs.technion.ac.il/~erez/publications.html},
crossref = {OOPSLA01}
}

@article{leve92,
author = "Willem G. Levelt and M. Frans Kaashoek and Henri E. Bal and Andrew Tanenbaum",
title = "A Comparison of Two Paradigms for Distributed Shared Memory",
journal = SPE,
publisher = Wiley,
volume = 22,
number = 11, 
pages = "985--1010",
month = Nov,
year = 1992
}

@article{leve82,
author = "B. W. Leverett and P. G. Hibbard",
title = "An Adaptive System for Dynamic Storage Allocation",
journal = SPE,
publisher = Wiley,
volume = 12,
number = 6,
month = jun,
year = 1982,
pages = "543--556"
}

@inproceedings{lewi74,
author = "T. G. Lewis and B. J. Smith and M. Z. Smith",
title = "Dynamic Memory Allocation Systems for Minimizing Internal Fragmentation
",
booktitle = "Proceedings of {ACM} Annual Conference",
publisher = ACM,
month = nov,
year = 1974,
pages = "725--728"
}

@phdthesis{lext92,
title = "Generation de Serveurs de Vues",
author = "Vincent Lextrait",
school = "University of Nice",
month = dec,
year = 1992,
address = "lextrait@hotmail.com",
comment = "Claims to have a solution to the problem of reference counting cycles",
note = "(In french)"
}

@techreport{li85,
author = "Kai Li and Paul Hudak",
title = "A New List Compaction Method",
type = "Research Report",
number = 362,
institution = "Yale University",
month = feb,
year = 1985
}

@article{li86,
author = "Kai Li and Paul Hudak",
title = "A New List Compaction Method",
journal = SPE,
publisher = Wiley,
volume = 16,
number = 2,
pages = "145--163",
month = feb,
year = 1986
}

@phdthesis{li86a,
author = "Kai Li",
title = "Shared Virtual Memory on Loosely Coupled Multiprocessors",
school = "Yale University",
year = 1986
}

@article{li89,
author = "Kai Li and Paul Hudak",
title = "Memory Coherence in Shared Virtual Memory Systems",
journal = TransCompSys,
publisher = ACM,
volume = 7,
number = 4,
pages = "321--359", 
month = Nov,
year = 1989
}

@inproceedings{li90,
author = "Kai Li",
title = "Real-Time Concurrent Collection in User Mode",
crossref = "OOPSLA90-gc",
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/GC90/Li.ps.Z",
abstract = "We previously presented a real-time, concurrent 
garbage-collection algorithm that uses the virtual memory page 
protection hardware to synchronize collector threads and mutator 
threads.  The algorithm requires the mutator threads to access 
protected pages that prevent collector threads from accessing.  
This paper investigates three other alternatives to achieve such 
a goal:  page-copying, multiple address mapping, and page sharing 
in different address spaces.  We will present our  experiment 
with the page-copying version and compare it with the kernel- 
mode, simple stop-and-copy, and sequential real-time versions."
}



@techreport{lieb81,
title = "A Real-Time Garbage Collector Based on the Lifetimes of Objects",
author = "Henry Lieberman and Carl E.Hewitt",
type = "{AI} Memo",
number = "569a",
institution = "{MIT}",
month = apr,
year = 1981,
URL = "ftp://publications.ai.mit.edu/ai-publications/pdf/AIM-569a.pdf",
comment = {Previously cited as "A Real-Time Garbage Collector That Can Recover Temporary Storage Quickly"},
}

@article{lieb83,
author = "Henry Lieberman and Carl E Hewitt",
title = "A Real-Time Garbage Collector Based on the Lifetimes of Objects",
journal = CACM,
publisher = ACM,
volume = "26(6)",
pages = "419--429",
year = 1983,
URL = {http://lieber.www.media.mit.edu/people/lieber/Lieberary/GC/Realtime/Realtime.html},
abstract = {The authors, motivated by the need for efficient management of short-lived
objects in object-oriented systems for AI applications, propose a new
garbage collection algorithm. The algorithm which is proposed has the
objective of differentiating the special case of garbage collection for
objects with short lives. Such differentiation, the paper argues, will also
improve the garbage collection for long-lived objects, since less effort is
made in considering these objects for reclamation.
The algorithm proposed is an extension of a garbage collection algorithm
proposed by Baker. The most important feature of Baker's algorithm is
that elementary object creation and object access time take a bounded
amount of time regardless of the memory size. It is a real-time algorithm.
As an enhancement to Baker's algorithm, the authors propose dividing the
address space into small regions, with each region being composed of a set
of pages. This division is different from the Baker algorithm, which
divides the address space into two regions. The second enhancement to Baker's
algorithm uses the finer divisions of the address space to vary the rate
of garbage collection for each region according to the age of the region.
The criteria for determining the rate are motivated by the observation that
newer regions contain a higher percentage of garbage.
The paper is excellently constructed. It was, however, disappointing not to
find comparative measurements for performance, region fragmentation, the
impact of locality, the impact of programming style, etc. Nevertheless, the
paper is recommended.}
}

@inproceedings{lim98,
author = {Tian F. Lim and Przemyslaw Pardyak and Brian N. Bershad},
title = {A Memory-Efficient Real-Time Non-Copying Garbage Collector},
pages = {118--129},
booktitle = "Proceedings of the First International Symposium on Memory Management",
address = {Vancouver, BC, Canada},
volume = "34(3)",
month = oct,
year = 1998,
abstract = {Garbage collectors used in operating systems such as SPIN and
embedded systems such as Java and Inferno must operate with limited
resources and minimize their impact on application performance.
Consequently, they must maintain short real-time pauses, low
overhead, and a small memory footprint. Most garbage collectors are
not adequate because they are either not real-time or they require
larger heaps because they trade space for time. For example,
Treadmill uses segregated free lists to allocate and reclaim memory in
constant time but at the cost of under-utilizing memory. We have
implemented a new version of the Treadmill collector and used it in the
SPIN extensible operating system kernel. We chose Treadmill for its
excellent real-time latencies and low overhead. We improve its poor
memory utilization by using real- time page-level management
techniques that reduce the fragmentation caused by segregated free
lists. We use page-wise collection to locate pages of free memory,
which are dynamically reassigned between free lists as needed. We
use virtual memory to dynamically remap free pages into continuous
ranges. Our experiments demonstrate that we have substantially
improved memory utilization without compromising latency or
overhead, and that the new collector performs very well for SPIN's
workloads.}
}

@manual{limb97,
title = "The {L}imbo Programming Language ",
organization = "Lucent Technologies Inc",
year = 1997,
URL = "http://inferno.lucent.com/inferno/",
abstract = "Limbo is a programming language intended for applications
running distributed systems on small computers. It supports modular
programming, strong type checking at compile- and run-time,
interprocess communication over typed channels, automatic garbage
collection, and simple abstract data types. It is designed for safe
execution even on small machines without hardware memory protection.
In its initial implementation for the Inferno operating system, object
programs generated by the Limbo compiler run using an interpreter for a
fixed virtual machine. Inferno and its accompanying virtual machine run
either stand-alone on bare hardware or as an application under
conventional operating systems like Unix, Windows 95, Windows NT, and
Plan 9. For several architectures, including Intel x86 and MIPS, Limbo
object programs are transformed on-the-fly into instructions for the
underlying hardware. "
}

@misc{lin92,
author = "Lin, Sheng-Lien",
title = "Performance Evaluation of a Generation Scavenging Algorithm",
year = 1992
}

@inproceedings{linc92,
title = "Operational Aspects of Linear Lambda Calculus",
author = "Patrick Lincoln and John Mitchell",
pages = "235--246",
booktitle = "Proceedings, Seventh Annual IEEE Symposium on Logic in Computer Science",
year = 1992,
month = jun,
address = "Santa Cruz, California",
publisher = IEEE
}


@inproceedings{lind87,
author = "T. G. Lindholm and R. A. O'Keefe",
title = "Efficient Implementation of a Defensible Semantics for Dynamic {P}rolog Code",
crossref = "ICLP87",
}

@article{lind73,
author = "Gary Lindstrom",
title = "Scaning List Structures Without Stacks or Tag Bits",
journal = IPL,
publisher = NH,
volume = 2,
number = 2,
month = jun,
year = 1973, 
pages = "47--51",
comments = {algorithm for traversing trees without a stack or mark bits},
}


@article{lind74,
author = "Gary Lindstrom",
title = "Copying List Structures Using Bounded Workspace",
journal = CACM, 
publisher = ACM,
volume = 17,
number = 4,
month = apr,
year = 1974,
pages = "199--202",
comments = {algorithm for copying lists without using a stack or mark bits.
It differs from the moving algorithms in that the altered contents of old lists
are later restored to their original values.},
}


@article{lind81,
title = "Referencing and Retention in Block-Structured Coroutines",
author = "Gary Lindstrom and Mary Lou Soffa",
journal = toplas,
publisher = ACM,
year = 1981,
month = jul,
volume = 3,
number = 3,
pages = "263--292",
comment = "Don't know if this is useful or not"
}

@inproceedings{lind94,
author = {Anders Lindstrom and Alan Dearle and di Bona, Rex and J. Matthew Farrow and Frans Henskens and John Rosenberg and Francis Vaughan},
title = {A Model for User-Level Memory Management in a Persisitent Distributed Environment},
editor = {Gopal Gupta},
booktitle = {Proceedings of the Seventeenth Annual Computer Science COnference, {ACSC--17}, Part {B}},
pages = {343--354},
address = {Christchurch, New Zealnad},
month = jan,
year = 1994,
URL = {http://docs.dcs.napier.ac.uk/DOCS/GET/linstrom94a/document.html}
}

@article{lins90a,
author = "Rafael D. Lins", 
title = "Cyclic Reference Counting with Lazy Mark-Scan",
journal = IPL,
publisher = NH,
volume = 44,
number = 4,
pages = "215--220",
year = 1992,
URL = "ftp://unix.hensa.ac.uk/pub/misc/ukc.reports/comp.sci/reports/26-92.ps.Z",
note = "Also Computing Laboratory Technical Report 75, University of Kent,
July 1990",
comment = {Optimises \cite{mart90}}
}


@techreport{lins91a,
author = {Rafael D. Lins and M\'{a}rcio A. Vasques}, 
title = "A Comparative Study of Algorithms for Cyclic Reference Counting",
institution = UKC,
number = 92, 
month = aug,
year = 1991,
URL = "ftp://unix.hensa.ac.uk/pub/misc/ukc.reports/comp.sci/reports/",
comment = {Compares the performance of \cite{mart90} and
several control strategies of \cite{lins90a}.
Also extends \cite{glas87} to work with cyclic structures.}
}


@article{lins91b,
author = "Rafael D. Lins", 
title = "A Shared Memory Architecture for Parallel Cyclic Reference 
Counting",
journal = "Microprocessing and Microprogramming",
volume = "32",
pages = "53--58",
publisher = "North-Holland",
month = sep,
year = 1991,
comments = "Describes a shared memory architecture based on
reference counting algorithms described in \cite{mart90} and
\cite{lins90}"
}


%do not change year
@inproceedings{lins91c,
author = "Rafael D. Lins and Richard E. Jones", 
title = "Cyclic Weighted Reference Counting",
booktitle = "Procedings of {WP \& DP'93} Workshop on Parallel and
Distributed Processing",
address = {Sofia, Bulgaria},
editor = "K. Boyanov",
publisher = NH,
pages = {369--382},
month = may,
year = 1993,
institution = UKC,
note = "Also Computing Laboratory Technical Report 95, University of Kent,
December 1991",
comment = "Allows weighted reference counting 
\cite{beva87,wats87} to work with cyclic structures.
Based on algorithms described in \cite{mart90,lins90a}"
}


@article{lins92,
author = "Rafael D. Lins", 
title = "A Multi-processor Shared Memory Architecture for Parallel Cyclic Reference Counting",
journal = "Microprocessing and Microprogramming",
volume = "35",
pages = "563--568",
publisher = "North-Holland",
month = sep,
year = 1992,
comments = {Generalises the architecture presented in \cite{lins91a}.}
}

@techreport{lins92c,
author = "Lins, Rafael D ",
institution = "Computing Laboratory, University of Kent",
title = "Generational Cyclic Reference Counting",
year = 1992,
URL = "ftp://unix.hensa.ac.uk/pub/misc/ukc.reports/comp.sci/reports/22-92.ps.Z",
month = sep,
number = "22-92"
}

@inproceedings{lins94,
author = "Lins, Rafael D. and Frank Dehne",
title = "Distributed Reference Counting",
booktitle = "Proceedings of the 1994 Canada--France Conference on Parallel Computing",
year = 1994,
pages = "95--100",
month = may,
series = LNCS,
publisher = SV,
number = 805,
comment = "Based on Lins' tri-colour mark-scan but uses process spawning.
Despite alleged proof, the algorithm is fundamentally flawed. It is simple
to provide counter-examples and, we believe, impossible to correct (in the
spirit of the algorithm)."
}

@article{lins02,
author = {Lins, Rafael D.},
title = {An Efficient Algorithm for Cyclic Reference Counting},
journal = IPL,
volume = 83,
pages = {145--150},
year = 2002,
comment = {Unconvincing paper marred by careless(?) errors in the algorithm.}
}

@inproceedings{lisk86,
title = "Highly Available Distributed Services and Fault-Tolerant Distributed 
Garbage Collection",
author = "Barbara Liskov and Rivka Ladin",
pages = "29--39",
booktitle = "Proceedings of the Fifth Annual ACM Symposium on the 
Principles on Distributed Computing", 
address = "Calgary", 
month = aug,
editor = "J. Halpern",
publisher = ACM,
year = 1986,
comment = "Local mark-sweep + highly available centralised service
which detects cycles."
}

@phdthesis{llam91,
author = "Llames, Rene Lim",
title = "Performance Analysis of Garbage Collection and Dynamic 
Reordering in a LISP System",
year = 1991, 
school = "University of Illinois at Urbana-Champaign"
}

@inproceedings{lo98,
author = {Chia-Tien Dan Lo and W. Srisa-an and J. Morris Chang},
title = {Boundary Analysis for Buddy Systems},
booktitle = {Proceedings of 1998 International Computer Symposium (Computer Architecture Track)},
address = {Tainan, Taiwan},
month = dec,
year = 1998,
pages = {96--103}
}

@inproceedings{lo00,
author = {Chia-Tien Dan Lo and W. Srisa-an and J. Morris Chang},
title = {Page Replacement Performance in Garbage Collection Systems},
booktitle = {Proceedings of 13th International Conference on Parallel and Distributed Computing Systems},
address = {Las Vegas, NA},
month = aug,
year = 2000,
pages = {374--379}
}

@inproceedings{lo00a,
author = {Chia-Tien Dan Lo and W. Srisa-an and J. Morris Chang},
title = {A Quantitative Simulator for Dynamic Memory Managers},
booktitle = {Proceedings of IEEE International Symposium on Performance Analysis of Systems and Software},
address = {Austin, TX},
publisher = IEEE,
month = apr,
year = 2000,
pages = {64--69},
URL = {http://ieeexplore.ieee.org/iel5/6790/18223/00842283.pdf}
}

@article{lo01,
author = {Chia-Tien Dan Lo and W. Srisa-an and J. Morris Chang},
title = {A Study of Page Replacement Performance in Garbage Collection Heap},
journal = {Journal of Systems and Software},
pages = {235--245},
publisher = ES,
volume = 58,
number = 3,
month = sep,
year = 2001
}

@inproceedings{lo01a,
author = {Chia-Tien Dan Lo and J. Morris Chang},
title = {A Multithreaded Concurrent Generational Garbage Collector for {J}ava},
crossref = {OOPSLA01},
note = {Doctoral Symposium}, 
pages = {7--9}
}

@inproceedings{lo02,
author = {Chia-Tien Dan Lo and W. Srisa-an and J. Morris Chang},
title = {A High Performance Garbage Collector for {J}ava},
booktitle = {Proceeding of the 2002 International Computer Symposium, ICS 2002},
address = {National Dong Hwa University, Hualien, Taiwan}, 
month = dec, 
year = 2002
}

@inproceedings{lo02a,
author = {Chia-Tien Dan Lo and W. Srisa-an and J. Morris Chang},
title = {A Multithreaded Concurrent Garbage Collector which Parallelizes the new Instruction in {J}ava},
booktitle = {International Parallel and Distributed Processing Symposium}, 
address = {Fort Lauderdale, FL}, 
month = apr, 
year = 2002, 
pages = {59--64}
}

@inproceedings{lo02b,
author = {Chia-Tien Dan Lo and W. Srisa-an and J. Morris Chang},
title = {A Performance Comparison between Stop-the-World and Multithreaded Concurrent Garbage Collection for {J}ava},
booktitle = {21st IEEE International Performance, Computing, And Communications Conference (IPCCC 2002)}, 
address = {Phoenix, AZ},  
month = apr, 
year = 2002, 
pages = {301--308}
}

@article{lo03,
author = {Chia-Tien Dan Lo and W. Srisa-an and J. M. Chang},
title = {Who Is Collecting Your {J}ava Garbage?}, 
journal = {IEEE IT Professional}, 
volume = 5, 
number = 2, 
month = apr,
year = 2003, 
pages = {44--50}
}

@article{lo04,
title = {The Design and Analysis of a Quantitative Simulator for Dynamic
Memory Management},
author = {Chia-Tien Dan Lo and W. Srisa-an and J. M. Chang},
journal = JSS,
volume = 72,
number = 3,
month = aug,
year = 2004,
pages = {443--453},
URL = {http://www.sciencedirect.com/science?_ob=GatewayURL&_origin=CONTENTS&_method=citationSearch&_piikey=S0164121203000955&_version=1&md5=8cab0058538ccf406a45cf151b2f4bfe},
}


@inproceedings{loid00,
author = {H-W. Loidl},
title = {Investigating the Memory Management in a Parallel Graph Reducer},
pages = {185-200},
editor = {M. Mohnen and P. Koopman},
booktitle = {Proceedings of the 12th International Workshop on Implementation of Functional Languages},
organization = {RWTH Aachen},
year = 2000,
series = {{Aachener Informatik Berichte}},
number = {AIB-00-7},
}

@article{lome75,
author = "D. B. Lomet",
title = "Scheme for Invalidating References to Freed Storage",
journal = "IBM Journal of Research and Development",
pages = "26--35",
month = jan, year=1975,
comment = "No inter-area links though he maintains objects in regions"
}

@inproceedings{loub95,
author = {Sylvain Louboutin and Vinny Cahill},
title = {On Comprehensive Global Garbage Detection},
booktitle = {Proceeding of the European Research Seminar on Advances in
Distributed Systems (ERSADS '95)},
publisher = {INRIA/IMAG},
month = apr,
year = 1995,
pages = {208--213},
address = {Alpes d'Huez, France},
URL = {ftp://ftp.dsg.cs.tcd.ie/pub/doc/TCD-CS-95-11.ps.gz},
note = {Also technical report TCD-CS-95-11, Department of Computer Science, Trinity College Dublin},
abstract = {The experience gained with centralised garbage collection
(GC) techniques has left a legacy of assumptions, expectations
and tradeoffs, which may lead one to overlook some Global
Garbage Detection (GGD) approaches. We argue that it is not
necessary to give up on comprehensiveness in order to achieve
a high degree of concurrency and scalability, although this
may be at a price which is not palatable in a centralised
system. For instance, much higher detection latency or space
overhead, at least in terms of worst case scenarios, is
acceptable in a large distributed system. We are currently
implementing a variation of Schelvis' algorithm on Amadeus
(taking advantage of Amadeus' object clustering ability), to
conduct an empirical evaluation of the actual impact of such
tradeoffs.}
}


@techreport{loub95a,
author = "Sylvain Louboutin and Vinny Cahill",
title = "Lazy, per Cluster Log-Keeping Mechanism for Global Garbage Detection on {Amadeus}",
institution = "Department of Computer Science, Trinity College",
year = 1995,
number = "TCD-CS-95-13",
month = may,
URL = "ftp://ftp.dsg.cs.tcd.ie/pub/doc/TCD-CS-95-13.ps.gz",
abstract = "This document describes a log-keeping mechanism designed to
support Global Garbage Detection on Amadeus. This log-keeping
mechanism maintains, on a per site basis, a conservative
approximation of the actual root set for that site. Exchanges
of object references across site boundaries are logged on a
per cluster basis to cope with the dynamic nature of the
overall object graph. Clustering also determines the
granularity of the information logged. Furthermore, this
mechanism proceeds lazily, that is, is does not require either
any additional messages to be exchanged (and thus does not
cause any race condition), nor trigger any object fault which
would not otherwise have occurred. This mechanism makes it
possible to implement at a reasonable cost, a higher level
comprehensive, although scalable, Global Garbage Detection
algorithm.",
}

@inproceedings{loub95b,
author = "Sylvain Louboutin and Vinny Cahill",
title =  "A Lazy Log-Keeping Mechanism for Comprehensive Global Garbage Detection on {Amadeus}",
booktitle = {OOIS (Object-Oriented Information Systems) '95},
publisher = SV,
address = "London",
pages = {118--132},
year = 1995,
month = dec,
URL = "ftp://ftp.dsg.cs.tcd.ie/pub/doc/dsg-92.ps.gz",
note = {Technical report TCD--CS--95--11},
abstract = "Global Garbage Detection (GGD) in object-oriented distributed
systems requires that each application process maintains some
information in support of GGD. Maintaining this information is
known as log-keeping. In this paper we describe a
low-overhead, log-keeping mechanism which proceeds lazily and
avoids race conditions while nevertheless maintaining enough
information for comprehensive GGD to take place.",
}

@inproceedings{loub97,
title = {Comprehensive Distributed Garbage Collection by Tracking Causal Dependencies of Relevant Mutator Events},
author = {Sylvain R.Y. Louboutin and Vinny Cahill},
booktitle = {Proceedings of ICDCS'97 International Conference on Distributed Computing Systems},
publisher = IEEE,
year = 1997,
URL = {ftp://ftp.dsg.cs.tcd.ie/pub/doc/dsg-106.ps.gz}
}

@phdthesis{loub98,
author = {Sylvain R.Y. Louboutin},
title = {A Reactive Approach to Comprehensive Global Garbage Detection},
school = {Trinity College, Dublin},
year = 1998, 
ISBN = {1-58112-044-3},
URL = {http://www.dissertation.com/library/1120443a.htm},
comment = {Louboutin says that the algorithm as described in the dissertation is a bit 
more complete than the one described in \cite{loub97}}
}

@inproceedings{lowr02,
author = {Lowry, M.C. and Munro, David S.}, 
title = {Safe and Complete Distributed Garbage with The {T}rain Algorithm},
booktitle = {Proceedings of the 2002 International Conference on Parallel and Distributed Systems (ICPADS'2002)}, 
address = {Taiwan}, 
month = dec,
year = 2002, 
pages = {651--658}
}

@techreport{lync90,
author = "N. A. Lynch",
title = "Multivalued Possibilities Mappings",
institution = "MIT Laboratory for Computer Science",
type = "Technical Memo",
number = "MIT/LCS/TM--422",
month = aug,
year = 1990,
URL = "ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/listings/abstracts/TM-422.html"
}

@article{lyon88,
title = "Tagless Marking that is Linear over Subtrees",
author = "G. Lyon",
journal = IPL,
publisher = NH,
volume = 27,
number = 1,
pages = "23--28",
year = "1988",
abstract = {A new tagless marking algorithm traverses and marks nodes of a
directed binary graph, initiating tests for cycles only as need arises.
Because trees do not trigger any tests, the algorithm takes linear time on 
any graph subtree.}
}


@inproceedings{macl91,
author = "Robert A. MacLachlan",
title = "A System Model of Memory Management",
crossref = "OOPSLA91-gc",
}


@techreport{mada92,
author = "Peter W. Madany and Nayeem Islam and Panos Kougiouris and Roy H.
Campbell",
title = "Reification and Reflection in {C++}: An Operating Systems
Perspective",
institution = "Department of Computer Science, University of Illinois at
Urbana-Champaign",
number = "UIUCDCS--R--92--1736",
month = mar,
year = 1992,
abstract = "The paper discusses using reification (the
representation of an attribute of an object-oriented
program such as method dispatch, inheritance, or object
structure within the program) and reflection (the
ability to make attributes like method invocation,
interface, inheritance, object implementation the
subject of computation) in Choices. Reification is
used, for example, to modify the behaviour of pointers
so reference-counting can be done safely. The system
includes inheritance and classes as run-time entities,
allowing dynamic extension of the system functions."
}

@techreport{maed93,
author = "Munenori Maeda and Hiroki Konaka and Yutaka Ishikawa and Takashi Tomokiyo and Atsushi Hori",
title = "An Incremental, Weighted, Cyclic Reference Counting for Object-based Languages",
institution = "Tsukuba Research Center",
year = 1993,
type = "RWCP Technical Report",
number = "P--93--001",
comment = "WRONG. Based on Brownbridge! But gives each object an ordinal number
in order to copy pointer strengths correctly."
}

@inproceedings{maed95,
title = "On-The-Fly Global Garbage Collection Based on Partly Mark-Sweep",
author = "Munenori Maeda and Hiroki Konaka and Yutaka Ishikawa and Takashi Tomokiyo and Atsushi Hori and Jorg Nolte",
address = "Tsukuba Research Center, Real World Computing Partnership, Tsukuba, J
apan",
crossref = "IWMM95",
comment = "This is simply Cyclic Weighted Reference Counting 
\cite{jone92,jone93} and comments in mail from REJ"
}

@inproceedings{maed97,
author = {Munenori Maeda and Yutaka Ishikawa},
title = {{GLEANER}-7: A Hybrid Distributed {GC} Algorithm},
URL = {ftp://ftp.dcs.gla.ac.uk/pub/drastic/gc/maeda.ps},
crossref = {OOPSLA97-gc}
}

@unpublished{maed92,
author = "Roman E. Maeder",
title = "A Provably Correct Reference Count Scheme for a Symbolic 
Computation System",
note = "In unpublished form, cited by Edelson",
year = 1992
}


@techreport{maek87,
author = "Maekawa, Mamoru and Ohta, Masataka and Shimizu, Kentaro",
title = "Garbage Collection for Multimedia Processing",
institution = "University of Tokyo",
year = 1987,
number = "87-01"
}

@inproceedings{mage04,
title = {Scalable Lock-Free Dynamic Memory Allocation}, 
author = {Maged Michael},
crossref = {PLDI04}
}

@inproceedings{magn95,
title = "Garbage Collection for Control Systems",
author = "Boris Magnusson and Roger Henriksson",
address = "Department of Computer Science, Lund University, Lund, Sweden",
crossref = "IWMM95",
URL = "ftp://mjolner.dna.lth.se/HD/ftp/pub/papers/LU-CS-TR.95-154.ps"
}

@techreport{magn95a,
title = "Garbage Collection for Hard Real-Time Systems",
author = "Boris Magnusson and Roger Henriksson",
institution = Lund,
number = "95--153",
URL = "ftp://mjolner.dna.lth.se/HD/ftp/pub/papers/LU-CS-TR.95-153.ps",
year = 1995
}

@article{mahe61,
author = "R. J. Maher",
title = "Problems of Storage Allocation in a Multiprocessor Multiprogrammed
System",
journal = CACM,
publisher = ACM,
volume = 4,
number = 10,
month = oct,
year = 1961,
pages = "421--422"
}

@mastersthesis{mahe92,
author = "Umesh Maheshwari",
title = "Distributed Garbage Collection in a Client--Server Transaction System",
school = "Department of Electrical Engineering and Computer Science, Massachuset
ts Institute of Technology",
year = 1992
}

@inproceedings{mahe93,
author = "Umesh Maheshwari",
title = "Distributed Garbage Collection in a Client--Server Persistent Object System",
crossref = "OOPSLA93-gc",
}

@techreport{mahe93a,
author = "Umesh Maheshwari",
title = "Distributed Garbage Collection in a Client--Server, Transactional, Persistent Object System",
institution = MIT,
number = "MIT/LCS/TR--574",
URL = "ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/listings/abstracts/TR-574.html",
year = 1993,
month = feb
}

@inproceedings{mahe94,
author = "Umesh Maheshwari",
title = " Fault-Tolerant Distributed Garbage Collection in a Client-Server 
Object-Oriented Database",
booktitle = "Third International Conference on Parallel and Distributed Information Systems, Austin",
URL = {ftp://pion.lcs.mit.edu/pub/thor/dgc.ps.gz},
month = sep,
year = 1994
}

@inproceedings{mahe95,
title = "Collecting Cyclic Distributed Garbage by Controlled Migration",
author = "Umesh Maheshwari and Barbara Liskov",
booktitle = "Proceedings of PODC'95 Principles of Distributed Computing",
URL = {http://www.pmg.lcs.mit.edu:80/~umesh/pubs/distance.ps.gz},
year = 1995
}

@inproceedings{mahe97,
title = "Collecting Cyclic Distributed Garbage by Back Tracing",
author = "Umesh Maheshwari and Barbara Liskov",
booktitle = "Proceedings of PODC'97 Principles of Distributed Computing",
address = {Santa Barbara, CA},
publisher = ACM,
pages = {239--248},
URL = {http://www.pmg.lcs.mit.edu:80/~umesh/pubs/backtracing.ps.gz},
year = 1997
}

@techreport{mahe97a,
title = "Partitioned Garbage Collection of a Large Object Store",
author = "Umesh Maheshwari and Barbara Liskov",
institution = MIT,
number = {MIT/LCS/TR--699},
URL = {http://www.pmg.lcs.mit.edu:80/~umesh/pubs/gcor_tr.ps.gz},
year = 1997, 
note = {This report contains an obsolete proposal. See \cite{mahe97b}}
}

@inproceedings{mahe97b,
title = "Partitioned Garbage Collection of a Large Object Store",
author = "Umesh Maheshwari and Barbara Liskov",
booktitle = "Proceedings of SIGMOD'97",
URL = {http://www.pmg.lcs.mit.edu:80/~umesh/pubs/gcor_sigmod97.ps.gz},
year = 1997
}

@phdthesis{mahe97c,
title = {Garbage Collection in a Large, Distributed, Object Store},
author = "Umesh Maheshwari",
school = MITLCS,
month = sep,
year = 1997,
note = {Technical Report MIT/LCS/TR-727},
URL = {http://www.pmg.lcs.mit.edu:80/~umesh/pubs/phd_tr.ps.gz}
}

@inproceedings{mais92,
author = {Julien Maisonneuve and Marc Shapiro and Pierre Collet},
title = {Implementing References as Chains of Links},
crossref = "IWOOOS92"
}

@phdthesis{mais96,
author = {Julien Maisonneuve},
title = {Hobbes: un mod\`{e}le de liaison de r\'{e}f\'{e}rences r\'{e}parties},
school = {Universit\'{e} Paris 6, Pierre et Marie Curie},
month = oct,
year = 1996
}

@inproceedings{makh00,
author = {Henning Makholm},
title = {A Region-based Memory Manager for {P}rolog},
crossref = {ISMM2000},
abstract = {
We extend Tofte and Talpin's region-based model for memory
management to support backtracking and cuts, which makes it suitable for
use with Prolog and other logic programming languages. We describe how
the extended model can be implemented and report on the performance of a
prototype implementation. The prototype implementation performs well
when compared to a garbage-collecting Prolog implementation using
comparable technology for non-memory-management issues. 
}
}

@techreport{makp91,
title = "Structuring Distributed Applications as Fragmented Objects",
author = " Mesaac Makpangou and Yvon Gourhant and Jean-Pierre {Le Narzul} and Marc Shapiro",
number = "Rapport de Recherche INRIA 1404",
institution = "INRIA",
month = feb,
year = 1992,
address = "nelly@sor.inria.fr, anonymous FTP nuri.inria.fr [128.93.1.26]"
}


@inproceedings{manc91,
author = "Luigi V. Mancini and Vittoria Rotella and Simonetta Venosa",
title = "Copying Garbage Collection for Distributed Object Stores",
booktitle = "Proceedings ot the Tenth Symposium on Reliable Distributed 
Systems, Pisa",
month = sep,
year = 1991,
comment = "Node-group collector"
}


@article{manc91a,
author = "Luigi V. Mancini and S. K. Shrivastava",
title = "Fault-Tolerant Reference Counting for Garbage Collection in 
Distributed Systems",
journal = CompJ,
publisher = BCS,
volume = 34,
number = 6,
pages = "503--513",
month = dec,
year = 1991,
}


@inproceedings{mara91,
author = "L. Maranget",
title = "{GAML}: A Parallel Implementation of Lazy {ML}",
crossref = "FPCA91",
pages = "102--123",
}

@article{marg71,
author = "B. H. Margolin and R. P. Parmelee and M. Schatzoff",
title = "Analysis of Free-Storage Algorithms",
journal = ISJ,
publisher = IBM,
volume = 10,
number = 4,
pages = "283--304",
year = 1971
}

@inproceedings{mark94,
title = "The Use of Reference Counters in Update and Invalidate Based Coherent Memory",
author = "Evangelos P. Markatos and Catherine E. Chronaki",
crossref = "PARLE94",
}

@inproceedings{marq89,
title = "Extending the Operating System to Support an Object-Oriented Environment",
author = {Jos\'{e} Alves Marques and Paulo Guedes},
crossref = "OOPSLA89",
pages = "113--122"
}

@techreport{marq90,
author = {Jos\'{e} Alves Marques and Paulo Guedes and Pedro Sousa and Paulo 
Ferreira and Jos\'{e} Monge and Andr\'{e} Z\'{u}quete and Manuel Sequeira},
title = "{IK} Implementation Report",
institution = "INESC, Portugal",
number = "INESC--TR--0013",
year = 1990,
month = jul,
note = "Extended description of system described in \cite{ferr90}."
}



@incollection{mars71,
author = "S. Marshall",
title = "An {A}lgol--68 Garbage Collector",
crossref = "Algol68",
pages = "239--243",
comments = {variant of Deutsch--Schorr--Waite algorithm for varisized cells.},
}


@article{mart82,
title = "An Efficient Garbage Compaction Algorithm",
author = "Johannes J. Martin",
journal = CACM,
publisher = ACM,
year = 1982,
month = Aug,
volume = 25,
number = 8,
pages = "571--581"
}


@article{mart90,
author = "A. D. Martinez and R. Wachenchauzer and Rafael D. Lins", 
title = "Cyclic Reference Counting with Local Mark-Scan",
journal = IPL,
publisher = NH,
volume = "34",
pages = "31--35",
year = 1990,
comments = {Presents a general garbage collection algorithm based on
reference counting, which deals with cyclic data structures, and proves its
correctness.}
}


@inproceedings{mate92,
title = "Efficient Implementation for Coroutines",
author = "L. Mateu",
address = "Universidade de Chile",
crossref = "IWMM92",
}

@article{mato98,
title = {A Taxonomy of Distributed Termination Detection Algorithms},
author = {Jeff Matocha and Tracy Camp},
journal = {Journal of Systems and Software},
pages = {207--221},
volume = 43,
number = 3,
month = nov,
year = 1998,
URL = {http://www.elsevier.nl/locate/jnlnr/07735}
}


@article{mats87,
title = "{SYNAPSE} --- A Multi-Microprocessor {L}isp Machine With Parallel 
Garbage Collector",
author = "Shogo Matsui and Yoshinobu Kato and Shinsuke Teramura and Tomoyuki Tanaka 
and Nobuyuki Mohri and Atsushi Maeda and Masakazu Nakanishi",
institution = "Keio University, Department of Mathematics, 
Japan,  Ricoh Ltd, Research and Development Lab,
Yokohama, Japan",
journal = LNCS,
publisher = SV,
year = 1987,
volume = 269,
pages = "131--137"
}

@inproceedings{mats95,
title = "Complementary Garbage Collector",
author = "Shogo Matsui and Yoshio Tanaka and Atsushi Maeda and Masakazu Nakanishi",
address = "Kanagawa University, Hiratsuka, Japan, and Keio University, Yokohama",
crossref = "IWMM95",
URL = {http://citeseer.nj.nec.com/84046.html},
}

@inproceedings{mats91,
author = {Satoshi Matsuoka and Shin'ichi Furuso and Akinori Yonezawa},
title = {A Fast Parallel Conservative Garbage Collector for Concurrent Object-oriented Systems},
crossref = {IWOOOS91},
pages = {87--93},
URL = {ftp://ftp.yl.is.s.u-tokyo.ac.jp/pub/papers/woos91-gc-a4.ps.Z}
}

@article{matt87,
author = {Friedmann Mattern},
title = {Algorithms for Distributed Termination Detection},
journal = {Distributed Computing},
volume = 2,
pages = {161--175},
year = 1987
}

@article{matt89,
author = {Friedmann Mattern},
title = {Global Quiescence Detection based on Credit distribution and Recovery},
journal = IPL,
volume = 30,
number = 4,
pages = {195--200},
year = 1989
}

@inproceedings{matt89a,
author = {Friedmann Mattern},
title = {Virtual Time and Global States of Distributed Systems},
booktitle = {International Workshop on Parallel and Distributed Algorithms},
editor = {M. Cosnard and others},
address = {Amsterdam},
pages = {215--226},
publisher = ES,
year = 1989
}


@inproceedings{matt95,
title = "{LEMMA}: A Distributed Shared Memory with Global and Local Garbage Coll
ection",
author = "David C. J. Matthews and Thierry {Le Sergent}",
address = "Department of Computer Science, University of Edinburgh, Edinburgh, and La
boratoire d'Analyse et d'Architecture des Systemes du Centre National de la
Recherche Scientifique, Toulouse",
crossref = "IWMM95",
}

@article{matt70,
author = "R. L. Mattson and J. Gecsei and D. R. Slutz and I. L. Traiger",
title = "Evaluation Techniques for Storage Hierarchies",
journal = ISJ,
publisher = IBM,
volume = 9,
year = 1970,
pages = "78--117"
}

@inproceedings{mazu00,
author = "Nancy Mazur and Gerda Janssens and Maurice Bruynooghe",
title = "A Module Based Analysis for Memory Reuse in {M}ercury",
booktitle = "Computational Logic",
pages = "1255-1269",
year = "2000",
url = "http://citeseer.nj.nec.com/379252.html" 
}
    
@inproceedings{mazu01,
author = {Nancy Mazur and Peter Ross and Gerda Janssens and Maurice Bruynooghe},
title = {Practical Aspects for a Working Compile Time Garbage Collection System for {M}ercury},
booktitle = {International Conference on Logic Programming},
pages = {105--119},
year = 2001,
url = {http://citeseer.nj.nec.com/mazur01practical.html}
}

@article{mcbe63,
author = "J. Harold McBeth",
title = "On the Reference Counter Method",
journal = CACM,
publisher = ACM,
volume = 6,
number = 9,
month = Sep,
pages = 575,
year = 1963,
comments = {First paper to report the inadequacy of reference counting \cite{coll60}
for cyclic structures.  }
}
 

@techreport{mcca59,
title = {Artificial Intelligence, Quarterly Progress Report no. 53},
author = {John McCarthy and Marvin Minsky},
institution = {Research Laboratory of Electronics at MIT},
month = apr,
year = 1959
}

@article{mcca60,
author = "John McCarthy",
title = "Recursive Functions of Symbolic Expressions and their Computation by
Machine",
journal = CACM,
publisher = ACM,
volume = 3,
year = 1960,
pages = "184--195",
comment = {The classical Mark-Sweep algorithm.}
}


@manual{mcca62,
author = "John McCarthy and others",
title = "{L}isp 1.5 Programmer's Manual",
publisher = MIT,
year = 1962,
}


@incollection{mcca78,
author = "John McCarthy",
title = "History of {LISP}",
booktitle = "History of Programming Languages",
editor = "Richard L. Wexelblat",
chapter = "IV",
pages = "173--197",
publisher = "ACM Monograph",
year = 1981
}

@incollection{mccu83,
author = "P. L. McCullough",
title = "Implementing the {S}malltalk-80 System: the {T}ektronix Experience",
crossref = "Smalltalk-BHWA",
pages = "59--78",
}

@article{mcdo98,
title = {Reducing Garbage in {J}ava},
author = {Charles E. McDowell},
journal = SIGPLAN,
volume = 33,
number = 9,
month = sep,
pages = {84--86},
year = 1998,
URL = {http://www.cse.ucsc.edu/research/embedded/pubs/gc/},
comment = {Obtains small improvement by observing that some objects
do not need to be stack allocated.}
}

@article{mcen87,
author = "T. J. McEntee",
title = "Overview of Garbage Collection in Symbolic Computing",
journal = "{LISP} Pointers",
publisher = ACM,
volume = 1,
number = 3,
pages = "8--16",
month = "August--September",
year = 1987
}

@inproceedings{mcga85,
author = "Mike McGaughey",
title = "Bounded-Space Tagless Garbage Collection for First Order Polymorphic Languages",
booktitle = "Proceedings of the Eighteenth Australian Computer Science Conference (ACSC '95)",
series = "Australian Computer Science Communications",
volume = "17(1)",
pages = "380--388",
address = "Glenelg, South Australia",
month = jan,
year = 1995,
URL = "http://www.cs.monash.edu.au/~mmcg/papers/mmcg-bounded-tagless-acsc95.ps.Z",
note = "Also appears as: Technical report 94/208, Department of Computer Science, Monash University",
abstract = "By compile-time type analysis of a program written in a statically typed first-order
polymorphic language, it is possible to generate a mark-sweep or copying garbage collector for that program
which does not require runtime tags on the data, which operates in linear time in the size of the data and stack,
and, excepting the use of a per-pointer mark bit, within a small, bounded workspace---desirable in an
algorithm which is only invoked when space is exhausted. The basis for the new graph marking algorithm, the
compile time type analysis required, and safety in the presence of sharing is described for languages employing a
first-order subset of the Hindley-Milner typing discipline; it is also immediately applicable to monomorphic,
type-safe programming languages, such as PASCAL. The algorithm is the first tag-free marking algorithm for
values of arbitrary algebraic type requiring less than linear space in the worst case."
}

@inproceedings{mcil76,
author = "M. Douglas McIlroy",
title = "Mass-Produced Software Components",
booktitle = "Software Engineering Concepts and Techniques (1968 {NATO}
Conference of {S}oftware Engineering)",
editor = "J. M. Buxton and Peter Naur and Brian Randell",
pages = "88--98",
year = 1976
}

@article{mcil82,
author = "M. Douglas McIlroy",
title = "The Number of States of a Dynamic Storage Allocation System",
journal = COMPJ,
volume = 25,
number = 3,
month = aug,
year = 1982,
pages = "388--392"
}

@inproceedings{mciv94,
author = "William J. McIver and Roger King",
title = "Self-Adaptive, On-Line Reclustering of Complex Object Data",
booktitle = "SIGMOD94",
pages = "407--418",
year = 1994
}

@inproceedings{mcke93,
author = "Paul E. McKenney and Jack Slingwine",
title = "Efficient Kernel Memory Allocation on Shared-Memory Multiprocessors",
booktitle = "{USENIX} 1993 Winter Technical Conference",
publisher = UA,
year = 1993
}

@inproceedings{mcku88,
author = "Marshall K. McKusick and Michael J. Karels",
title = "Design of a General-Purpose Memory Allocator for the {4.3BSD} {UNIX} Kernel",
booktitle = "Proceedings of the Summer 1988 {USENIX} Conference",
publisher = UA,
month = jun,
year = 1988
}

@article{mcna91,       
title = "2 Models For Integrating Persistence And Lazy Functional 
Languages",
author = "D. J. McNally and Anthony J. T. Davie",
address = "University of  St Andrews, Department of Computational Science, St Andrews KY16 9ST,
Fife, Scotland",
journal = Sigplan,
publisher = ACM,
year = 1991,
volume = 26,
number = 5,
pages = "43--52"
}


@phdthesis{meir85,
author = "Meira, Silvio R. de L.",
title = "On the Efficiency of Applicative Algorithms",
school = UKC,
month = mar,
year = 1985,
comment = "Chapter 4 considers limited-field reference counts"
}


@inproceedings{mell80,
author = "C. S. Mellish",
title = "An Alternative to Structure-Sharing in the Implementation of a 
{P}rolog Interpreter",
booktitle = "Workshop on Logic Programming, Debrecen, Hungary",
year = 1980,
comment = "Structure copying:simplifies gc algorithms (bruy82)." ,
}

@misc{melo99,
title = {The {J}ava {H}ot{S}pot Performance Engine: An In-Depth Look},
author = {Steve Meloan},
year = 1999, 
URL = {http://developer.java.sun.com/developer/technicalArticles/Networking/HotSpot/},
comment = {Contains some discussion of object layout and GC in HotSpot.
Whether it is in-depth or not....},
howpublished = {Article on Sun's Java Developer Connection site}
}

@article{mend93,
author = "Abraham Mendelson and Dominique Thiebaut and Dhiraj K. Pradhan",
title = "Modeling Live and Dead Lines in Cache Memory Systems",
journal = IEEETransComp,
publisher = IEEE,
volume = 42,
number = 1,
year = 1993,
month = jan,
pages = {1--14}
}

@inproceedings{mene97,
title = {Garbage Collection in Open Distributed Tuple Space Systems},
author = {Ronaldo Menezes and Alan Wood},
booktitle = {15th Brazilian Computer Networks Symposium --- SBRC '97},
pages = {525--543},
month = may,
year = 1997,
abstract = {This paper demonstrates the need for garbage collection in
multiple tuple space distributed open systems, which has Linda as a
major icon, and identifies problems involved in incorporating garbage
collection into such systems.  We concern ourselves with open
implementations as the existence of a garbage collector is essential in
this environment.
The extension of Linda to include multiple tuple spaces has introduced
this new problem as processes are now able to create tuple spaces,
spawn other processes into these tuple spaces, and store tuples (data)
into these tuple spaces, but are unable to delete any of the objects
(tuples, tuple spaces and processes) or even decide about their
usefulness.
In this paper we begin by showing that the main problem in introducing
garbage collection into Linda is the lack of sufficient information
about the effectiveness of Linda objects. We then describe techniques
for maintaining a structure to be used by a garbage collection
algorithm of tuple spaces.},
URL = {http://www.cs.york.ac.uk/linda/ps/sbrc97.ps}
}

@inproceedings{mene98,
title = {Ligia: Incorporating Garbage Collection in a {J}ava based {L}inda-like Run-Time System},
author = {Ronaldo Menezes},
booktitle = {Proceedings of the 2nd Workshop on Distributed Systems (WOSID'98)},
address = {Curitiba, Parana, Brazil},
pages = {81--88},
year = 1998,
abstract = {Generative distributed open coordination systems have been
so far implemented in a variety of ways. Surprisingly, no published
implementation appears to address one particularly important issue for
any general purpose open system | garbage collection.
This paper describes an open Linda-like implementation called Ligia
using Java, based on communication via sockets and which includes
garbage collection of tuple spaces and agents. It is also demonstrated
how the garbage collection described in [MW97] is implemented and that
it adds little overhead to the overall performance of the system.},
URL = {http://www.cs.york.ac.uk/linda/ps/wosid98.ps}
}

@inproceedings{mene98a,
title = {Using Tuple Monitoring and Process Registration on the Implementation of Garbage Collection in open {L}inda-like Systems},
author = {Ronaldo Menezes and Alan Wood},
booktitle = {Proceedings of the Tenth IASTED International Conference: PDCS'98},
address = {Las Vegas},
pages = {490--495},
month = oct,
year = 1998,
publisher = {ASTED/Acta Press},
abstract = {This paper demonstrates the importance of garbage
collection in open distributed tuple space systems based on Linda, and
how it should be implemented without adding a big overhead to the
system.
The extension of Linda to include multiple tuple spaces introduced this
new problem as processes are able to create tuple spaces but are unable
to delete them  or even decide whether a given tuple space is still
required in the system or not (garbage).
Techniques for maintaining a structure to be used by a garbage
collection algorithm of tuple spaces are described, implemented and the
results analysed. Two new concepts are introduced in the model in order
to provide the collector with the information required: tuple
monitoring and process registration.}
}

@techreport{mene98b,
title = {Ligia: A {J}ava based {L}inda-like Run-time System with Garbage Collection of Tuple Spaces},
author = {Ronaldo Menezes and Alan Wood},
institution = {University of York},
number = {YCS 304 (1998)},
year = 1998,
abstract = {Generative distributed open coordination systems have been
so far implemented in a variety of ways.  Surprisingly, no published
implementation appears to address one particularly important issue for
any general purpose open system | garbage collection.
This paper describes an open Linda-like implementation called Ligia
using Java, based on communication via sockets and which includes
garbage collection of tuple spaces and agents. It is demonstrated how
to do garbage collection efficiently, showing that little overhead is
added to the overall performance of the system.},
URL = {ftp://ftp.cs.york.ac.uk/reports/YCS-98-304.ps.Z}
}


@inproceedings{merr92,
title = "Collections and Garbage Collection",
author = "S. C. Merrall and J. A. Padget",
address = "University of Bath",
crossref = "IWMM92",
}

@misc{mery95,
title = {Refining Solutions of the On The Fly Garbage Collection from Formal Specifications},
author = {Dominique M\'{e}ry},
address = {Universit\'{e} henri Poincar\'{e}},
email = {mery@loria.fr},
month = nov,
year = 1995
}

@book{metr80,
title = "A History of Computing in the Twentieth Century",
editor	 = "N. Metropolis and J. Howlett and Gian-Carlo Rota",
publisher = AP,
year = 1980
}

@book{meye88,
author = "Bertrand Meyer",
title = "Object-oriented Software Construction",
publisher = PH,
year = 1988,
comment = "Introduces the Eiffel object-oriented programming language."
}

@techreport{meye96,
author = "Bertrand Meyer",
title = "The {ISE} {E}iffel Garbage Collection mechanism: An overview",
institution = "ISE Inc.",
URL = {http://www.eiffel.com/doc/manuals/technology/internal/gc/page.html},
mon= feb,
year = 1996
}

@inproceedings{meye03,
title = {A Novel Processor Architecture with Exact Tag-free Pointers},
author = {Matthias Meyer},
booktitle = {2nd Workshop on Application Specific Processors},
address = {San Diego, CA},
year = 2003,
URL = {http://www.ikr.uni-stuttgart.de/Content/Staff/Home/meyer/User/wasp03.pdf}
}

@incollection{meye83,
author = "R. Meyers and D. Casseres",
title = "An {MC68000}-Based {S}malltalk-80 System",
crossref = "Smalltalk-BHWA",
pages = "175--188",
}


@inproceedings{mikh01,
author = {V.V. Mikheev and S.A. Fedoseev},
title = {Compiler-Cooperative Memory Management in {J}ava},
booktitle = {Proceedings of the Andrei Ershov Fourth International Conference "Perspectives of System Informatics"},
series = LNCS, 
volume = 2244,
publisher = SV,
year = 2001,
URL = {http://www.excelsior-usa.com/pdf/StackAlloc.pdf}
}

@techreport{mill88a,
author = "B. P. Miller",
title = "The Frequency of Dynamic Pointer References in {'C'} Programs",
institution = "University of Wisconsin, Madison",
number = "TR 759",
year = 1988
}

@phdthesis{mill87,
author = "James S. Miller",
title = "Multi{S}cheme: A Parallel Processing System Based on {MIT} {S}cheme",
school = MIT,
year = 1987,
URL = "ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/listings/abstracts/TR-402.html",
note = "Also Technical Report MIT/LCS/402"
}

@inproceedings{mill90,
author = "James S. Miller and B. Epstein",
title = "Garbage Collection in {M}ulti{S}cheme",
booktitle = "US/Japan Workshop on Parallel Lisp, LNCS 441",
pages = "138--160",
month = jun,
year = 1990
}

@techreport{mill94,
author = "Miller, James S.  and Rozas, Guillermo J. ",
institution = MITAI,
title = "Garbage Collection is Fast, but a Stack is Faster",
year = 1994,
URL = "ftp://publications.ai.mit.edu/ai-publications/1000-1499/AIM-1462.ps.Z",
month = mar,
number = "{AIM}-1462"
}
 
@article{mill96,
author = "Justin Miller",
title = "Clean Up: {C++} Garbage Collection",
journal = "BYTE",
month = jan,
year = 1996,
pages = "157--158",
comment= "Reference counting library for C++."
}

@book{miln90,
author = "Robin Milner and Mads Tofte and Robert Harper",
title = "The Definition of Standard {ML}",
publisher = MIT,
year = 1990
}


@techreport{mins63,
author = "Marvin L. Minsky",
title = "A {L}isp Garbage Collector Algorithm Using Serial Secondary Storage",
number = "Memo 58 (rev.)",
institution = "Project MAC",
address = "MIT, Cambridge, MA",
month = dec,
year = 1963,
comments = {Presents an algorithm which eliminates the difficulties of having
a shared cell being output more than once to secondary storage.
Does not use a stack, but requires one mark-bit per lisp cell.
Live data is copied out to a file and then read back in.
This algorithm is linearizing.
Lisp 1.5. Would be unbearably slow on a modern machine.  }
}


@article{mira77,
author = "Miranda, Eliot E.",
title = "BrouHaHa --- a Portable {S}malltalk Interpreter",
journal = SIGPLAN,
volume = 22,
number = 12,
publisher = ACM,
pages = "354--365",
year = 1977,
comment = "``also describes Peter Deutsch's add/subtract two reference
counting hack that has to be one of the all-time greats.''"
}


@inproceedings{mira87,
author = "Eliot Miranda",
title = "Brou{H}a{H}a --- a Portable {S}malltalk Interpreter",
crossref = "OOPSLA87",
pages = "354-365",
comment = "Hybrid: reference count + mark-sweep"
}


@article{misr82,
title = "Termination Detection of Diffusing Computations in Communicating Sequential Processes",
author = "Jayadev Misra and K. M. Chandy",
pages = "37--43",
journal = toplas,
publisher = ACM,
year = 1982,
month = jan,
volume = 4,
number = 1
}


@article{misr86,
title = "Axioms for Memory Access in Asynchronous Hardware Systems",
author = "Jayadev Misra",
pages = "142--153",
journal = toplas,
publisher = ACM,
year = 1986,
month = jan,
volume = 8,
number = 1
}

@inproceedings{mitc03,
title = {{L}eak{B}ot: An Automated and Lightweight Tool for Diagnosing Memory Leaks in Large Java Applications},
author = {Nick Mitchell and Gary Sevitsky},
booktitle = {Proceedings of European Conference on Object-Oriented Programming, ECOOP 2003},
month = jun,
year = 2003,
address = {Darmstadt, Germany},
pages = {351--377},
abstract = {Despite Java's automatic reclamation of memory, memory
leaks remain an important problem. For example, we frequently encounter
memory leaks that cause production servers to crash. These servers
represent an increasingly common class of Java applications: they are
large scale and they make heavy use of frameworks. For these
applications, existing tools require too much expertise, and, even for
experts, require many hours interpreting low-level details. In
addition, they are often too expensive to use in practice. We present
an automated, adaptive, and scalable tool for diagnosing memory leaks,
called LeakBot.

LeakBot incorporates three new techniques. First, it automatically
ranks data structures by their likelihood of containing leaks. This
process dramatically prunes the set of candidate structures, using
object reference graph properties and knowledge of how leaks occur.
Second, it uses Co-Evolving Regions to identify suspicious regions
within a data structure and characterize their expected evolution.
Third, it uses the first two methods to derive a lightweight way to
track those regions' actual evolution as the program runs. These
techniques are mutually beneficial: we need only monitor what is highly
ranked, and, because the tracking is so cheap, a region's rank can be
continually updated with information from production machines. Finally,
this whole process can be done without user assistance.

We demonstrate LeakBot's effectiveness on a number of large-scale
applications that we have analyzed as part of the ongoing consulting
practice our group maintains. We have found that the ranking analysis
scales (e.g. written in Java, it analyzes 10^6 objects in 30 seconds
with a 300M heap), is selective (e.g. it prunes that set to three
candidate leak roots), and is accurate (it discounts non-leakingroots).
The CER generation completes in tens of seconds. The lightweight
tracking refines the rankings, while lowering throughput by less than
5\%.}
}

@inproceedings{mitt86,
author = "Mittal, S. and Bobrow, Daniel and Kahn, K.",
title = "Virtual Copies: At the Boundary Between Classes and Instances",
crossref = "OOPSLA86",
pages = "159--166"
}

@inproceedings{miya87,
author = "Miyauchi, Nobuhito and A. Matsumoto and Y. Kimura and A. Goto",
title = "Multiple Reference Management by {MRB} --- {GC} Characteristics on 
{KL1} Emulator",
booktitle = "35th Meeting of Information Processing Society",
year = 1987,
month = sep,
note = "In Japanese"
}


@techreport{miya89,
author = "Miyauchi, Nobuhito and Kawada, Yasuharu and Nakajima, Katsuto",
title = "Tracing Garbage Collection for {KL1} on the {M}ulti-{PSI}/{V2} 
System",
institution = "Institute for New Generation Computer Technology",
year = 1989,
type = "ICOT technical report",
number = "TR-469",
month = Mar,
abstract = "This paper describes the implementation and evaluation 
of tracing garbage collection for KL1 on the Multi-PSI/V2.  It is 
important for committed choice language systems to implement 
effective memory management mechanisms, because the memory 
consumption speed is quite high.  The incremental garbage 
collector by Multiple Reference Bit (MRB) reclaims single-
referenced data in order to keep locality and avoid frequent 
tracing garbage collection on the Multi-PSI/V2, but cannot 
collect multiple-referenced garbages.  Thus, the tracing garbage 
collector is indispensable to collect multiple-referenced
garbages.  The MRB information is maintained by counting 
reference paths in the tracing garbage collection, so the 
incremental garbage collector can collect all of single-
referenced garbages after that.  We evaluated the performance of 
the tracing garbage collection and the statistics of memory 
consumption on the Multi-PSI/V2, and confirmed that all of 
processors can work away without the disturbance of the tracing 
garbage collection."
}

@inproceedings{mogu91,
author = "Mogul, Jeffrey C. and Anita Borg",
title = "The Effect of Context Switches on Cache Performance",
crossref = "ASPLOS91",
pages = "75--84",
comment = "Cost of second level cache miss may rise to 200 cycles"
}


@phdthesis{moha84,
author = "Khayri A. Mohamed-Ali",
title = "Object Oriented Storage Management and Garbage Collection in 
Distributed Processing Systems",
school = "Royal Institute of Technology, Stockholm",
month = dec,
number = "TRITA--CS--8406",
year = 1984,
comment = "Cannot deal with cycles"
}

@article{moha86,
title = "Global Garbage Collection for Distributed Heap Storage-Systems",
author = "Kharyi A. Mohamed-Ali and Seif Haridi",
address = "Swedish Inst. Computer Science, S--16313 Spanga, Sweden",
journal = "International Journal Of Parallel Programming",
year = 1986,
volume = 15,
number = 5,
pages = "339--387"
}


%Check author
@inproceedings{moha89,
author = "Kharyi A. Mohamed-Ali", 
title = "Garbage Collection for {O}r-parallel {P}rolog Based on {WAM}",
booktitle = "Proceedings of the Gigalips Workshop, Stockholm",
month = apr,
year = 1989,
publisher = "SICS"
}

@techreport{mohn95,
title = "Efficient Compile-Time Garbage Collection for Arbitrary Data Structures",
author = "Markus Mohnen",
institution = "University of Aachen",
number = "95--08",
URL = "ftp://ftp.informatik.rwth-aachen.de/pub/reports/1995/95-08.ps.gz",
month = may,
year = 1995,
abstract = "This paper describes a \emph{compile-time garbage collection} (ctgc)
           method in the setting of a first-order functional language with data 
           structures. The aim is to obtain information on positions in a 
           program where certain heap cells will become obsolete during 
           execution. Therefore we develop an abstract interpretation for the
           detection of {\em inheritance information\/} which allows us to 
           detect whether the heap cells of an argument will be propagated to
           the result of a function call. The abstract interpretation itself is
           independent of the evaluation strategy of the underlying language. 
           However, since the actual deallocations take place after on 
           termination of functions, the information obtained by the abstract
           interpretation can be only be applied in an eager context, which may
           be detected using strictness analysis in a lazy language. In order to
           increase efficiency we show how the number of recomputations can be
           decreased by using only parts of the abstract domains. The worst case
           time complexity is essentially quadratic in the size of the program.
           We illustrate the method developed in this paper with several 
           examples and we demonstrate how to use the results in an eager 
           implementation.  Correctness of the analysis is considered, using a
           modified denotational semantics as reference point. A main goal of
           our work is to keep both the run-time and the compile-time overhead 
           as small as possible.",
note = "Also in Seventh International Symposium on Programming Languages, Implementations, Logics and Programs, PLILP95"
}

@inproceedings{monn01,
title = {Principled Scavenging},
author = {Stefan Monnier and Bratin Saha and Zhong Shao},
crossref = {PLDI01}
}

@manual{moon74,
author = "David A. Moon",
title = "{MACLisp} reference manual",
organization = "Project MAC",
address = "MIT, Cambridge, MA",
month = apr,
year = 1974,
}


@inproceedings{moon84,
title = "Garbage Collection in a Large {LISP} System",
author = "David A. Moon",
crossref = "LFP84",
pages = "235--245",
comment = "Improve performance by using the garbage collector.
Lisp Machines have special purpose hardware to detect pointers
into fromspace and trap to a handler.
The cost of this checking on a conventional machine is in the tens of percent
for a high performance system."
}


@inproceedings{moon85,
author = "David A. Moon",
title = "Architecture of the {S}ymbolics 3600",
booktitle = "Proceedings of the 12th Annual International Symposium on Computer
Architecture",
address = "Boston, MA",
month = jun,
year = 1985,
pages = "76--83",
comment = {Multiple generations are reclaimed incrementally.}
}

@inbook{moon90,
author = "David A. Moon",
title = {Symbolics Architecture},
chapter = 3,
booktitle = "Computers for Artificial Intelligence Processing",
publisher = Wiley,
year = 1990
}

@inproceedings{moon91,
title = {Genera Retrospective},
crossref = {IWOOOS91},
author = "David A. Moon",
note = {Order Number 2265}
}

@inproceedings{moon92,
title = "Copying Garbage Collection is Harmful",
author = "David A. Moon",
crossref = "IWMM92",
}

@inproceedings{moor97,
title = {Oscar: A {GC} Testbed},
author = {Jonathan Moore and Mike Hicks and Scott Nettles},
URL = {ftp://ftp.dcs.gla.ac.uk/pub/drastic/gc/nettles-oscar.ps},
crossref = {OOPSLA97-gc}
}

@techreport{more97,
author = {Luc Moreau},
title = {A Distributed Garbage Collector with Diffusion Tree Reorganisation and Object Mobility},
number = {M97/2},
month = oct,
institution = {University of Southampton},
year = 1997
}

@inproceedings{more97a,
author = {Luc Moreau and David DeRoure and Ian Foster},
title = {{N}e{X}eme: a Distributed {S}cheme Based on {N}exus},
booktitle = {Third International Europar Conference (EURO-PAR'97)},
series = LNCS,
volume = 1300,
pages = {581--590},
address = {Passau, Germany},
month = aug,
publisher = SV,
year = 1997
}

@inproceedings{more98,
author = {Luc Moreau},
title = {Hierarchical Distributed Reference Counting},
pages = {57--67},
crossref = {ISMM98},
abstract = {Massively distributed computing is a challenging problem
for garbage collection algorithm designers
as it raises the issue of scalability. The high number of hosts
involved in a computation can require large tables for reference
listing, whereas the lack of information sharing between hosts in
a same locality can entail redundant GC traffic. In this paper,
we argue that a conceptual hierarchical organisation of massive
distributed computations can solve this problem. By conceptual
hierarchical organisation, we mean that processors are still able
to communicate in a peer to peer manner using their usual
communication mechanism, but GC messages will be routed as if
processors were organised in hierarchy. We present an extension
of a distributed reference counting algorithm that uses such a
hierarchical organisation. It allows us to bound table sizes by
the number of hosts in a domain, and it allows us to share GC
information between hosts in a same locality in order to reduce
cross-network GC traffic. }
}

@inproceedings{more98a,
author = {Luc Moreau},
title = {A Distributed Garbage Collector with Diffusion Tree Reorganisation and Mobile Objects},
pages = {204--215},
crossref = {ICFP98}, 
URL = {http://www.acm.org/pubs/articles/proceedings/fp/289423/p204-moreau/p204-moreau.pdf}
}

@misc{more99,
author = {Luc Moreau and Jean Duprat},
title = {A Construction of Distributed Reference Counting: the Constructive Proof in {C}oq},
month = feb,
year = 1999,
URL = {http://www.ecs.soton.ac.uk/~lavm/coq/drc/}
}

@inproceedings{more99a,
author = {Luc Moreau},
title = {Implementation and Performance Evaluation of a Distributed Garbage
Collection Algorithm},
booktitle = {Parallel and Distributed Computing for Symbolic and Irregular Applications, PDCSIA'99},
editor = {Takayasu Ito and Taiichi Yuasa},
year = 1999,
URL = {http://www.ecs.soton.ac.uk/~lavm/papers/pdcsia99.ps.gz},
publisher = {World Scientific Publishing},
address = {Sendai, Japan},
month = jul,
pages = {221--241},
abstract = {We have recently described an algorithm for distributed garbage
collection based on reference-counting; the algorithm describes a
spectrum of algorithms according to the policy used to manage
messages. In this paper, we describe the implementation of the
algorithm and evaluate its performance.  We have implemented two
policies, which are extremes of the spectrum.  The first one uses
incdec messages, whose effect is to reorganise the diffusion tree,
whereas the other one does not use such messages, which in effect
results in Piquer's indirect reference counting.  In addition, two
different strategies for managing action queues have been
implemented.  The conclusions of our experimentations are the
following. Using incdec messages potentially offers more
parallelism in the DGC activity; this phenomenon can be measured by
shorter causality chains than with indirect reference counting.
Grouping messages per destination dramatically reduces the number
of messages to be sent, though requires a more complex
implementation as messages have to be sorted per destination.}
}


@article{morr78,
author = "F. Lockwood Morris",
title = "A Time- and Space-Efficient Garbage Compaction Algorithm",
journal = CACM,
publisher = ACM,
volume = 21,
number = 8,
pages = "662--5",
year = "1978",
abstract = {Compacting GC for vari-sized cells. O(n) and requires only 1 extra bit per 
pointer.
No break tables. Sliding. Cf. also Jonkers79. Apparently slow --- see cohen-
nicolau.}
}


@article{morr79,
author = "F. Lockwood Morris",
title = "On a Comparison of Garbage Collection Techniques",
journal = CACM, 
publisher = ACM,
volume = 22,
number = "10",
month = Oct,
year = 1979,
pages = 571,  
}


@article{morr82,
title = "Another Compacting Garbage Collector",
author = "F. Lockwood Morris",
journal = IPL,
publisher = NH,
series = "Data compaction",
year = 1982,
month = oct,
volume = 15,
number = 4,
pages = "139--142"
}


@techreport{morr95,
title = "Abstract Models of Memory Management",
author = "J. Gregory Morrisett and Mattias Felleisen and Robert Harper",
institution = CMU,
URL = "http://www.cs.cmu.edu:8001/afs/cs.cmu.edu/user/jgmorris/web/jgmorris-home.html",
month = jan,
number = "CMU--CS--95--110",
year = 1995,
note = "Also published as Fox memorandum CMU--CS--FOX--95--01"
}

@inproceedings{morr95a,
title = "Abstract Models of Memory Management",
author = "J. Gregory Morrisett and Mattias Felleisen and Robert Harper",
URL = "http://www.cs.cornell.edu/Info/People/jgm/papers/fpca_gc.ps",
crossref = "FPCA95",
}

@incollection{morr97,
title = {Semantics of Memory Management for Polymorphic Languages},
author = {Greg Morrisett and Robert Harper},
booktitle = {Higer Order Operational Techniques in Semantics},
editor = {A. Gordon and A. Pitts},
publisher = {Newton Institute, } # CUP,
year = 1997
}

@phdthesis{morr95b,
title = "Compiling with Types",
author = "J. Gregory Morrisett",
school = CMU,
URL = "http://www.cs.cornell.edu/Info/People/jgm/papers/thesis.ps",
month = dec,
year = 1995,
note = "Published as CMU Technical Report CMU-CS-95-226",
}

@techreport{moss78,
author = "Moss, J. Eliot B.",
title = "Abstract Data Types in Stack Based Languages",
institution = "MIT Laboratory for Computer Science",
type = "Technical Memo",
number = "MIT/LCS/TR--190",
month = aug,
year = 1990,
URL = "ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/listings/abstracts/TR-190.html"
}

@incollection{moss88,
author = "J. Eliot B. Moss and S. Sinofsky",
title = "Managing Persistent Data with {M}neme: Designing a Reliable,
Shared Object Interface",
booktitle = "Advances in Object-oriented Database Systems",
series = LNCS,
volume = 334,
pages = "298--316",
publisher = SV,
year = 1988
}

@inproceedings{moss89,
author = "Moss, J. Eliot B.",
title = "Addressing Large Distributed Collections of Persistent
Objects:  The {M}neme Project's Approach",
booktitle = "Second International Workshop on Database Programming
Languages",
pages = "269--285",
month = jun,
year = 1989,
address = "Glenedon Beach, OR",
URL = {ftp://ftp.cs.umass.edu/pub/osl/papers/dbpl89.ps.Z},
note = "Also available as Technical Report 89-68,
University of Massachusetts Department of Computer and Information
Science, Amherst, MA, 1989."
}


@techreport{moss89b,
author = "J. Eliot B. Moss",
title = "The {M}neme Persistent Object Store",
type = "COINS Technical Report",
number = "89--107",
institution = "University of Massachusetts, Department of Computer and Information Science",
year = 1989
}

@inproceedings{moss90,
author = "J. Eliot B. Moss",
title = "Garbage Collecting Persistent Object Stores",
crossref = "OOPSLA90-gc",
URL = "ftp://ibis.cs.umass.edu/pub/papers/oopsla90gc.ps.Z",
note = "Also in SIGPLAN Notices 23(1):45--52, January 1991.",
}


@techreport{moss90a,
author = "Moss, J. Eliot B.",
title = "Working With Objects: To Swizzle or Not to Swizzle?",
number = "90--38",
institution = "University of Massachusetts",
address = "Amherst, MA",
month = may,
year = 1990    
}


@inproceedings{moss91,
author = "Maurice P. Herlihy and J. Eliot B. Moss",
title = "Lock-Free Garbage Collection for Multiprocessors",
booktitle = "Parallel Algorithms and Architectures",
publisher = ACM,
pages = "229--236",
month = jul,
year = 1991
}

@inproceedings{moss91a,
title = "The {UM}ass Language Independent Garbage Collector Toolkit",
author = "J. Eliot B. Moss",
crossref = "OOPSLA91-gc",
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/GC91/moss.ps"
}

@inproceedings{moss96,
author = {J. Eliot B. Moss and David S. Munro and Richard L. Hudson},
title = {{PMOS}: A Complete and Coarse-grained Incremental Garbage Collector for Persistent Object Stores},
crossref = "IWPOS96",
pages = {140--150},
URL = {http://www.dcs.st-and.ac.uk/research/publications/download/MMH96.pdf},
abstract = {Traditional garbage collection techniques designed for
	language systems operating over transient data do not readily migrate
	to a persistent context. The size, complexity, and permanence
	characteristics of a persistent object store mean that an automatic
	storage reclamation system, in addition to ensuring that all
	unreachable and only unreachable data is reclaimed, must also maintain
	store consistency while limiting I/O overhead when collecting
	secondary-memory data. Research has shown that careful selection of
	which area of a store to collect can significantly increase the amount
	of reclaimed storage while reducing the I/O costs.  Many garbage
	collectors for existing stores, however, either are off-line or rely on
	reclaiming space in a predefined order. This paper presents a new
	incremental garbage collection algorithm specifically designed for
	reclaiming persistent object storage. The collector extends the Mature
	Object Space algorithm to ensure incrementality in a persistent
	context, to achieve recoverability, and to impose minimum constraints
	on the order of collection of areas of the persistent address space.}
}

@inproceedings{mowr92,
author = "T. C. Mowry and Monica S. Lam and A. Gupta",
title = "Design and Evaluation of a Compiler Algorithm for Prefetching",
crossref = "ASPLOS92",
pages = "62--73",
}

@inproceedings{mulk90,
author = "Anne Mulkers and William Winsborough and Maurice Bruynooghe",
title = "Analysis of Shared Data Structures for Compile-Time Garbage Collection in Logic Programs",
booktitle = "7th International Conference on Logic Programming",
publisher = MIT,
pages = "747--762",
year = 1990
}

@techreport{mulk90a,
author = "Anne Mulkers and William Winsborough and Maurice Bruynooghe",
title = "Analysis of Shared Data Structures for Compile-Time Garbage Collection in
 Logic Programs",
institution = "Katholieke Universitiet of Leuven, Belgium",
type = "Report",
number = "CW117",
note = "Extended version",
year = 1990
}

@phdthesis{mulk91,
author = "Anne Mulkers",
title = "Deriving Live Data Structures in Logic Programs by Means of Abstract
Interpretation",
school = "Katholieke Universitiet of Leuven, Belgium",
year = 1991
}

@inproceedings{mulk92,
author = "Anne Mulkers and William Winsborough and Maurice Bruynooghe",
title = "Static Analysis of Logic Programs to Detect Run-Time Garbage Cells",
booktitle = "International Conference on Computer Systems and Software
Engineering",
publisher = IEEE,
pages = "526--531",
year = 1992
}

@book{mulk93,
author = "Anne Mulkers",
title = "Live Data Structures in Logic Programs",
publisher = SV,
series = LNCS,
number = 675,
year = 1993,
comment = "Abstract interpretation for compile-time gc"
}


@techreport{mulk93a,
author = "Anne Mulkers and William Winsborough and Maurice Bruynooghe",
title = "A Live-Structure Data-Flow Analysis for {P}rolog",
institution = "Katholieke Universitiet of Leuven, Belgium",
type = "Theory Reort",
number = "CW167",
year = 1993
}

@article{mulk94,
author = "Anne Mulkers and William Winsborough and Maurice Bruynooghe",
title = "Live-Structure Dataflow Analysis for {P}rolog",
journal = TOPLAS,
publisher = ACM,
volume = 16,
number = 2,
month = mar,
year = 1994,
URL = {http://www.acm.org/pubs/citations/journals/toplas/1994-16-2/p205-mulkers/}
}

@techreport{mull92,
author = "H. L. Muller and K. G. Langendoen and L. O. Hertzberger",
title = "{MiG}: Simulating Parallel Functional Programs on Hierarchical 
Cache Architectures",
institution = "Department of Computer Science, University of Amsterdam",
year = 1992,
month = jun,
number = "CS--92--04",
}

@phdthesis{mull76,
author = {Klaus A. G. M\"{u}ller},
title = "On the Feasibility of Concurrent Garbage Collection",
school = "Tech. Hogeschool Delft",
month = Mar,
year = 1976,
}

@inproceedings{munr99,
author = {David Munro and Alfred Brown and Ron Morrison and J. Eliot B. Moss},
title = {Incremental Garbage Collection of a Persistent Object Store using {PMOS}},
booktitle = {Advances in Persistent Object Systems},
editor = {Ron Morrison and Mick Jordan and Malcolm Atkinson},
publisher = MK,
pages = {78--91},
year = 1999,
URL = {http://www.dcs.st-and.ac.uk/research/publications/download/MBM+99.pdf}
}

@inproceedings{munr00,
author = {David S. Munro and Alfred L. Brown},
title = {Evaluating Partition Selection Policies using the {PMOS} Garbage Collector},
pages = {104--115},
crossref = {IWPOS00}
}

@inproceedings{murt84,
author	 = "Thomas P. Murtagh",
title = "A Less Dynamic Memory Allocation Scheme for {A}lgol-like Languages",
crossref = "POPL84",
pages = {283--289},
}


@article{murt91,
title = "An Improved Storage Management Scheme for Block Structured Languages",
author = "Thomas P. Murtagh",
pages = "372--398",
journal = toplas,
publisher = ACM,
year = 1991,
month = jul,
volume = 13,
number = 3
}

@article{naga88,
author = "Naganuma, Jiro and Ogura, Takeshi and Yamada, Shin-ichiro and Kimura, Takashi",
address = "NTT, Kanagawa, Jpn",
title = "High-Speed {CAM}-Based Architecture for a {P}rolog Machine ({ASCA})",
year = 1988,
journal = IEEETransComp,
publisher = IEEE,
volume = 37,
number = 11,
month = 11,
pages = "1375--1383",
abstract = {A content-addressable-memory (CAM)-based machine is proposed
for a high-speed Prolog machine. This Prolog machine
attempts to speed up the total Prolog execution performance
by using a hierarchical pipelined scheme and CAM-based
backtracking scheme. The hierarchical pipelined scheme
reduces the total number of Prolog execution steps to half
of that using the conventional method. The CAM-based
backtracking is efficiently and quickly achieved by using a
sophisticated garbage collection function, which eliminates
the need for stacks and additional operation cycles. In this
machine, all Prolog execution can be simply controlled by a
semantic information 'inference depth' without any address
handling by sorting all working information, binding, and
control information in CAMs. This machine attains a
performance of 100 KLIPS (kilo logical inferences per
second) on the deterministic append program in the
interpretive mode and also attains high performance on the
interministic program. All Prolog programs in artificial-
intelligence application areas can run at high performance
on this machine.}
}

@techreport{naka88,
author = "Nakajima, Katsuto",
title = "Piling {GC}: Efficient Garbage Collection for {Al} Languages",
institution = "Institute for New Generation Computer Technology",
year = 1988,
type = "ICOT technical report",
number = "TR-354"
}

@inproceedings{naka88a,
author = "Nakajima, Katsuto",
title = "Piling {GC}: Efficient Garbage Collection for {Al} Languages",
booktitle = "IFIP WG 10.3 Working Conference on Parallel Processing",
year = 1988,
pages = "210--204",
publisher = NH
}


@mastersthesis{neel96,
title = "An Analysis of the Effects of Memory Allocation Policy on Storage Fragmentation",
author = "Michael S. Neely",
school = "University of Texas at Austin",
year = 1996,
URL = "http://www.cs.utexas.edu/users/oops/papers.html#neely-thesis"
}

@inproceedings{neir87,
author = "Anne Neirynck and Prakash Panangaden and Alan J. Demers",
title = "Computation of Aliases and Support Sets",
crossref = "POPL87",
pages = {274--283},
}


@phdthesis{neir88,
author = "Anne Neirynck",
title = "Static Analysis of Aliasing and Side Effects in Higher-Order Languages",
school = CORNELL,
year = 1988,
month = jan
}

@inproceedings{nels83,
title = "Verifying Reachability Invariants of Linked Structures",
author = "Greg Nelson",
pages = "38--47",
crossref = "POPL83",
}


@mastersthesis{nels89,
author = "Nelson, Jeffrey E.",
title = "Automatic, Incremental, On-The-Fly Garbage Collection of Actors",
year = 1989,
school = "Virginia Polytechnic Institute and State University"
}


@inproceedings{nett92,
title = "Replication-Based Incremental Copying Collection",
author = "Scott M. Nettles and James W. O'Toole and David Pierce and Nicholas Haines",
address = "Carnegie Mellon University, USA",
crossref = "IWMM92",
URL = "ftp://reports.adm.cs.cmu.edu/usr/anon/1993/CMU-CS-93-138.ps",
}

@techreport{nett92a,
author = "Nettles, Scott M.",
title = "A {L}arch Specification of Copying Garbage Collection",
institution = "School of Computer Science, Carnegie Mellon University",
year = 1992,
type = "Research paper",
number = "CMU-CS-92-219",
URL = "http://rose.mercury.acs.cmu.edu:1082/TR/CMU:CS-92-219",
month = Dec,
abstract = "Garbage collection (GC) is an important part of many 
language implementations.  One of the most important garbage 
collection techniques is copying GC.  This paper consists of an 
informal but abstract description of copying collection, a formal 
specification of copying collection written in the Larch Shared 
Language and the Larch/C Interface Language, a simple 
implementation of a copying collector written in C, an informal 
proof that the implementation satisfies the specification, and a 
discussion of how the specification applies to other types of 
copying GC such as generational copying collectors.  Limited 
familiarity with copying GC or Larch is needed to read the 
specification."
}

@inproceedings{nett93,
title = "Real-Time Replication-Based Garbage Collection",
author = "Scott M. Nettles and James W. O'Toole",
address = "Carnegie Mellon University, USA",
crossref = "PLDI93",
URL = "http://www.psrg.lcs.mit.edu/ftpdir/james/papers/pldi93.ps",
comment = "Copying GC that permits continuous unimpeded mutator access to the 
original object during copying. GC incrementally replicates accessible objects
and uses a mutation log to bring replicas up-to-date"
}

@techreport{nett93b,
title = "Concurrent Garbage Collection of Persistent Heaps",
author = "Scott M. Nettles and James W. O'Toole and David Gifford",
number = "MIT/LCS/TR--569 and CMU--CS--93--137",
institution = "Computer Science Department, Carnegie-Mellon University",
URL = "ftp://reports.adm.cs.cmu.edu/usr/anon/1993/CMU-CS-93-137.ps",
month = apr,
year = 1993,
note = "The same paper as \cite{otoo93a}"
}

@inproceedings{nett93c,
author = "Scott M. Nettles and James W. O'Toole",
title = "Implementing Orthogonal Persistence: A Simple Optimization Based on Replicating Collection",
crossref = "IWOOOS93",
}

@inproceedings{nett96,
title = {A Rollback Technique for Implementing Persistence by Reachability},
author = {Scott M. Nettles and James W. O'Toole},
crossref = "IWPOS96"
}

@inproceedings{newe57,
author = "A. Newell and J. C. Shaw",
title = "Programming the Logic Theory Machine",
booktitle = "Proceedings of the Western Joint Computing Conference",
pages = "230--240",
year = 1957
}


@article{newe60,
author = "A. Newell and F. M. Tonge",
title = "An Introduction to Information Processing Language {V}",
journal = CACM,
publisher = ACM,
volume = 3,
number = 4,
month = Apr,
pages = "205--211",
year = 1960,
comment = {
An early list processing language. IPL--V programmers were responsible for
returning list cells to the pool of free storage.  }
}
 

@article{newm82,
author = "I. A. Newman and R. P. Stallard and M. C. Woodward",
title = "Performance of Parallel Garbage Collection Algorithms",
journal = "Computer Studies",
volume = 166,
month = sep,
year = 1982
}



@inproceedings{newm82a,
author = "I. A. Newman and R. P. Stallard and M. C. Woodward",
title = "Alternative Approaches to Multiprocessor Garbage Collection",
booktitle = "Proceedings of the International Conference on Parallel Processing",
pages = "205--210",
publisher = IEEE,
month = aug,
year = 1982,
comment = "Modification of Lamport's multiprocessor on-the-fly algorithm"
}

@inproceedings{newm83,
author = "I. A. Newman and R. P. Stallard and M. C. Woodward",
title = "Improved Multiprocessor Garbage Collection Algorithms",
booktitle = "Proceedings of the International Conference on Parallel Processing",
pages = "367-368",
publisher = IEEE,
month = aug,
year = 1983,
comment = "Modification of Lamport's multiprocessor on-the-fly algorithm"
}

@inproceedings{newm84,
author = "I. A. Newman and R. P. Stallard and M. C. Woodward",
title = "A Parallel Compaction Algorithm for Multiprocessor Garbage
Collection",
booktitle = "Proceedings of Parallel Computing 83 Conference",
editor = "M. Feilmeier and J. Joubert and U. Schendel",
pages = "450--462",
year = 1984
}

@article{newm87,
title = "A Hybrid Multiple Processor Garbage Collection Algorithm",
author = "I. A. Newman and R. P. Stallard and M. C. Woodward",
address = "Loughborough University of Technology, Department of Computer Studies,
Loughborough LE11 3TU,  Leics,  England",
journal = CompJ,
publisher = BCS,
year = 1987,
volume = 30,
number = 2,
pages = "119--127",
abstract = {Dynamic storage allocation schemes continue to grow in popularity.
The problem of automatically reclaiming space that is no longer used is the
principal drawback of such memory management schemes.  This paper gives an
overview of existing algorithms and proposes a new combined approach that
overcomes some of the problems with previous algorithms.  Results are presented
for several algorithms executed on a four-processor system that suggest that
the proposed combined approach offers an improved performance when 
executed on shared-memory multiprocessors.}
}


@inproceedings{ng87,
title = "Basic Memory Support for Functional Languages",
author = "Y. H. Ng and R. J. Glover",
booktitle = "1987 Proceedings --- Fourth International {IEEE} {VLSI}
Multilevel Interconnection Conference. {S}anta {C}lara, {J}une 15--16",
publisher = IEEE,
pages = "35--40",
year = 1987,
abstract = {A symbolic associative processor (SAP) is described that is capable
of supporting complex dynamic data structures commonly found in functional
programming.  The overheads imposed by the need for garbage collection, which
are a limiting factor in conventional Von Neumann and random access memory
implementations, are minimized by the use of a modified content-addressable
memory.  The suitability of the proposed SAP for VLSI implementation is
discussed, and a test chip containing some SAP structures is described.}
}

@mastersthesis{ng96,
author = {T.C.T. Ng},
title = {Efficient Garbage Collection for Large Object-Oriented Databases},
school = MITLCS,
year = 1996
}

@article{niel77,
author = "Norman R. Nielsen",
title = "Dynamic Memory Allocation in Computer Simulation",
journal = cacm,
publisher = ACM,
year = 1977,
volume = 20,
number = 11,
month = nov,
pages = {864--873}
}


@techreport{nils87,
author = "Nilsen, Kelvin D.",
title = "Real-Time Garbage Collection of Strings and Linked Data Structures",
institution = "University of Arizona, Department of Computer Science",
year = 1987,
month = Jan,
number = "TR 87-5"
}


@article{nils88,
title = "Garbage Collection of Strings and Linked Data-Structures in Real-Time",
author = "Kelvin D. Nilsen",
institution = "Univ Arizona, Department of Computer Science, Tucson, AZ, 85721",
journal = SPE,
publisher = Wiley,
year = 1988,
volume = 18,
number = 7,
pages = "613--640",
comments = {Variant of Baker's algorithm, with lazy copying.
This paper describes the addition of certain information to a
string descriptor and enhancements to existing copying garbage collection
algorithms that permit linked data structures and strings to be allocated 
and garbage collected from a shared region of memory in real time.  This 
algorithm is real-time in the sense that the time required for allocation 
of each basic unit of memory is bounded by a constant.
An analysis of performance is
reported, and comparisons are made with traditional garbage collection.}
}


@inproceedings{nils90,
author = "Kelvin D. Nilsen and William J. Schmidt",
title = "Hardware Support for Garbage Collection of Linked Objects and Arrays in Real-Time",
crossref = "OOPSLA90-gc",
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/GC91/nilsen.ps"
}


@techreport{nils90a,
author = "Nilsen, Kelvin D. and  Schmidt, William J.",
title = "A High-Level Overview of Hardware Assisted Real-Time Garbage Collection",
institution = "Iowa State University, Department of Computer Science",
year = 1990,
number = "TR90-18a",
month = Oct,
abstract = "The costs of executing traditional garbage collection 
algorithms most generally include not only the costs of 
allocating and reclaiming memory, but also the overhead costs 
imposed by the garbage collection system on standard memory read 
and write operations.  This paper  outlines the design of a 
general purpose garbage collection system that uses specialized 
hardware to allow standard memory access and modification 
operations to perform nearly as well as traditional memory. 
Allocation and  garbage collection are as efficient as more 
traditional stop-and-wait garbage collection systems.  The cost 
of the specialized hardware is relatively small in comparison to 
the cost of the memory it manages.
The specialized hardware is located entirely within an 
intelligent memory module whose interface to the system bus is 
identical to  traditional memory.  This paper describes the data 
types supported by the general purpose garbage collection 
algorithm and outlines the hardware organization of the proposed 
architecture."
}

@inproceedings{nils91,
author = "Kelvin D. Nilsen",
title = "A High-Performance Architecture for Real-Time Garbage Collection ",
crossref = "OOPSLA91-gc",
}


@techreport{nils92,
author = "Nilsen, Kelvin D. and  Schmidt, William J.",
title = "Hardware-Assisted General-Purpose Garbage Collection for 
Hard Real-Time Systems",
institution = "Iowa State University, Department of Computer Science",
year = 1992,
number = "ISU TR92-15",
month = oct,
URL = "http://www.cs.iastate.edu/tech-reports/TR92-15.ps"
}

@techreport{nils92a,
author = "Nilsen, Kelvin D. and  Schmidt, William J.",
title = "Preferred Embodiment of a Hardware-Assisted Garbage Collection System",
institution = "Iowa State University, Department of Computer Science",
year = 1992,
number = "ISU TR92-17",
month = nov,
URL = "http://www.cs.iastate.edu/tech-reports/TR92-17a.ps"
}

@techreport{nils92b,
author = "Kelvin D. Nilsen",
title = "Memory Cycle Accountings for Hardware-Assisted Real-Time Garbage Collection",
institution = "Iowa State University",
number = "91-21(c)",
address = "Computer Science Department",
year = 1992,
URL = "http://www.cs.iastate.edu/tech-reports/TR91-21c.ps"
}

@article{nils92c,
title = "Cost-Effective Object-Space Management for Hardware-Assisted 
Real-Time Garbage Collection",
author = "Nilsen, Kelvin D. and  Schmidt, William J.",
journal = "Letters on Programming Language and Systems",
publisher = ACM,
volume = 1,
number = 4,
pages = "338--354",
month = dec,
year = 1992,
URL = {http://www.newmonics.com/webroot/technologies/gc/loplas.ps}
}

@inproceedings{nils93,
author = "Kelvin D. Nilsen",
title = "Reliable Real-Time Garbage Collection of {C++}",
crossref = "OOPSLA93-gc",
}

@article{nils93a,
title = "Cost-Effective Object-Space Management for Hardware-Assisted Real-Time Garbage Collection",
author = "Kelvin D. Nilsen and William J. Schmidt",
journal = "Letters on Programming Languages and Systems",
publisher = ACM,
year = 1993,
volume = 1,
number = 4,
pages = "338--354",
month = dec
}

@inproceedings{nils94,
title = "Cost-Effective Hardware-Assisted Real-Time Garbage Collection",
author = "Kelvin D. Nilsen",
booktitle = "Workshop on Language, Compiler, and Tool Support for Real-Time Systems, PLDI94",
month = jun,
year = 1994,
URL = "ftp://ftp.cs.iastate.edu:/pub/kelvin",
abstract = {Hardware-assisted real-time garbage collection offers more
reliable operation and higher
performance than software-only real-time garbage collection
systems. Completed simulation studies have analyzed the behavior
of a hardware-assisted garbage collection system tuned primarily
to achieve high throughput. Based on these studies, we conclude
that system designers can trade small amounts of performance
loss for significant cost reductions. This paper provides an
overview of an alternative design for hardware-assisted
real-time garbage collection that has been configured with the
primary goal of maximizing performance per unit cost. Work is
under way to build and analyze a hardware prototype.}
}

@article{nils94a,
title = "A High-Performance Hardware-Assisted Real Time Garbage Collection System",
author = "Kelvin D. Nilsen and William J. Schmidt",
journal = "Journal of Programming Languages",
year = 1994,
volume = 2,
number = 1,
URL = "ftp://ftp.cs.iastate.edu:/pub/kelvin"
}

@article{nils94b,
title = "Reliable Real-Time Garbage Collection of {C++}",
author = "Kelvin D. Nilsen",
journal = "Computing Systems",
year = 1994,
volume = 7,
number = 4,
URL = "ftp://ftp.cs.iastate.edu:/pub/kelvin",
abstract = {Garbage collection of C++ offers the potential of improving
programmer productivity, reducing the occurrence of dynamic memory
management errors in both prototype and production software, and
increasing the levelof abstraction provided by many reusable software
components. The hardware-assisted real-time garbage collection system
described in this paper offers the additional benefits of providing
more predictable memory utilization and response times than are
available from traditional dynamic memory management techniques for
C++. This paper describes a C++ dialect that allows real-time garbage
collection of heap-allocated objects in a manner that is compatible
with traditional real-time development methodologies. This paper also
provides a brief overview of established methodologies for development
of reliable real-time software, with emphasis on issues that are
relevant to garbage collection, and summarizes the shortcomings of
existing real-time garbage collection techniques.}
}

@inproceedings{nils95,
title = "Progress in Hardware-Assisted Real-Time Garbage Collection",
author = "Kelvin Nilsen",
address = "Department of Computer Science, Iowa State University, Ames, IA",
crossref = "IWMM95",
abstract = {Hardware-assisted real-time garbage collection offers more
reliable operation and higher
performance than software-only real-time garbage collection
systems. Completed simulation studies have analyzed the behavior
of a hardware-assisted garbage collection system tuned primarily
to achieve high throughput. Based on these studies, we conclude
that system designers can trade small amounts of performance
loss for significant cost reductions. This paper provides an
overview of an alternative design for hardware-assisted
real-time garbage collection that has been configured with the
primary goal of maximizing performance per unit cost. Improved
functionality is achieved by providing support for a variety of
garbage collection algorithms, including fully copying,
incremental mark and sweep, mostly stationary, and generational
techniques. }
}

@inproceedings{nils95a,
author = "Kelvin Nilsen and H. Gao",
title = "The Real-Time Behaviour of Dynamic Memory Management in {C++}",
booktitle = "IEEE Real-Time Technologies and Applications Symposium",
publisher = IEEE,
address = "Chicago",
pages = "142--153",
month = may,
year = 1995,
URL = {http://www.newmonics.com/webroot/technologies/gc/rtas.ps},
abstract = {Dynamic memory management is an important aspect of modern
software engineering techniques based on object-oriented methodologies.
Additionally, dynamic management of memory serves important roles in
improving the flexibility and functionality of large software systems.
However, developers of current real-time systems avoid the use of
dynamic memory because they fear that the worst-case time and space
requirements of typical memory managers are insufficiently bounded. The
degree to which these concerns are valid is quantified by detailed
measurements of several real-world workloads. A special
hardware-assisted real-time garbage collection system has been designed
to facilitate reliable use of dynamic memory in hard-real-time systems.
By analyzing the dynamic memory use of application software, the
real-time developer can prove compliance with time and space
constraints.  Analysis techniques are presented and the real-time
performance of the hardware-assisted garbage collection system are
compared to that of the traditional allocators.}
}

@inproceedings{nils95b,
author = "Kelvin Nilsen",
title = {High-Level Dynamic Memory Management for Object Oriented Real-Time Systems},
booktitle = {Workshop on Object-Oriented Real-Time Systems},
address = {San Antonio, Tx.},
month = oct,
year = 1995,
URL = {http://www.newmonics.com/webroot/technologies/gc/oops.ps},
abstract = {On-the-fly memory allocation and deallocation is required
for the cost-effective implementation of systems with workloads that
vary over time and for systems that deal with problems of unpredictable
size or complexity. Furthermore, many of the easily programmed data
structures that are most efficient for data access and manipulation are
constructed from large numbers of independently allocated memory
objects. But dynamic memory management in real-time systems is
difficult because most traditional allocation and deallocation
algorithms are unpredictable in terms of their worst-case memory
utilization and execution times. This paper describes recent work on a
new memory management system designed specifically to support
hard-real-time allocation, automatic garbage collection, and
defragmentation of the free pool. The memory management system, which
consists of special hardware circuits placed between the CPU's
level-two caches and its memory subsystem, offers worst-case allocation
delays of two microseconds and typical memory utilizations that exceed
binary-buddy allocators by over 30\%. Commercial implementations of this
technology are currently under development.}
}

@article{nils96,
title = {Issues in the Design and Implementation of Real-Time {J}ava},
author = "Kelvin Nilsen",
journal = {Java Developer's Journal},
month = jun,
year = 1996,
volume = 1,
number = 1,
pages = 44,
URL = {http://www.sys-con.com/java/iss1/real.htm}
}

@article{nils96a,
title = {Starting to {PERC}},
author = "Kelvin Nilsen",
journal = {Java Developer's Journal},
month = jul,
year = 1996,
volume = 1,
number = 2,
pages = 11,
URL = {http://www.sys-con.com/java/iss2/perc.htm}
}

@article{nils96b,
title = {Invited Note: {J}ava for Real-Time},
author = "Kelvin Nilsen",
journal = {Real-Time Systems Journal},
month = sep,
year = 1996,
pages = {197--205},
URL = {http://www.newmonics.com/WebRoot/technologies/java.html#rtsj}
}

@article{nils98,
author = "Kelvin Nilsen",
title = {Adding Real-Time Capabilities to the {J}ava Programming Language},
journal = CACM,
publisher = ACM,
year = 1998,
note = {To appear},
comment = {NewMonics Inc real-time Java}
}

@inproceedings{nish98,
author = {Gor Nishanov and Sibylle Schupp},
title = {Garbage Collection in Generic Libraries},
pages = {86--96},
crossref = {ISMM98},
abstract = {This paper demonstrates a unified and garbage-collector independent
way to describe the information required for precise collection.
Thereby it is possible to construct a library that can be used with
different mostly-copying collectors, without modifying the code of the
library or the garbage collector. The library design presented applies
the adaptor idiom of generic programming which guarantees that no
overhead, in time or space, incurs if the library is used with manual
allocators or with garbage collectors that do not require programmer
cooperation. We illustrate the approach with adaptors to Bartlett's and
to the CMM primary collector. We also show that the Standard
Template Library (STL) can be easily modified to become
garbage-collector aware. }
}

@techreport{nish98a,
author = {Gor Nishanov and Sibylle Schupp},
title = {Design and Implementation of the fgc Garbage Collector},
number = {98--7},
institution = {Rensselaer Polytechnic Institute, NY},
year = 1998,
note = {Extended version (1 December 1999) available},
URL = {http://www.cs.rpi.edu/research/gpg/fgc.html}
}

@techreport{nish88,
author = "Nishida, Kenji and Kimura, Yasunori and Matsumoto, A.",
title = "Evaluation of the Effect of Incremental Garbage Collection by 
{MRB} on {FGHC} Parallel Execution Performance",
institution = "Institute for New Generation Computer Technology",
year = 1988,
type = "ICOT technical report",
number = "TR-394",
month = Jun,
abstract = "The reduction of bus traffic is the key issue to 
improve the performance of shared memory multiprocessors based on 
coherent cache mechanism.  Committed choice logic programming 
lanagues, such as Flat GHC (FGHC), consume memory area very 
rapidly, and require large storage size.  Such large storage size 
requirement affects the total system performance not only by 
frequent global GC, but also by increasing bus traffic especially 
for memory allocation.  Incremental GC reduces the bus traffic 
for memory allocation by decreasing the required storage size. 
It also reduces other bus traffic by decreasing cache misses, 
since the locality of memory references can be enhanced by 
reclamation and reuse of memory cells.
Therefore, incremental GC is the key issue to improve the total 
system performance of committed choice logic programming 
language.  Incremental GC by Multiple Reference Bit (MRB-GC) has 
been proposed as an efficient incremental GC scheme for FGHC.  
The required staorge size is reduced to 30 percent by MRB-GC.  The 
overheads of incremental GC, such as extra memory references for 
management of reference count, is reduced not to affect the 
performance of FGHC execution.  The paper evaluates the effect of 
MRB-GC on the bus traffic of FGHC execution on the shared memory 
multiprocessor.
The evaluation result shows that memory-cache traffic is reduced 
more than expected from decrement of the required storage size.  
Yet the problem on the increase of cache-cache traffic by mutual 
invalidation of cache blocks is revealed."
}

@inproceedings{nish88a,
author = "Nishida, Kenji and Kimura, Yasunori and Matsumoto, A. and A. Goto",
title = "Evaluation of {MRB} Garbage Collection on Parallel Logic 
Programming Architectures",
booktitle = "7th International Conference on Logic Programming, Jerualem",
pages = "83--95",
publisher = MIT,
month = jun,
year = 1988
}

@article{nitz91,
author = {B. Nitzberg and V. Lo},
title = {Distributed Shared Memory: A Survey of Issues and Algorithms},
journal = {IEEE Computer},
pages = {52--60},
year = 1991
}

@inproceedings{niwa86,     
title = "Garbage Collector with Area Optimization for {FACOM} {ALPHA}.",
author = "M. Niwa and M. Yuhara and K. Hayashi and A. Hattori",
booktitle = "{COMPCON} Spring 86: Thirty-First {IEEE} Computer Society 
International Conference. {S}an {F}rancisco, 1986 {M}arch 3--6",
publisher = IEEE, 
year = 1986,
abstract = {The FACOM ALPHA is a high-speed list processing machine that can
execute LISP and PROLOG programs.  It is a back-end processor connected to 
a Fujitsu M series mainframe computer or S series superminicomputer.  The 
garbage collector and memory management of the FACOM ALPHA are discussed.  A 
feature of the FACOM ALPHA garbage collector is that the sizes of the memory
areas for different types of data are dynamically adjusted to optimize the 
configuration
for each user program.  The algorithm used by this memory size adjustment
function is presented and its effectiveness is evaluated.  Measurements
indicate that the algorithm reduces the number of garbage collection calls
while improving memory-use efficiency.}
}


@book{nobl00,
title = {Small Memory Software: Patterns for Systems with Limited Memory},
author = {James Noble and Charles Weir and Duane Bibby},
publisher = AW,
year = 2000,
ISBN = {201596075},
pages = 288
}

@inproceedings{norc03,
author = {Norcross, Stuart and Morrison, Ron and Munro, David S. and Detmold, Henry},
title = {Implementing a Family of Distributed Garbage Collectors},
booktitle = {Proceedings of the 2003 Australasian Computer Science Conference, (ACSC2003)},
address = {Adelaide}, 
month = jan,
year = 2003, 
pages = {161--170}
}

@mastersthesis{nori79,
title = "A Storage Reclamation System for an Applicative Multiprocessor System",
author = "A. K. Nori",
school = "University of Utah",
address = "Salt Lake City, Utah",
year = 1979
}
 

@inproceedings{nort87,
author = "S. C. North and John H. Reppy",
title = "Concurrent Garbage Collection on Stock Hardware",
crossref = "FPCA87",
pages = "113--133",
abstract = "the design and implementation of a memory
management system for Pegasus, a system that supports the 
implementation of programming environments and other interactive applications
on single-user workstations.
Variation of (broo84), itself a variation of Baker."
}

@techreport{nuth87,
author = "Peter R. Nuth",
title = "Communication Patterns in a Symbolic Multiprocessor",
institution = MITLCS,
number = "MIT/LCS/TR--395",
month = jun,
year = 1987
}

@article{nuth89,
author = "Peter R. Nuth and Robert H. Halstead",
title = "A Study of {LISP} on a Multiprocessor (Preliminary Version)",
journal = "Lisp Pointers",
publisher = ACM,
volume = 2,
number = "3--4",
pages = "15--32",
year = 1989
}

@book{occa88,
title = "The occam 2 Reference Manual",
author = "inmos",
publisher = PH,
year = 1988
}

@phdthesis{ofar92,
author = "O'Farrell, William Gerald",
title = "Garbage Collection Algorithms for the Connection Machine",
year = 1991,
school = "Syracuse University"
}

@article{ogur89,
author = "Ogura, Takeshi and Yamada, Junzo and Yamada, Shin-Ichiro and Tan-No, Masa-Aki",
address = "NTT LSI Lab, Atsugi, Japan",
title = "20-kbit Associative Memory {LSI} for Artificial Intelligence Machines",
year = 1989,
journal = "IEEE Journal of Solid-State Circuits",
publisher = IEEE,
volume = 24,
number = 4,
month = aug,
abstract = {A 20-kb (512 words multiplied by 40 b) CMOS associative-
memory LSI is described. This LSI performs large-scale
parallelism for highly efficient associative operations in
artificial intelligence machines. Relational search, large-
bit-length data treatment, and quick garbage collection are
realized on the single-chip associative-memory LSI. A cell
array structure has been designed in order to reduce the
chip area. A newly designed simple accelerator circuit
allows for high-speed search operations. The LSI is
fabricated using 1.2- mu m double-aluminum-layer CMOS
process technology. 284,000 devices have been integrated on
a 5.3 multiplied by 7.9-mm**2 chip. The measured minimum
cycle time and power dissipation at 10-MHz operation are 85
ns and 250 mW, respectively. The associative memory, with
its highly efficient associative operation capabilities,
promises to be a large step toward the development of high-
performance artificial intelligence machines. }
}

@article{olde85,
author = "Rod R. Oldehoeft and S. J. Allan",
title = "Adaptive Exact-Fit Storage Management",
journal = CACM,
publisher = ACM,
volume = 28,
number = 5,
pages = "506-511",
month = may,
year = 1985
}

@inproceedings{olde92,
author = {William J. Older and John A. Rummell},
title = {An Incremental Garbage Collector for {WAM}-Based {P}rolog},
booktitle = {Proceedings of ICLP92 International Conference on Logic Programming},
address = {Washington, DC},
pages = {369--383},
year = 1992
}


@manual{OMG97,
organization = {Object Management Group},
key = {OMG},
title = {Garbage Collection of {CORBA} Objects},
note = {Draft {RFP}},
year = 1997,
URL = {http://www.omg.org/docs/orbos/orbos/1997/97-08-08.pdf}
}

@manual{omoh91,
title = "The {S}ather Language",
author = "Stephen M. Omohundro",
organization = "ICSI, Berkeley",
year = 1991,
comment = "Sather is an object oriented language designed to be simple,
     efficient, safe, and non-proprietary. It was originally
     envisioned as a ``cleaned-up'' version of Eiffel, addressing
     perceived failures in simplicity and efficiency. The first public
     implementation (Sather 0) was first released to the public by ICSI
     in 1991. Shortly after, a compiler group at the University of
     Karlsruhe created the first native code compiler.

     A major effort then began to redesign the language to correct shortcomings 
     in Sather 0 and to make Sather suitable for
     general-purpose, large scale programming. In part because each compiler 
     group was building a compiler for a moving
     design target, the two parallel efforts resulted in two dialects, Sather 1
      and Sather K. This report analyzes the essential
     causes of the differences, which result from differences in each group's 
     goals. <http://www.icsi.berkeley.edu/~davids/tr-96-037.ps.gz>" 
}

@article{onod93,
title = "A Generational and Conservative Copying Collector for Hybrid Object-oriented Languages",
author = "Tamiya Onodera",
institution = "IBM Tokyo research Lanboratory",
journal = SPE,
publisher = Wiley,
volume = 23,
number = 10,
pages = "1077--1093",
month = oct,
year = 1993
}

@phdthesis{oper89,
title = "Optimization and Garbage Collection in {A}da Programs on Shared 
Memory Computers",
author = "H. L. Operowsky",
school = "New York Academy of Sciences",
address = "New York",
year = "1989",
other = "UMI order no:  GAX89-16082"
}

@manual{optimizeit,
title = "OptimizeIt",
key = "OptimizeIt",
organization = {Borland},
note = {http://www.optimizeit.com},
URL = {http://www.optimizeit.com},
comment = {Profiling and debugging tools for {J}ava (formerly published by VMGEAR)}
}

@book{orga83,  
title = "A Programmer's View of the {I}ntel 432 System",
author = "E. I. Organick",
publisher = MGH,
year = 1983,
pages = "418",
isbn = "0--07--047719--1",
abstract = {Chapter 9 describes the extensive memory
management facilities of iMAX and the supporting hardware. These include
facilities to support the stack and heap memory resources required, for
example, by executing ADA programs. In addition, memory management supports
an on-the-fly garbage collector, dynamic memory compaction, and, where
configured, a virtual memory management subsystem.
Almost all references are numbered wrongly; the reference numbers should
be increased by a number from 0 to 4.
Sometimes the text looks like a eulogy of Intel.
It is difficult to discern whether the description of
the design of the Intel 432 system coincides with reality; it could be
viewed also as a subsequent interpretation by the author.
As mentioned above, the chapters on ADA consume too much space.
The book is written in a lucid manner. It should be of interest to
different clienteles: designers of operating systems, designers of
programming languages, computer architects, and programmers; they all 
could learn more about the dependencies between programming languages and
computer systems.}
}

@inproceedings{ossi02,
title = {A Parallel, Incremental and Concurrent {GC} for Servers},
author = {Yoav Ossia and Ori Ben-Yitzhak and Irit Goft and Elliot K. Kolodner and Victor Leikehman and Avi Owshanko},
crossref = {PLDI02},
pages = {129--140},
abstract = {Multithreaded applications with multi-gigabyte heaps
running on modern servers provide new challenges for garbage collection
(GC).  The challenges for "server-oriented" GC include: ensuring short
pause times on a multi-gigabyte heap, while minimizing throughput
penalty, good scaling on multiprocessor hardware, and keeping the
number of expensive multi-cycle fence instructions required by
weak-ordering to a minimum. We designed and implemented a fully
parallel, incremental, mostly concurrent collector, which employs
several novel techniques to meet these challenges. First, it combines
incremental GC to ensure short pause times with concurent low-priority
background GC threads to take advantage of processor idle time. Second,
it employs a low-overhead work packet mechanism to enable full
parallelism among the incremental and concurrent collecting threads and
ensure load balancing. Third, it reduces memory fence instructions by
using batching techniques: one fence for each block of small objects
allocated, one fence for each group of objects marked, and no fence at
all in the write barrier. When compared to the mature well-optimized
parallel stop-the-world mark-sweep collector already in the IBM Jvm,
our collector prototype reduces the maximum pause time from 284 ms to
101 ms, and the average pause time from 266 ms to 66 ms while only
losing 10\% throughput when running the SPECjbb2000 benchmark on a 256
MB heap on a 4-way 550 MHz Pentium multiprocessor.}
}

@misc{otoo90,
author = "James W. O'Toole",
title = "Garbage Collecting Locally",
note = "Area Exam, Department of Electrical Engineering and Computer Science, MIT",
month = dec,
year = 1990,
URL = "http://www.psrg.lcs.mit.edu/ftpdir/james/papers/RevisedGcl.txt"
}

@techreport{otoo93,
title = "Concurrent Replicating Garbage Collection",
author = "James W. O'Toole and Scott M. Nettles",
type = "Technical Report",
number = "MIT--LCS--TR--570 and CMU--CS--93--138",
institution = "MIT and CMU",
year = 1993,
URL = "ftp://reports.adm.cs.cmu.edu/usr/anon/1993/CMU-CS-93-138.ps",
note = "Also LFP94 and OOPSLA93 Workshop on Memory Management and Garbage Collection",
}

@inproceedings{otoo93a,
title = "Concurrent Compacting Garbage Collection of a Persistent Heap",
author = "James W. O'Toole and Scott M. Nettles and David Gifford",
crossref = "SOSP93",
pages = "161--174",
URL = "http://www-psrg.lcs.mit.edu/ftpdir/pub/james/sosp93.ps",
note = "Also MIT/CMU Technical report MIT--LCS--TR--569. The same paper as \cite{nett93b}",
comment = "Client threads read and write the heap in primary memory and can
independently commit or abort writes; when committed they are preserved in
stable storage. Clients can freely access the heap during GC because a replica
is created."
}

@techreport{otoo93b,
title = "Real-Time Replication {GC}: An Implementation Report",
author = "James W. O'Toole and Scott M. Nettles",
number = "MIT--LCS--TR--568 and CMU--CS--93--136",
institution = "MIT and CMU",
year = 1993,
note = "WWW page says this is unpublished."
}

@techreport{otoo93c,
title = "Garbage Collecting an Object Cache",
author = "James W. O'Toole",
number = "MIT/LCS/TM--485",
institution = MIT,
URL = "http://www.psrg.lcs.mit.edu/ftpdir/james/papers/replgc-cache.txt",
month = apr,
year = 1993,
}


@article{owic76,
author = "Susan Owicki and David Gries",
title = "Verifying Properties of Parallel Programs: An Axiomatic Approach",
journal = CACM,
publisher = ACM,
volume = 19,
number = 5,
month = May,
year = 1976,
pages = "279--285",
abstract = {An axiomatic method for proving a number of properties
of parallel programs is presented. Hoare has given a set of axioms for
partial correctness, but they are not strong enough in most cases.
This paper defines a more powerful deductive system which is in some
sense complete for partial correctness. A crucial axiom provides
for the use of auxiliary variables, which are added to a parallel
program as an aid to proving it correct.
The information in a partial correctness proof can be used to prove
such properties as mutual exclusion, freedom from deadlock, and
program termination.
Techniques for verifying these properties are presented and illustrated
by application to the dining philosophers problem.},
comments = {Used in \cite{grie77} to prove the correctness of the on-the-fly algotithm in \cite{dijk76b}}
}


@inproceedings{owic81,
title = "Making the World Safe for Garbage Collection",
author = "Susan Owicki",
crossref = "POPL81",
pages = "77--86",
}


@article{owic82,
title = "Proving Liveness Properties of Concurrent Programs",
author = "Susan Owicki and Leslie Lamport",
pages = "455--495",
journal = TOPLAS,
publisher = ACM,
year = 1982,
month = jul,
volume = 4,
number = 3,
comments = {see \cite{rame83}},
}


@techreport{ozaw89,
author = "Ozawa, Toshihiro and Hosoi, Akira and Hattori, Akira.",
title = "Generation Type Garbage Collection for Parallel Logic Languages",
institution = "Institute for New Generation Computer Technology",
year = 1989,
type = "ICOT technical report",
number = "TR-512",
month = Oct,
abstract = {This paper presents a garbage collection (GC) method 
for parallel logic programming languages.  Paralle logic 
languages require large amounts of data since logic variables can 
have only one value.  Efficient memory management is important 
for an efficient language processor.  In the parallel loge 
language Flat Guarded Horn Clauses (FGHC), the amount of live 
data is always small compared to the total amount of data 
allocated.  These are two kinds of data: short-term and long-
term.  We concluded that garbage collection using only 2 
generations best suits this kind of language.  We call our
garbage collection method "2-generation garbage collection".
Short-term data is garbage collected back into the 1st generation 
garbage collection and long-term data is collected into the 2nd 
generation garbage collection.  This method is efficient 
independent of the ratio of the amount of live data to heap size. 
When this ratio is high, our method is especially good, reducing 
the amount of data copied by a factor of 10, compared to simple 
copying garbage collection.}
}

@article{page82,
author = "Ivor P. Page",
title = "Optimal Fit of Arbitrary Sized Segments",
journal = CompJ,
publisher = BCS,
volume = 25,
number = 1,
month = jan,
year = 1982
}

@article{page84,
author = "Ivor P. Page",
title = "Analysis of a Cyclic Placement Scheme",
journal = CompJ,
publisher = BCS,
volume = 27,
number = 1,
month = jan,
year = 1984,
pages = "18--25"
}

@article{page86,
author = "Ivor P. Page and Jeff Hagins",
title = "Improving the Performance of Buddy Systems",
journal = IEEETransComp,
publisher = IEEE,
volume = "C-35",
number = 5,
month = may,
year = 1986,
pages = "441--447"
}

@inproceedings{pala94,
title = "Evaluating Stream Buffers as a Secondary Cache Replacement",
author = "S. Palacharla and R. E. Kessler",
crossref = "ISCA94",
pages = {24--33}
}

inproceedings{pall88,
title = "Multiprocessor {S}malltalk: A Case Study of a Multiprocessor-Based
Programming Environment",
author = "Joseph Pallas and David Ungar",
crossref = "PLDI88",
}

@techreport{pan86,
author = "Pan, Wilson",
title = "Designing an Operating System Kernal Based on Concurrent Garbage 
Collection",
institution = "University of Iowa, Department of Computer Science",
year = 1986,
number = "86-04"
}

@mastersthesis{panz86,
author = "Panzer, Edward J.",
title = "Execution Time of Marking Algorithms During Garbage Collection 
in {LISP}",
year = 1986,
school = "California State Polytechnic University",
}

@incollection{pare68,
author = "R. J. Parents",
title = "A Simulation Oriented Memory Allocation Algorithm",
booktitle = "Simulation Programming Languages",
editor = "J. M. Buxton",
publisher = "North-Holland",
address = "Amsterdam", 
year = 1968, 
pages = "199--209",
}


@phdthesis{park91,
author = "Young G. Park",
title = "Semantic Analyses for Storage Management Optimizations in Functional Language Implementations",
school = "New York University",
year = 1991
}

@inproceedings{park91a,
author = "Young Gil Park and Benjamin Goldberg",
title = "Reference Escape Analysis: Optimizing Reference Counting
based on the Lifetime of References",
booktitle = "Symposium on Partial Evaluation and Semantics-Based Program Manipul
ation",
address = "New Haven, Connecticut",
month = jun,
year = 1991,
pages = "178--189"
}

@article{park92,
title = "Escape Analysis on Lists",
author = "Young G. Park and Benjamin Goldberg",
pages = "116--127",
journal = SIGPLAN,
month = Jun,
volume = 27,
number = 7,
address = "San Francisco, {U.S.A.}",
publisher = ACM,
year = 1992,
comment = "Higher order programming languages tend to allocate
objects at a very high rate.  Many of the objects are included in
lists and this paper shows how an analysis can be done to see how far
from the spine of a list a function gets, and this what part of a list
may escape (and hence be required on the heap rather than the stack).
Other optimizations include reuse of lists."
}

@article{park95,
author = "Young G. Park and Benjamin Goldberg",
title = {Static Analysis for Optimising Reference Counting},
journal = IPL,
volume = 55,
number = 4,
month = aug,
year = 1995,
pages = {229-234}
}

@article{pati97,
author = {Harish G. Patil and Charles N. Fischer},
title = {Low-cost, Concurrent Checking of Pointer and Array Accesses in {C} Programs},
journal = SPE,
volume = 27,
number = 12,
pages = {87--110},
month = dec,
year = 1997
}

@techreport{patt83,
author = "David A. Patterson",
title = "Smalltalk on a {RISC}: Architectural Investigations",
institution = "Computer Science Division, University of California, Berkeley",
number = "CS292R",
year = 1983,
month = apr
}

@inproceedings{pauw93,
author = {de Pauw, W. and R. Helm and D. Kimelman and J. Vlissides},
title = {Visualizing the Behaviour of Object-Oriented Systems},
crossref = {OOPSLA93},
pages = {326--337},
URL = {http://www.research.ibm.com/jinsight/papers/oopsla93.ps}
}

@incollection{pauw97,
author = {de Pauw, W. and D. Kimelman and J. Vlissides},
title = {Visualizing Object-Oriented Software Execution},
booktitle = {Software Visualization},
publisher = MIT,
editor = {John T. Stasko and John B. Domingue and Marc H. Brown and Blaine A. Price},
year = {1997},
URL = {http://www.research.ibm.com/jinsight/papers/coots98.pdf}
}

@inproceedings{pauw99,
author = {de Pauw, W. and G. Sevitski},
title = {Visualizing Reference Patterns for Solving Memory Leaks in {J}ava},
crossref = {ECOOP99},
pages = {116--134},
URL = {http://www.research.ibm.com/jinsight/papers/refpat.pdf}
}

@article{pauw00,
author = {de Pauw, W. and G. Sevitski},
title = {Visualizing Reference Patterns for Solving Memory Leaks in {J}ava},
journal = {Concurrency: Practice and Experience},
publisher = Wiley,
year = 2000,
volume = 12,
pages = {1431-1454},
URL = {http://www.research.ibm.com/jinsight/papers/CPE2000.pdf}
}

@inproceedings{pauw01,
author = {de Pauw, W. and N. Mitchell and M. Robillard G. Sevitski and H. Srinivasan},
title = {Drive-by Analysis of Running Programs},
booktitle = {Proceedings for Workshop on Software Visualization, International
Conference on Software Engineering},
address = {Toronto},
month = may,
year = 2001,
URL = {http://www.research.ibm.com/jinsight/papers/ICSE2001.pdf}
}

@misc{pawl,
title = {Reference Objects and Garbage Collection},
author = {Monica Pawlam},
year = 1999, 
URL = {http://developer.java.sun.com/developer/technicalArticles//ALT/RefObj/index.html},
comment = {Whether it is in-depth or not....},
howpublished = {Article on Sun's Java Developer Connection site}
}

@techreport{paz03,
author = {Harel Paz and David F. Bacon and Elliot K. Kolodner and Erez Petrank and V.T. Rajan},
title = {Efficient On-the-Fly Cycle Collection},
number = {CS--2003--10},
institution = {Technion University},
year = 2003,
URL = {http://www.cs.technion.ac.il/~erez/Papers/CycleCollection.ps}
}


@article{pear96,
title = {Garbage collection with pointers to individuals cells},
author = {B. Pearlmutter},
journal = CACM,
volume = 39,
number = 12,
month = dec,
year = 1996
}

@inproceedings{peir98,
title = {Capturing Dynamic Memory Reference Behavior with Adaptive Cache Topology},
author = {J. Peir and Y. Lee and W. Hsu},
crossref = {ASPLOS98}
}

@techreport{peng89,
author = "Peng, Chih-Jui and Gurindar S. Sohi",
title = "Cache Memory Design Considerations to Support Languages with
Dynamic Heap Allocation",
number = 860,
institution = {Computer Sciences Department, University of Wisconsin-Madison},
month = jul,
comment = {cache performance of heap-intensive programs is bad w/conventional
caches (assumes eden > cache); computes improvements with "allocate in
cache" operation and in-cache GC; nice systematic treatment,
interesting arguments},
year = 1989
}


@techreport{pepe88,
author = "E. J. H. Pepels and van Eekelen, M. C. J. D. and M. J. Plasmeijer",
title = "A Cyclic Reference Counting Algorithm and its Proof",
institution = "Computing Science Department",
address = "University of Nijmegen",
year = "1988",
number = "88--10",
comments = {A correct and terminating version of the algorithm in
\cite{brow85} and its proof. Based on \cite{salk87}.
Complexity is at least exponential.},
}

@inproceedings{pers99,
title = {Live Memory Analysis for Garbage Collection in Embedded Systems},
author = {Patrik Persson},
pages = {45--54},
crossref = {LCTES99}
}

@article{pete77,
author = "J. L. Peterson and T. A. Norman",
title = "Buddy Systems",
journal = CACM,
publisher = ACM,
volume = 20,
number = 6,
pages = "421--431",
year = 1977
}

@inproceedings{pete03,
title = {A Type Theory for Memory Allocation and Data Abstraction},
author = {Leaf Peterson and Robert Harper and Karl Crary and Frank Pfenning},
crossref = {POPL03}
}

@article{peti98,
author = {Alexandre Petit-Bianco},
title = {Java Garbage Collection for Real-Time Systems},
journal = Dobbs,
month = oct,
year = 1998,
URL = {http://www.ddj.com/ddj/1998/1998_10/LEAD/LEAD.htm}
}

@article{peyt92,
author = "Peyton Jones, Simon L.",
title = "Implementing Lazy Functional Languages on Stock Hardware: The
{S}pineless {T}agless {G}-Machine",
journal = JFP,
publisher = CUP,
volume = 2,
number = 2,
month = apr,
year = 1992,
pages = "127--202"
}

@techreport{peyt98,
author = {Peyton Jones, Simon L. and Norman Ramsey},
title = {Machine-Independent Support for Garbage Collection, Debugging, Exception Handling and Concurrency},
number = {CS--98--19},
institution = {University of Virginia},
URL = {http://www.eecs.harvard.edu/~nr/pubs/c--rti-abstract.html},
month = aug,
year = 1998,
abstract = {For a compiler writer, generating good machine code for a
variety of platforms is hard work. One might try to reuse a
retargetable code generator from another compiler, but code generators
are complex and difficult to use, and they limit one's choice of
implementation language. One might try to use C as a portable assembly
language, but C limits the compiler writer's flexibility and the
performance of the resulting code. The wide use of C, despite these
drawbacks, argues for a portable assembly language.

C{-}{-} is a new language designed expressly as a portable assembly
language. C{-}{-} eliminates some of the performance problems associated
with C, but in its originally-proposed form it does not provide
adequate support for garbage collection, exception handling, and
debugging. The problem is that neither the high-level compiler nor the
C{-}{-} compiler has all of the information needed to support these
run-time features. This paper proposes a three-part solution: new
language constructs for C{-}{-}, run-time support for C--, and restrictions
on optimization of C{-}{-} programs.

The new C{-}{-} language constructs enable a high-level compiler to
associate initialized data with spans of C{-}{-} source ranges and to
specify ``alternate continuations'' for calls to procedures that might
raise exceptions. The run-time support is an interface (specified in C)
that the garbage collector, exception mechanism, and debugger can use
to get access to both high-level and low-level information, provided
that the C{-}{-} program is suspended at a safe point. High- and low-level
information is coordinated by means of the C{-}{-} spans and a common
numbering for variables. Finally, the C{-}{-} optimizer operates under the
constraints that the debugger or garbage collector can change the
values of local variables while execution is suspended, and that a
procedure call with alternate continuations can return to more than one
location.

This three-part solution also provides adequate support for
concurrency, so the paper illustrates the problem and the proposed
solution with examples from garbage collection, exception handling,
debugging, and threads. The paper also includes a model of the dataflow
behavior of C{-}{-} calls.

A number of open problems remain. The most serious have to do with
apparent redundancies among spans and safe points, and with the
interaction of debugging support with optimization.

This paper is very much work in progress. We are not yet satisfied with
the solutions we've come up with. Perhaps you can help improve it. }
}

@inproceedings{peyt99,
author = {Simon Peyton Jones and Norman Ramsey and Fermin Reig},
title = {C--: a Portable Assembly Language that Supports Garbage Collection},
booktitle = {International Conference on Principles and Practice of Declarative Programming},
month = sep,
year = 1999,
URL = {http://www.eecs.harvard.edu/~nr/pubs/c--gc-abstract.html},
abstract = {For a compiler writer, generating good machine code for a
variety of platforms is hard work. One might try to reuse a
retargetable code generator, but code generators are complex and
difficult to use, and they limit one's choice of implementation
language. One might try to use C as a portable assembly language, but C
limits the compiler writer's flexibility and the performance of the
resulting code. The wide use of C, despite these drawbacks, argues for
a portable assembly language. C{-}{-} is a new language designed expressly
for this purpose. The use of a portable assembly language introduces
new problems in the support of such high-level run-time services as
garbage collection, exception handling, concurrency, profiling, and
debugging. We address these problems by combining the C{-}{-} language with
a C{-}{-} run-time interface. The combination is designed to allow the
compiler writer a choice of source-language semantics and
implementation techniques, while still providing good performance. }
}

@book{pfal77,
author = "J. L. Pfalz",
title = "Computer Data Structures",
publisher = MGH,
year = 1977,
comments = {book with sections on garbage collection},
}

@inproceedings{phal95,
title = "A Miss History-based Architecture for Cache Prefetching",
author = "Vidyadhar Phalke and B. Gopinath",
address = "Department of Computer Science and Department of Electrical and Computer Eng.,
Rutgers University, Piscataway, NJ",
crossref = "IWMM95",
}

@article{phil00,
title = {Cooperating Distributed Garbage Collectors For Clusters and Beyond},
author = {Michael Philippsen},
journal = {Concurrency: Practice and Experience},
volume = 12,
number = 7,
pages = {595--610},
month = may,
year = 2000,
URL = {http://wwwipd.ira.uka.de/~phlipp/mypapers/dgc.ps.gz},
note = {Also published in 8th Int. Workshop on Compilers for Parallel Computers CPC'2000, Aussois, France},
}

@article{phip99,
author = {G. Phipps},
title = {Comparing Observed Bug and Productivity Rates for {J}ava and {C++}},
journal = SPE,
pages = {345--358},
volume = 29,
number = 4,
month = apr,
year = 1999
}

@techreport{piep93,
title = {Compiler Techniques for Managing Data Motion},
author = {Pieper},
institution = CMU,
month = dec,
year = 1993,
number = {CMU-CS-93-217},
abstract = {Software caching, automatic algorithm blocking, and data overlays are 
different names for the same problem: compiler management of data movement 
throughout the memory hierarchy. Modern high-performance architectures often 
omit hardware support for moving data between levels of the memory hierarchy: 
iWarp does not include a data cache, and Cray supercomputers do not have 
virtual memory. These systems have effectively traded a more complicated 
programming model for performance by replacing a hardware-controlled memory 
hierarchy with a simple fast memory. The simpler memories have less logic in 
the critical path, so the cycle time of the memories is improved.
For programs which fit in the resulting memory, the extra performance is 
great. Unfortunately, the driving force behind supercomputing today is a class 
of very large scientific problems, both in terms of computation time and in 
terms of the amount of data used. Many of these programs do not fit in the 
memory of the machines available. When architects trade hardware support for 
data migration to gain performance, control of the memory hierarchy is left to 
the programmer. Either the program size must be cut down to fit into the 
machine, or every loop which accesses more data than will fit into memory must 
be restructured by hand. This thesis describes how a compiler can relieve the 
programmer of this burden, and automate data motion throughout the memory 
hierarchy without direct hardware support.
This works develops a model of how data is accessed within a nested loop by 
typical scientific programs. It describes techniques which can be used by 
compilers faced with the task of managing data motion. The concentration is on 
nested loops which process large data arrays using linear array subscripts. 
Because the array subscripts are linear functions of the loop indices and the 
loop indices form an integer lattice, linear algebra can be applied to solve 
many compilation problems.
The approach it to tile the iteration space of the loop nest. Tiling allows 
the compiler to improve locality of reference. The tiling basis matrix is 
chosen from a set of candidate vectors which neatly divide the data set. The 
execution order of the tiles is selected to maximize locality between tiles. 
Finally, the tile sizes are chosen to minimize execution time.
The approach has been applied to several common scientific loop nests: 
matrix-matrix multiplication, QR-decomposition, and LU-decomposition. In 
addition, an illustrative example from the Livermore Loop benchmark set is 
examined. Although more compiler time can be required in some cases, this 
technique produces better code at no cost for most programs.}
}

@article{piqu90,
author = {Jos\'{e} M. Piquer},
title = {Un {GC} Parall\`{e}le pour un {Lisp} Distribu\'{e}},
journal = {Journ\'{e}es francophones des langages applicatifs},
month = Jan,
year = 1990,
note = "Also Bigre 69, July 1990"
}

@inproceedings{piqu90a,
author = {Jos\'{e} M. Piquer},
title = "Sharing Date Structures in Distributed {L}isp",
booktitle = "Proceedings of High Performance and Parallel Computing in Lisp Workshop",
address = "London",
month = Nov,
year = 1990
}

@inproceedings{piqu91,
title = "Indirect Reference Counting: A Distributed Garbage
Collection Algorithm",
author = {Jos\'{e} M. Piquer},
crossref = "PARLE91",
comment = "Keep indirect reference counts at each node. Does not need to create
indirection cells (cf. weighted RC). Cannot handle cycles.
Appears to use send more messages than weighted RC."
}

@phdthesis{piqu91a,
author = {Jos\'{e} M. Piquer},
title = {Parall\'{e}lisme et Distribution en {L}isp},
school = "Ecole Polytecnique, Massy, France",
month = Jan,
year = 1991
}


@inproceedings{piqu92,
title = "Dynamic Revision of Choice Points During Garbage Collection in {P}rolog",
author = {Jos\'{e} M. Piquer},
address = "University of Aix-Marseille II, France",
crossref = "IWMM92",
}

@inproceedings{piqu95,
title = "Indirect Mark and Sweep: A Distributed {GC}",
author = {Jos\'{e} M. Piquer},
address = "Universidad de Chile, Santiago",
crossref = "IWMM95",
}

@article{piqu96,
title = "Indirect Distributed Garbage Collection: Handling Object Migration",
author = {Jos\'{e} M. Piquer},
journal = TOPLAS,
pages = "615--647",
month = sep,
year = 1996,
volume = 18,
number = 5,
}

@inproceedings{piri98,
author = {Pekka P. Pirinen},
title = {Barrier Techniques for Incremental Tracing},
pages = {20--25},
crossref = {ISMM98},
abstract = {This paper presents a classification of barrier techniques
for interleaving tracing with mutator operation during an incremental
garbage collection. The two useful tricolour invariants are derived
from more elementary considerations of graph traversal. Barrier
techniques for maintaining these invariants are classified according to
the action taken at the barrier (such as scanning an object or changing
its colour), and it is shown that the algorithms described in the
literature cover all the possibilities except one. Unfortunately, the
new technique is impractical. Ways of combining barrier techniques are
also discussed. }
}

@inproceedings{pitt85,
title = "Towards a Real Time Garbage Collector for {PROLOG}",
author = "Edwin Pittomvils and Maurice Bruynooghe and Yves D. Willems",
booktitle = "1985 Symposium on Logic Programming. Boston, 1985 Jul 15--18",
pages = {185--198},
publisher = IEEE, 
year = 1985,
abstract = {Inspired by the work of H. Lieberman and C. Hewitt
(1983), which describes a garbage collector which takes into account the
lifetimes of objects, the authors were able to improve the garbage collection
algorithm as described by M. Bruynooghe (1982).  The improved algorithm reduces
the time needed to mark and compact the storage area by limiting its activity
to relatively small segments of memory.  It can easily be extended to a real-
time garbage collector that preserves the important properties of increasing
the locality of references and allowing for the recuperation of memory 
during backtracking.}
}

@inproceedings{pium95,
author = "Ian Piumarta",
title = "SSP Chains -- from mobile objects to mobile computing (Position Paper)",
booktitle = "{ECOOP} Workshop on Mobility, 1995",
year = 1995,
URL = "http://www-sor.inria.fr/SOR/docs/SSPMobPP_ecoop95-mobility-pp.html"
}

@inproceedings{pium95a,
title = {Garbage Collection in Distributed Object Systems},
author = {Ian Piumarta and Marc Shapiro and Paulo Ferreira},
booktitle = {Workshop on Reliability and Scalability in Distributed Object Systems, OOPSLA'95},
address = {Austin, TX},
month = oct,
year = 1995,
URL = {http://cretina.inesc.pt/people/pjpf-home/oopsla95-dist-piumarta.ps}
}

@article{pixl88,
title = "An Incremental Garbage Collection Algorithm For Multi-Mutator 
Systems",
author = "C. Pixley",
address = "Microelectr  Comp Technol Corp, VLSI Computer Aided Design Program,  
3500 W B Alcones Center Dr, Austin, Texas, 78759",
journal = "Distributed Computing",
year = 1988,
volume = 3,
number = 1,
pages = "41--50"
}


@inproceedings{plai91,
author = {David Plainfoss\'{e} and Marc Shapiro},
title = "Distributed Garbage Collection in the System is Good",
crossref = "IWOOOS91",
pages = "94--99",
URL = "http://www-sor.inria.fr/SOR/docs/DGCOS_iwooos91.html"
}

@inproceedings{plai91a,
author = {David Plainfoss\'{e} and Marc Shapiro},
title = "A Distributed Garbage Collection as an Operating System Component",
crossref = "OOPSLA91-gc",
}


@inproceedings{plai92,
title = "Experience with Fault-Tolerant Garbage Collection in a Distributed {L}isp System",
author = {David Plainfoss\'{e} and Marc Shapiro},
address = "INRIA, France",
URL = "http://www-sor.inria.fr/SOR/docs/EFTGC_iwmm92.html",
crossref = "IWMM92",
comment = "Local GC + distributed reference counting. Does not collect cycles."
}

@inproceedings{plai92a,
author = {David Plainfose{\'e} and Marc Shapiro},
title = "A Distributed {GC} in an Object-Support Operating System",
URL = "http://www-sor.inria.fr/SOR/docs/DGCOOS_iwooos92.html",
crossref = "IWOOOS92",
}

@inproceedings{plai94,
title = "A Survey of Distributed Garbage Collection Techniques",
author = {David Plainfose{\'e} and Marc Shapiro},
booktitle = "Second Closed {BROADCAST} Workshop",
organization = "Broadcast Basic Research Action",
address = "Bruxelles (Belgique)",
month = nov,
URL = "http://www-sor.inria.fr/SOR/docs/DGC-survey.html",
year = 1994,
note = "Superseded by \cite{plai95}"
}

@phdthesis{plai94a,
author = {David Plainfoss\'{e}},
title = "Distributed Garbage Collection and Reference Management in the {S}oul Object Support System", 
school = {Universit\'{e} Paris-6, Pierre-et-Marie-Curie},
year = 1994,
address = "Paris (France)",
month = jun,
note = "Available from INRIA as TU-281, ISBN-2-7261-0849-0",
URL = "http://www-sor.inria.fr/SOR/docs/Soul_plainfosse-thesis.html"
}

@inproceedings{plai95,
title = "A Survey of Distributed Garbage Collection Techniques",
author = {David Plainfoss\'{e} and Marc Shapiro},
booktitle = "Proceedings of the International Workshop on Memory Management",
address = "Kinross, Scotland",
publisher = SV,
series = LNCS,
volume = 986,
month = sep,
year = 1995,
URL = "http://www-sor.inria.fr/SOR/docs/SDGC_iwmm95.html"
}

@inproceedings{plak00,
author = {Manoj Plakal and Charles N. Fischer},
title = {Concurrent Garbage Collection Using Program Slices on Multithreaded Processors},
crossref = {ISMM2000},
abstract = {
We investigate reference counting in the context of a multithreaded
architecture by exploiting two observations: (1) reference-counting can be
performed by a transformed mutator slice that isolates heap references, and
(2) hardware trends indicate that microprocessors in the near future will
soon be able to execute multiple concurrent threads on a single chip. We
generate a reference-counting collector as a transformed program slice of
an application and then execute this slice in parallel with the application as a
"run-behind" thread. Preliminary measurements of collector overheads are
encouraging. 
}
}

@article{plau94,
title = "Managing the Heap",
author = "P.J. Plauger",
journal = "Journal of {C} Language Translation",
volume = 6,
number = 1,
month = sep,
year = 1994,
comment = "How to implement malloc, free, and friends"
}

@inproceedings{poll82,
author = "F. J.  Pollack and G. W. Cox and D. W. Hammerstein and K. C. Kahn and K. K. Lai and J. R. Rattner",
title = "Supporting {Ada} Memory Management in the {iAPX--432}",
pages = "117--131",
crossref = "ASPLOS82",
comments = "Describes a HW/SW implementation of the on-the-fly garbage collection
algorithm in \cite{dijk78}"
}

@article{pome85,
title = "Prefetching Pacing Buffer to Reduce Cache Misses",
author = "J. H. Pomerene and T. R. Puzak and R. N. Rechtshaffen and F. J. Sparacio",
journal = "IBM Technical Disclosure Bulletin",
volume = 27,
number = 5,
year = 1985,
pages = "2773--2774"
}

@article{pome85a,
title = "Prefetching Confirmation Array",
author = "J. H. Pomerene and T. R. Puzak and R. N. Rechtshaffen and F. J. Sparacio",
journal = "IBM Technical Disclosure Bulletin",
volume = 27,
number = 5,
year = 1985,
pages = "2786--2787"
}

article{pome85b,
title = "Shadow Structure to Perform {D}-Line Prefetching",
author = "J. Pomerene and T. R. Puzak and R. N. Rechtshaffen and F. J. Sparacio",
journal = "IBM Technical Disclosure Bulletin",
volume = 27,
number = 5,
year = 1985,
pages = "2987--2988"
}

@inproceedings{poon85,
title = "Cache Memories in a Functional Programming Environment",
author = "E. K. Y. Poon and Simon L. {Peyton Jones}",
booktitle = {Aspen\"{a}s Workshop on Implementation of Functional Languages,
G\"{o}teborg},
note = "Also UCL Computer Science Internal Note 1680",
year = 1985
}

@inproceedings{prin96,
author = {Tony Printezis},
title = {Disk Garbage Collection Strategies for Persistent {J}ava},
booktitle = {Proceedings of the First International Workshop on Persistence and {J}ava},
address = {Drymen, Scotland},
URL = {http://www.dcs.gla.ac.uk/~tony/research/pjw1.ps.gz},
month = sep,
year = 1996
}

@techreport{print96a,
author = {Tony Printezis and Quentin Cutts},
title = {Measuring the Allocation Rate of {N}apier88},
institution = "Department of Computer Science, University of Glasgow",
URL = {http://www.dcs.gla.ac.uk/~tony/research/measure.ps.gz},
month = nov,
year = 1996
}

@inproceedings{prin97,
author = {Tony Printezis and Malcolm P. Atkinson and Laurent Dayn{\`e}s and Susan Spence and Pete Bailey},
title = {The Design of a new Persistent Object Store for {{PJ}ama}},
booktitle = {Proceedings of the Second International Workshop on Persistence and {J}ava ({PJW2})},
address = {Half Moon Bay, CA, USA},
URL = {http://www.dcs.gla.ac.uk/~tony/research/pjw2.ps.gz},
month = aug,
year = 1997
}

@phdthesis{prin00,
author = {Tony Printezis},
title = {Management of Long-Running High-Performance Persistent Object Stores},
school = {University of Glasgow},
month = may,
year = 2000
}

@inproceedings{prin00a,
author = {Tony Printezis and David Detlefs},
title = {A Generational Mostly-Concurrent Garbage Collector},
crossref = {ISMM2000},
abstract = {
This paper reports our experiences with a mostly-concurrent incremental
garbage collector, implemented in the context of a high performance
virtual machine for the Java programming language. The garbage
collector is based on the ``mostly parallel'' collection algorithm of
Boehm et al. and can be used as the old generation of a generational
memory system. It overloads efficient write-barrier code already
generated to support generational garbage collection to also identify
objects that were modified during concurrent marking. These objects
must be rescanned to ensure that the concurrent marking phase marks all
live objects. This algorithm minimises maximum garbage collection pause
times, while having only a small impact on the average garbage
collection pause time and overall execution time. We support our claims
with experimental results, for both a synthetic benchmark and real
programs.
}
}

@inproceedings{prin01,
author = {Tony Printezis}, 
title = {{Hot-Swapping between a Mark\&Sweep and a Mark\&Compact Garbage Collector in a Generational Environment}},
crossref = {JVM01},
URL = {http://www.usenix.org/events/jvm01/printezis.html}
}

@inproceedings{prin02,
title = {Visualising the {T}rain Garbage Collector},
author = {Tony Printezis and Alex Garthwaite},
crossref = {ISMM02},
pages = {100--105},
abstract = {GCspy is an architectural framework for the collection,
transmission, storage and replay of memory management behaviour. It
makes new contributions to the understanding of the dynamic memory
behaviour of programming languages (and especially object-oriented
languages that make heavy demands on the performance of memory
managers).  GCspy's architecture allows easy incorporation into any
memory management system: it is not limited to garbage-collected
languages. It requires only small changes to the system in which it is
incorporated but provides a simple to use yet powerful data-gathering
API.  GCspy scales to allow very large heaps to be visualised
effectively and efficiently. It allows already-running, local or
remote, systems to be visualised and those systems to run at full speed
outside the points at which data is gathered. GCspy's visualisation
tool presents this information in a number of novel ways.  Deep
understanding of program behaviour is essential to the design of the
next generation of garbage collectors and explicit allocators. Until
now no satisfactory tools have been available to assist the implementer
in gaining an understanding of heap behaviour.  GCspy has been
demonstrated to be a practical solution to this dilemma. It has been
used to analyse production Java virtual machines running applications
of realistic size.  Its use has revealed important insights into the
interaction between application program and JVM and has led to the
development of better garbage collectors.}
}

@techreport{prin02a,
author = {Tony Printezis and Richard Jones},
title = {{GC}spy: An Adaptable Heap Visualisation Framework},
institution = {University of Kent},
number = {5--02},
month = mar,
year = 2002,
URL = {http://www.cs.ukc.ac.uk/pubs/2002/1364},
note = {Also University of Glasgow Technical Report}
}

@inproceedings{prin02b,
author = {Tony Printezis and Richard Jones},
title = {{GC}spy: An Adaptable Heap Visualisation Framework},
crossref = {OOPSLA02},
pages = {343-358}
}

@inproceedings{prot95,
author = {J. Proti\'{c} and M. Toma\u{s}evi\'{c} and V. Milutinovi\'{c}},
title = {A Survey of Distributed Shared Memory Systems},
booktitle = {Proceedings of 28th Annual Hawaii International Conference on System Science},
volume = {I (architecture)},
pages = {74--84},
year = 1995
}

@book{prot98,
author = {J. Proti\'{c} and M. Toma\u{s}evi\'{c} and V. Milutinovi\'{c}},
title = {Distributed Shared Memory: Concepts and Systems},
publisher = IEEE,
month = aug,
year = 1997,
URL = {http://church.computer.org/cspress/CATALOG/bp07737.htm},
}

@inproceedings{przy88,
author = "Przybylski, Stephen A. and Mark Horowitz and John Hennessy",
title = "Performance Tradeoffs in Cache Design",
booktitle = "15th Annual International Symposium on Computer Architecture",
address = "Honolulu, Hawaii",
month = jun,
year = 1988,
pages = "290--298"
}

@book{przy90,
author = "Steven A. Przybylski",
title = "Cache and Memory Hierarchy Design: A Performance-Directed
Approach",
publisher = "Morgan Kaufman",
address = "Palo Alto, CA",
year = 1990
}

@inproceedings{przy90a,
author = "Przybylski, Stephen",
title = "The Performance Impact of Block Sizes and Fetch Strategies",
crossref = "ISCA90",
pages = "160--169"
}


@inproceedings{puau92,
title = "Distributed Garbage Collection of Active Objects with No Global Synchronisation",
author = "Isabelle Puaut",
address = "INRIA/IRISA, France",
crossref = "IWMM92",
}

@phdthesis{puau93,
title = {Gestion d'objets actifs dans les syst\`{e}mes distribu\'{e}s: probl\'{e}matique et mise en oeuvre},
author = "Isabelle Puaut",
school = {Universit\'{e} de Rennes I},
year = 1993
}

@inproceedings{puau94,
title = "A Distributed Garbage Collector for Active Objects",
author = "Isabelle Puaut",
crossref = "PARLE94",
note = "Also INRIA UCIS-DIFUSION RR 2134"
}

@inproceedings{puau94a,
title = "A Distributed Garbage Collector for Active Objects",
author = "Isabelle Puaut",
crossref = "OOPSLA94",
pages = "113-128",
}

@article{purd70,
title = "Statistical Properties of the Buddy System",
author = "P. W. Purdom and S. M. Stigler",
journal = JACM,
publisher = ACM,
volume = 17,
number = 4,
month = oct,
year = 1970,
pages = "683--697"
}

@article{purd71,
author = "P. W. Purdom and S. M. Stigler and Tat-Ong Cheam",
title = "Statistical Investigation of Three Storage Allocation Algorithms",
journal = "BIT",
volume = 11,
year = 1971,
pages = "187--195"
}

@manual{pure92,
title = "Purify",
key = "Purify",
organization = "Pure Software",
address = "Los Altos, CA",
year = 1992
}


@phdthesis{puza85,
author = "Thomas R. Puzak",
title = "Analysis of Cache Replacement Algorithms",
school = "University of Massachussetts, Department of Electrical and Computer Engineering",
month = feb,
year = 1985
}

@inproceedings{qian02,
title = {An Adaptive, Region-based Allocator for {J}ava},
author = {Feng Qian and Laurie Hendren},
crossref = {ISMM02},
pages = {127--138}
}

@inproceedings{qian02a,
author = {Yang Qian and Witawas Srisa-an and T. Skotiniotis and J. Morris Chang},
title = {Java Virtual Machine Timing Probes --- A Study of Object Life Span and {GC}},
booktitle = {Proceedings of 21st IEEE International Performance, Computing and Communications Conference (IPCCC)},
addess = {Phoenix, AZ},
month = apr,
year = 2002
}


@article{quei88,
author = "Christian Queinnec",
title = "Dynamic Extent Objects",
journal = "Lisp Pointers",
publisher = ACM,
volume = 2,
number = 1,
year = 1988,
URL = "ftp://ftp.inria.fr/INRIA/Projects/icsla/Papers/DynExt-All.ps.gz"
}


@article{quei89,
title = "Mark {DURING} {S}weep rather than {M}ark {THEN} {S}weep",
author = "Christian Queinnec and Barbara Beaudoing and Jean-Pierre Queille",
address = "Ecole Polytech, F--91128 Palaiseau, France,  Chaussee Jules Cesar, F-95520 Osny, France",
journal = LNCS,
publisher = SV,
year = 1989,
volume = 365,
pages = "224--237",
URL = "ftp://ftp.inria.fr/INRIA/Projects/icsla/Papers/gcp.ps.gz",
comment = "On-the-fly garbage collection",
abstract = "Garbage Collection frees the programmer from the burden of
explicitly deallocating unused data. This facility induces a considerable
overhead but also causes some delays that may affect real-time
applications.  Guaranteed throughput (with at most short and
predictable delays) is needed in many applications such as plane or
plant control and requires at least a worst case analysis to identify
the performances of the whole system.  Traditional GC are made of two
phases: the marker which identifies all useful data, followed by the
sweeper which reclaims all useless data.  On-the-fly GC schemes were
introduced to permit an application and a collector to run
concurrently. That concurrency may lessen the GC penalty incurred by
the application.

We present here a new algorithm where the application,
the marker and the sweeper are concurrent. The benefit is to tightly
adjust collection rate to application consumption and have an allocation
time bounded by a small constant. Moreover our algorithm does not waste memory
and appears to be well suited for embedded systems.

This ``mark {\sc during} sweep'' algorithm is completely presented.  An
interesting single-processor and incremental realisation is also
analysed and followed by  some implementation variations."
}

@inproceedings{quei94,
author = "Christian Queinnec",
title = {Sharing Mutable Objects and Controlling Groups of Tasks in a concurrent and Distributed Language},
editor = {Takayasu Ito and Akinori Yonezawa},
booktitle = {Proceedings of the Workshop on Theory and Practice of Programming (TPPP'94)},
series = LNCS,
volume = 700,
pages = {70--93},
address = {Sendai, Japan},
month = nov,
year = 1994,
publisher = SV
}

@inproceedings{quei99,
author = {Christian Queinnec and Luc Moreau},
title = {Graceful Disconnection},
booktitle = {Parallel and Distributed Computing for Symbolic and Irregular Applications, PDCSIA'99},
editor = {Takayasu Ito and Taiichi Yuasa},
year = 1999,
publisher = {World Scientific Publishing},
URL = {http://www.ecs.soton.ac.uk/~lavm/papers/gradisc.ps.gz},
address = {Sendai, Japan},
month = jul,
pages = {242--252},
abstract = {A distributed object system allows objects to be communicated
from site to site disregarding their physical locations.
Communicating objects often leaves a trail homing to the site
that owns the original object. To shortcut these trails reduces
the number of ``zombies'' i.e., sites that are part of the trail
but do not need the object for themselves. This paper proposes an
algorithm that allows a site to disconnect gracefully that is,
without global network synchronization and therefore
quickly. This algorithm focuses on the proper treatment of
zombies.}
}

@misc{ram??,
title = "Parallel Garbage Collection Without Synchronization Overhead",
author = "Ashwin Ram and Janak H. Patel",
comment = "post 83?"
}

@inproceedings{rama02,
author = {Y. Srinivas Ramakrishna},
title = {Automatic Memory Management in the {J}ava {H}ot{S}pot Virtual Machine},
booktitle = {JavaOne Conference},
year = 2002,
}

@article{rame83,
author = "S. Ramesh and S. L. Mehndiratta",
title = "The Liveness Property of On-The-Fly Garbage Collector --- a Proof",
journal = IPL,
publisher = NH,
volume = 17,
number = 4,
month = nov,
year = 1983,
pages = "189--195",
comments = {This article uses \cite{owic82} to give a more formal proof
that on-the-fly garbage collection \cite{dijk78} terminates and
is live-lock free.},
}

@manual{rams01,
author = {Norman Ramsey and Peyton Jones, Simon L. and C. Lindig and T. Nordin and D. Oliva and Nogueira Iglesias, P.},
title = {C{-}{-} Reference Manual},
month = nov,
year = 2001,
URL = {http://www.cminusminus.org}
}

@article{rana83,
author = "S. P. Rana",
title = "A Distributed Solution to the Distributed Termination Problem",
journal = IPL,
publisher = NH,
volume = 17,
pages = {43--46},
year = 1983,
month = jul
}

@article{rand68,
author = "Brian Randell and C. J. Kuehner",
title = "Dynamic Storage Allocation Systems",
journal = CACM,
publisher = ACM,
volume = 12,
number = 7,
month = may,
year = 1968,
pages = "297--306"
}

@article{rand69,
author = "Brian Randell",
title = "A Note on Storage Fragmentation and Program Segmentation",
journal = CACM,
publisher = ACM,
volume = 12,
number = 7,
month = jul,
year = 1969,
pages = "365--372"
}

@article{rao78,
title = "Performance Analysis of Cache Memories",
author = "G. S. Rao",
journal = JACM,
publisher = ACM,
volume = 25,
number = 3,
month = jul,
year = 1978,
pages = "378--395"
}

@inproceedings{rash87,
author = "R. Rashid and A. Tevanian and M. Young and others",
title = "Machine-Independent Virtual Memory Management for Paged Uniprocessor and Multiprocessor Architectures",
crossref = "ASPLOS87",
pages = "31--39",
}

@inproceedings{rath87,
title = "Design of a Self-Managing Secondary Memory",
author = "B. D. Rathi and J. C. Browne and G. J. Lipovski",
booktitle = "Proceedings of the Twentieth {H}awaii International Conference 
on System Sciences 1987. (Volume 1 = {A}rchitecture, Decision Support
Systems and Knowledge-Based Systems.) {K}ailua-{K}ona, {HI}, {USA}", 
month = "January 6--9",
publisher = "Western Periodicals Co",
address = "North Hollywood, CA, USA",
pages = "293--302",
year = 1987,
abstract = {The 'self-managing-secondary memory' (SMSM) is intended to serve at
an intermediate level between primary memory and disks in the memory hierarchy.
It supports name based associative searching for objects, to implement
distributed and parallel name (directory) management.  It also supports
hardware memory allocation, garbage collection and compaction.  It can store
and retrieve variable size objects as readily as fixed size objects.  The SMSM
is modularly expandable in two senses = "(1) multiple units can function as an
integrated unit with respect to name management; and (2) (due to internal
parallelism) the storage capacity of each cell can be expanded over a wide
range without increase in latency or access times.  The functionality of the
SMSM can be extended to include database operations such as selection or
projection if desired.}
}

@phdthesis{rau77,
title = "Program Behavior and the Performance of Memory Systems",
author = "B. R. Rau",
school = "Stanford University",
year = 1977
}

@inproceedings{redd03,
title = {Correctness of Data Representations Involving Heap Data Structures},
author = {Uday S. Reddy and Hongseok Yang},
pages = {129--160},
crossref = {ESOP03}
}

@article{reev79,
author = "C. M. Reeves",
title = "Free Store Distribution under Random-Fit Allocation",
journal = CompJ,
publisher = BCS,
volume = 22,
number = 4,
month = nov,
year = 1979,
pages = "346--351"
}

@article{reev80,
author = "C. M. Reeves",
title = "Free Store Distribution under Random-Fit Allocation: Part 2",
journal = CompJ,
publisher = BCS,
volume = 23,
number = 4,
month = nov,
year = 1980,
pages = "298--306"
}

@article{reev82,
author = "C. M. Reeves",
title = "A Lumped-State Model of Clustering in Dynamic Storage Allocation",
journal = Compj,
volume = 27,
number = 2,
year = 1982,
pages = "135--142"
}

@article{reev83,
author = "C. M. Reeves",
title = "Free Store Distribution under Random-Fit Allocation, Part 3",
journal = CompJ,
publisher = BCS,
volume = 26,
number = 1,
month = feb,
year = 1983,
pages = "25--35"
}

@inproceedings{reid99,
author = {Alastair Reid and John McCorquodale and Jason Baker and Wilson Hsieh and Joseph Zachary},
title = {The Need for Predictable Garbage Collection},
booktitle = {Proceedings of the ACM SIGPLAN Workshop on Compiler Support for System Software (WCSSS'99)},
month = may,
year = 1999,
URL = {http://www.cs.utah.edu/flux/papers/gc-wcsss99.ps.gz},
abstract = { Modern programming languages such as Java are increasingly
being used to write systems programs. By ``systems programs,'' we mean
programs that provide critical services (compilers), are long-running
(Web servers), or have time-critical aspects (databases or query
engines). One of the requirements of such programs is predictable
behavior. Unfortunately, predictability is often compromised by the
presence of garbage collection. Various researchers have examined the
feasibility of replacing garbage collection with forms of stack
allocation that are more predictable than GC, but the applicability of
such research to systems programs has not been studied or measured. A
particularly promising approach allocates objects in the n-th stack
frame (instead of just the topmost frame): we call this deep stack
allocation. We present dynamic profiling results for several Java
programs to show that deep stack allocation should benefit systems
programs, and we describe the approach that we are developing to
perform deep stack allocation in Java. }
}

@article{rein73,
author = "E. M. Reingold",
title = "A Non-Recursive List Moving Algorithm",
journal = CACM, 
publisher = ACM,
volume = 16,
number = 5,
month = may,
year = 1973,
pages = "305--307",
comments = {Optimization to the copying algorithm (feni69) which uses
Deutsch-Schorr-Waite link-reversal technique (scho67).},
}

@phdthesis{rein93,
author = "Mark B. Reinhold",
title = "Cache Performance of Garbage-Collected Programming Languages",
school = "MIT Laboratory for Computer Science",
note = "Also Technical Memo MIT/LCS/TR--581",
month = sep,
year = 1993,
URL = "ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/listings/abstracts/TM-581.html"
}

@inproceedings{rein94,
author = "Mark B. Reinhold",
title = "Cache Performance of Garbage-Collected Programs",
crossref = "PLDI94",
URL = "ftp://ftp.nj.nec.com/pub/pls/pldi94.ps.Z"
}

@techreport{repp86,
author = "John H. Reppy and E. R. Gansner",
title = "Pegasus: A Foundation for Programming Environments",
institution = "AT\&T Bell Laboratories",
type = "Technical Memorandum",
year = 1986,
month = dec,
note = "An earlier version appeared in Proceedings of Second ACM/SIGSOFT/SIGPLAN
Symposium on Practical Software Development Environments, December 1986, 
218--227."
}

@techreport{repp93,
author = "John H. Reppy",
title = "A High-Performance Garbage Collector for {S}tandard {ML}",
institution = "AT\&T Bell Laboratories",
type = "Technical Memorandum",
year = 1993,
month = dec,
address = "Murray Hill, NJ",
URL = "ftp://ftp.research.vell-labs.com/dist/smnlj/papers/93-tr-reppy.ps"
}

@article{ribe89,
title = "Content-Addressable Memories Applied to Execution of Logic Programs",
author = "J. C. D. F. Ribeiro and C. D. Stormon and J. V. Oldfield and M. R. Brule",
journal = "{IEE} Proceedings, Part E: Computers and Digital Techniques",
volume = 136,
number = 5,
pages = "383--388",
year = "1989",
abstract = {The paper describes techniques for using content-addressable memory
to speed up the execution of logic programs for both single and multiple
processor implementations.  The techniques allow for significant speed-ups in
unification, clause selection, branch switching, variable handling and garbage
collection.  For multiple processor implementations, the literal ordering and
environment join algorithms are improved.  In addition to the speed
improvements, some simplification of software results from performing 
indexing operations in content-addressable memory.}
}

@inproceedings{rich00,
author = {Nicolas Richer and Marc Shapiro},
title = {The Memory Behaviour of the {WWW}, or The {WWW} Considered as a Persistent Store},
pages = {136--146},
crossref = {IWPOS00}
}

@phdthesis{rich02,
title = {Strat\'{e}gies de Gestion M\'{e}moire dans les M\'{e}moires d'Objets Persistantes Automatiques Partitionn\'{e}es},
author = {Nicolas Richer},
month = may,
year = 2002,
school = {Universit\'{e} Pierre et Marie Curie --- Paris VI}
}

@article{rich00a,
author = {Jeffrey Richter},
title = {Garbage Collection: Automatic Memory Management in the {M}icrosoft {.NET} Framework},
journal = {MSDN Magazine},
publisher = {Microsoft},
volume = 15,
number = 11,
month = nov,
year = 2000,
pages = {82--92},
URL = {http://msdn.microsoft.com/msdnmag/issues/1100/GCI/GCI.asp}
}

@article{rich00b,
author = {Jeffrey Richter},
title = {Garbage Collection -- Part 2: Automatic Memory Management in the {M}icrosoft {.NET} Framework},
journal = {MSDN Magazine},
publisher = {Microsoft},
volume = 15,
number = 13,
month = dec,
year = 2000,
pages = {82--92},
URL = {http://msdn.microsoft.com/msdnmag/issues/1200/GCI2/GCI2.asp},
}

@inproceedings{rido87,
title = "Deterministic and Stochastic Modeling of Parallel Garbage Collection:  
Towards Real-Time Criteria",
author = "Olivier Ridoux",
pages = "128--136",
booktitle = "Computer Architecture News. The 14th Annual International 
Symposium on Computer Architecture, Pittsburgh, Pennsylvania, June 2--5, 
1987",
publisher = ACM,
year = "1987"
}



@article{ripl78,
author = "G. David Ripley and Ralph E. Griswold and David R. Hanson",
title = "Performance of Storage Management in an Implementation of {SNOBOL4}",
journal = TransSWE,
publisher = ACM,
volume = "SE--4",
number = 2,
pages = "130--137",
year = 1978,
month = mar
}

@mastersthesis{ritz99,
author = {Tobias Ritzau},
title = {Real-Time Reference Counting for {RT}-{J}ava},
note = {Licenciate thesis. In Link\"{o}ping Studies in Science and Technology, No. 748},
school = {Link\"{o}ping University},
month = mar,
year = 1999,
URL = {http://www.ida.liu.se/~tobri/download.php4?paper=lic.pdf}
}

In Linkping Studies in Science and Technology, No. 748, March 1999.
@inproceedings{ritz99a,
author = {Tobias Ritzau},
title = {Real-Time Reference Counting --- Automatic memory management with short and predictable interruptions},
booktitle = {Pproceedings of the Svenska Nationella Realtidsf\"{o}reningen (SNART) conference},
address = {Link\"{o}ping},
month = aug, 
year = 1999,
}

@inproceedings{ritz00,
author = {Tobias Ritzau},
title = {Real-Time Reference Counting},
booktitle = {{J}ava for Embedded Systems workshop},
address = {London},
month = may,
year = 2000,
URL = {http://www.ida.liu.se/~tobri/download.php4?paper=rtrc.pdf}
}

@inproceedings{ritz01,
author = {Tobias Ritzau},
title = {Hard Real Time Reference Counting without External Fragmentation},
booktitle = {Proceedings of the {JOSES} ({J}ava Optimization Strategies for Embedded Systems) workshop at {ETAPS} 2001},
address = {Genoa, Italy},
year = 2001,
URL = {http://www.ida.liu.se/~tobri/download.php4?paper=etaps2001.ps}
}

@inproceedings{ritz02,
author = {Tobias Ritzau and Peter Fritzson},
title = {Decreasing Memory Overhead in Hard Real-Time Garbage Collection},
booktitle = {Second International Workshop on Embedded Software (EMSOFT '02)},
address = {Grenoble},
editor = {A. Sangiovanni-Vincentelli and J. Sifakis},
publisher = {Springer},
series = LNCS,
volume = 2491,
month = oct,
year = 2002,
comment = {RT referennce counting}
}

@phdthesis{ritz03,
author = {Tobias Ritzau},
title = {Memory Efficient Hard Real-Time Garbage Collection},
school = {Link\"{o}ping University}, 
month = may,
year = 2003,
URL = {http://www.ida.liu.se/~tobri/download.php4?paper=ritzau-thesis.pdf}
}

@manual{RNI97,
key = {Microsoft RNI, 1997},
organisation = {Microsoft Corporation},
title = {Raw Native Interface},
year = 1997,
URL = {http://www.microsoft.com/java/sdk/20/jnative/rni.htm},
note = {Microsoft's Raw Native Interface for Java}
}

@article{robe79,
title = "Code Generation and Storage Allocation for Machines with Span-Dependent Instructions",
author = "Edward L. Robertson",
journal = toplas,
publisher = ACM,
year = 1979,
month = jul,
volume = 1,
number = 1,
pages = "71--83"
}


@inproceedings{robe90,
author = "Robertson, J. and M. Devarakonda",
title = "Data Cache Management Using Frequency-Based Replacement",
booktitle = "Proceedings of the {ACM} {SIGMETRICS} Conference on
Measurement and Modeling of Computer Systems",
publisher = ACM,
year = 1990 
}

@inproceedings{robe02,
author = {Sven Roberts},
title = {Applying Priorities to Memory Allocation},
crossref = {ISMM02},
pages = {1--11}
}

@inproceedings{robe03,
title = {Time-triggered Garbage Collection --- Robust and Adaptive Real-time {GC}
Scheduling for Embedded Systems},
author = {Sven Gesteg\o{a}rd Robertz and Roger Henriksson},
crossref = {LCTES03}
}

@mastersthesis{robe03a,
title = {Flexible Automatic Memory Management for Real-time and Embedded SYstems},
author = {Sven Gesteg\o{a}rd Robertz},
note = {Lic. eng. thesis},
school = {Lund University},
year = 2003
}


@article{robs71,
author = "J. M. Robson",
title = "An Estimate of the Store Size Necessary for Dynamic Storage Allocation",
journal = JACM,
publisher = ACM,
volume = 18,
number = 3,
month = jul,
year = 1971,
pages = "416--423"
}

@article{robs73,
author = "J. M. Robson",
title = "An Improved Algorithm for Traversing Binary Trees Without Auxiliary 
Stack",
journal = IPL,
publisher = NH,
volume = 2,
number = 1,
month = mar,
year = 1973,
pages = "12--14",
comments = {algorithm for traversing trees without a stack or mark bits},
}

@article{robs74,
author = "J. M. Robson",
title = "Bounds for some Functions Concerning Dynamic Storage Allocation",
journal = JACM,
publisher = ACM,
volume = 21,
number = 3,
month = jul,
year = 1974,
pages = "419--499"
}


@article{robs77,
author = "J. M. Robson",
title = "A Bounded Storage Algorithm for Copying Cyclic Structures",
journal = CACM, 
publisher = ACM,
volume = 20,
number = 6,
month = jun,
year = 1977, 
pages = "431--433",  
comments = {algorithm for copying lists without using a stack or mark bits.
It differs from the moving algorithms in that the altered contents of old lists
are later restored to their original values.},
}

@article{robs77a,
author = "J. M. Robson",
title = "Worst Case Fragmentation of First Fit and Best Fit Storage Allocation S
trategies",
journal = CompJ,
publisher = BCS,
volume = 20,
number = 3,
month = aug,
year = 1977,
pages = "242--244"
}

@article{robs80,
author = "J. M. Robson",
title = "Storage Allocation is {NP}-Hard ",
journal = IPL,
publisher = NH,
volume = 11,
number = 3,
month = nov,
year = 1980,
pages = "119--125",
abstract = {The problem considered in this paper is that of determining,
given a store in which some blocks have already been allocated and given a
request, where this block can be allocated without producing the result that
some request/freeing sequences are now impossible to deal with.
It will be shown that this problem is NP-hard in the sense used by Garey and
Johnson (i.e. that satisfiability is Turing reducible to it) by means of a
reduction from the Knapsack problem shown to be NP.},
}


@article{roch71,
author = "Arnold Rochfeld",
title = "New {LISP} Techniques for a Paging Environment",
journal = CACM,
publisher = ACM,
volume = 14,
number = 12,
month = Dec,
year = 1971,
pages = "791--795",
}

@inproceedings{rodr96,
title = "A Cyclic Distributed Garbage Collector for {N}etwork {O}bjects",
author = "Helena C. C. D. Rodrigues and Richard E. Jones",
crossref = "WDAG96",
pages = {123--140},
URL = {http://www.cs.ukc.ac.uk/pubs/1996/12/content.ps.gz},
abstract = "This paper presents an algorithm for distributed garbage collection
  and outlines its implementation within the Network Objects system.
  The algorithm is based on a {\em reference listing} scheme, which is
  augmented by {\em partial tracing} in order to collect distributed
  garbage cycles.  Processes may be dynamically organised into groups,
  according to appropriate heuristics, to reclaim distributed garbage
  cycles.  The algorithm places no overhead on local collectors and
  suspends local mutators only briefly. Partial tracing of the
  distributed graph involves only objects thought to be part of a
  garbage cycle: no collaboration with other processes is required.
  The algorithm offers considerable flexibility, allowing
  expediency and fault-tolerance to be traded against completeness."
}

@inproceedings{rodr98,
title = {Cyclic Distributed Garbage Collection with Group Merger},
author = "Helena C. C. D. Rodrigues and Richard E. Jones",
note = {Also UKC Technical report 17--97, December 1997},
pages = {249--273},
crossref ={ECOOP98}
}


@phdthesis{rodr98a,
author = {Helena C.C.D. Rodrigues},
title = {Cyclic Distributed Garbage Collection},
school = UKC,
year = 1998,
}

@misc{rodr95,
author = {Gustavo Rodriguez-Riviera},
title = {Cyclic Distributed Garbage Collection Without Global Synchronisation},
note = {PhD preliminary examination report},
year = 1995
}

@article{rodr97,
title = {Non-intrusive Cloning Garbage Collection with Stock Operating System Support},
author = {Gustavo Rodriguez-Rivera and Vince Russo},
journal = SPE,
volume = 27,
number = 8,
month = aug,
year = 1997,
abstract = {It is well accepted that automatic garbage collection
simplifies programming, promotes modularity, and reduces development
effort. However it is commonly believed that these advantages do not
counteract the perceived price: excessive overheads, possible long
pause times while garbage collections occur, and the need to modify
existing code. Even though there are publically available garbage
collector implementations that can be used in existing programs, they
do not guarantee short pauses, and some modification of the application
using them is still required. In this paper we describe a
snapshot-at-beginning concurrent garbage collector algorithm and its
implementation. This algorithm guarantees short pauses, and can be
easily implemented on stock UNIX-like operating systems. Our results
show that our collector performs comparable to other garbage collection
implementations on uniprocessor machines and outperforms similar
collectors on multiprocessor machines. We also show our collector to be
competitive in performance with explicit deallocation. Our collector
has the added advantage of being non-intrusive. Using a dynamic linking
technique and effective root set inferencing, we have been able to
successfully run our collector even in commercial programs where only
the binary executable and no source code is available. In this paper we
describe our algorithm, its implementation, and provide both an
algorithmic and a performance comparison between our collector and
other similar garbage collectors.}
}

@inproceedings{rodr97a,
author = {Gustavo Rodriguez-Riviera and Vince Russo},
title = {Cyclic Distributed Garbage Collection Without Global Synchronization in {CORBA}},
crossref = "OOPSLA97-gc",
URL = {http://www.cs.purdue.edu/homes/grr/backtracing.ps}
}

@inproceedings{rodr98b,
author = {Gustavo Rodriguez-Rivera and Michael Spertus and Charles Fiterman},
title = {A Non-Fragmenting, Non-Moving Garbage Collector},
pages = {79--85},
crossref = {ISMM98},
abstract = {One of the biggest disadvantages of non-copying collectors compared
to copying collectors has been their limited ability to deal with memory
fragmentation. In this paper, we describe two techniques to reduce
fragmentation without the need of copying live data. The first technique
reduces internal fragmentation in BiBOP (Big Bag of Pages) like
allocators. The second technique reduces external fragmentation using
virtual memory calls available in most modern operating systems. It
can also reduce the size of the heap after periods of great activity in
long lived applications. These techniques have been successfully used
in Geodesic Systems' Great Circle, a commercially-available
conservative garbage collector. This paper describes these techniques,
their implementation, and some experimental results. }
}

@inproceedings{rodr00,
author = {Gustavo Rodriguez-Rivera and Mike Spertus and Charles Fiterman},
title = {Conservative Garbage Collection for General Memory Allocators},
crossref = {ISMM2000},
abstract = {
This paper explains a technique that allows the use of conservative garbage
collection on general memory allocators. This is possible by using two data
structures named malloc-tables and jump-tables that are computed at
garbage collection time to map pointers to beginning of objects and their
sizes. This paper describes malloc-tables and jump-tables, an
implementation of a malloc/jump-table based conservative garbage
collector for Doug Lea's memory allocator, and experimental results that
compare this implementation with Boehm-Demers-Weiser's GC, a
state-of-the-art conservative garbage collector. 
}
}

@inproceedings{roje92,
title = "A Concurrent Generational Garbage Collector for a Parallel Graph Reducer",
author = {Niklas R\"{o}jemo},
address = "Chalmers University of Technology, Sweden",
crossref = "IWMM92",
}

@techreport{roje93,
author = {Niklas R\"{o}jemo},
title = "Generational Garbage Collection is Leak-Prone",
institution = "Department of Computer Science, Chalmers University",
month = jan,
year = 1993,
type = "Draft paper"
}

@inproceedings{roje94,
author = {Niklas R\"{o}jemo},
title = "nhc: A Space-Efficient Haskell Compiler", 
booktitle = "Proceedings of the workshop on Implementation of Functional Languages",
address = "School of Information Systems, Univ. of East Anglia, Norwich",
month = sep,
year = 1994
}

@inproceedings{roje95,
title = "Generational Garbage Collection Without Temporary Space Leaks for Lazy
Functional Languages",
author = {Niklas R\"{o}jemo},
address = "Chalmers University of Technology, Goteborg, Sweden",
crossref = "IWMM95",
}

@phdthesis{roje95a,
title = "Garbage Collection, and Memory Efficiency, in Lazy Functional Languages",
author = {Niklas R\"{o}jemo},
school = "Chalmers University of Technology, Goteborg, Sweden",
year = 1995,
abstract = 
"Automatic memory management is an important concept in many high order
languages. It improves productivity by abstracting away from memory management,
but it is not free! The cost can sometimes be much higher than the programmer
thought. This is especially true for lazy functional languages where it is not
always obvious when things are evaluated. This thesis describes two ways to
decrease the overhead. Faster garbage collectors and tools to aid programmers
writing more efficient programs.

The first two papers are examples of improved garbage collectors. One is
intended for a parallel machine, the other is for sequential machines. Both use
generational garbage collectors to decrease the garbage collection time.
Neither of them need the usual test-before-update used in other generational
collectors. The test could be avoided by taking advantage of the fact that only
redexes are updated in functional languages, and then only after they have been
evaluated.

The third paper describes an extended version of heap profiling. This is a tool
that helps programmers produce more memory efficient programs. In the extended
version not only static information can be profiled, but also some dynamic
properties can be observed. This aids the programmer in writing even faster and
more space efficient programs. The gain in speed can be higher than using an
infinitely fast garbage collector, since also the time to allocate the memory
goes away.

The last two papers are examples of memory efficient implementations. The first
of these papers describes a fast and space efficient implementation of parsing
combinators, the second gives an overview of a Haskell compiler.  This Haskell
compiler is not only written in a memory efficient manner, it also tries to
produce space efficient code. Some of the methods to decrease memory usage in
the compiler can be used in other lazy functional programs, not only compilers."
}

@inproceedings{roje95b,
title = {Highlights from nhc -- a space-efficient {H}askell compiler},
author = {Niklas R\"{o}jemo},
crossref = {FPCA95},
URL = {ftp://ftp.cs.chalmers.se/pub/users/rojemo/fpca95.ps.gz},
abstraxt = {Self-compiling implementations of Haskell, i.e., those written in
Haskell, have been and, except one, are still space consuming
monsters.  Object code size for the compilers themselves are 3-8Mb,
and they need 12-20Mb to recompile themselves.  One reason for the
huge demands for memory is that the main goal for these compilers is
to produce fast code.  However, the compiler described in this paper,
called "nhc" for "Nearly a Haskell Compiler", is the one above
mentioned exception.  This compiler concentrates on keeping memory
usage down, even at a cost in time.  The code produced is not fast,
but nhc is usable, and the resulting programs can be run on computers
with small memory.
This paper describes some of the implementation choices done, in the
Haskell part of the source code, to reduce memory consumption in nhc.
It is possible to use these also in other Haskell compilers with no,
or very small, changes to their run-time systems.
Time is neither the main focus of nhc nor of this paper, but there is
nevertheless a small section about the speed of nhc.  The most notable
observation concerning speed is that nhc spends approximately half the
time processing interface files, which is much more than needed in the
type checker.  Processing interface files is also the most space
consuming part of nhc in most cases.  It is only when compiling source
files with large sets of mutually recursive functions that more memory
is needed to type check than to process interface files.}
}

@inproceedings{roje96,
title = "Lag, drag, void, and use: heap profiling and space-efficient compilation revisited",
author = {Niklas R\"{o}jemo and Colin Runciman},
URL = {http://www.cs.york.ac.uk/~colin/papers/icfp96.ps.gz},
crossref = "ICFP96",
pages = "34--41"
}

@incollection{rons98,
author = {M. Ronsse and De Bosschere, K.},
title = {{JiT}I: Tracing Memory References for Data Race Detection},
booktitle = {Parallel Computing: Fundamentals, Applications and New Directions},
volume = 12, 
pages = {327--334},
series = {Advances in Parallel Computing},
month = feb,
year = 1998,
publisher = NH,
editor = {D'Hollander, E. and Joubert, F.J. and Trottenberg, U.},
URL = {http://www.elis.rug.ac.be/~ronsse/diota/doc/Parco97.ps}
}

@inproceedings{rose92,
title = "Integrating the {Scheme} and {C} Languages",
author = "John H. Rose and Hans Muller",
crossref = "LFP92",
pages = "247--259",
comment = "
Uses Scheme as a control and prototyping language.
Concervative garbage collector, functions callable both ways, header
files, etc."
}

@inproceedings{rose87,
author = "John Rosenberg and J. L. Keedy",
title = "Object Management and Addressing in the {MONADS} Architecture",
crossref = "IWPOS87",
}


@inproceedings{rose90,
title = "Stability in a Persistent Store Based on a Large Virtual Memory",
author = "J. Rosenberg and F. A. Henskens and A. L. Brown and Ron Morrison and David
 Munro",
year = 1990,
booktitle = "International Workshop on Architectural Support for Security and Pe
rsistence of Information",
publisher = "Springer Verlag and the British Computer Society",
pages = {229--245}
}


@inproceedings{rose91,
author = "John Rosenberg",
title = "Architectural Support for Persistent Objects",
pages = "48--60",
crossref = "IWOOOS91",
}


@article{ross67,
author = "D. T. Ross",
title = "The {AED} Free Storage Package",
journal = CACM, 
publisher = ACM,
volume = 10,
number = 8,
month = Aug,
year = 1967,
pages = "481--492",
comment = {Memory is split into zones. Different zones can be anaged differently. 
Ross says that automatic collection in zones is inefficient. No mechanism to
handle inter-zonal pointers.}
}


@inproceedings{ross83,
title = "A Garbage Collecting Associative Memory for Interactive Database 
Systems",
author = "R. A. Ross",
pages = "109--123",
booktitle = "Integrated interactive computing systems.  Proceedings of the 
{E}uropean conference {ECICS'82} ({S}tresa, {I}taly, {S}ept. 1--3, 1982)",
editor = "P. Degano and E.  Sandewall",
publisher = ENH,
year = 1983
}

@inproceedings{roth98,
title = {Dependence Based Prefetching for Linked Data Structures},
author = {A. Roth and A. Moshovos and G. Sohi},
crossref = {ASPLOS98}
}

@inproceedings{roth98a,
author = {David J. Roth and David S. Wise},
title = {One-bit Counts between Unique and Sticky},
pages = {49--56},
crossref = {ISMM98},
URL = {http://doi.acm.org/10.1145/286860.286866},
abstract = {Stoye's one-bit reference tagging scheme can be extended to local
counts of two or more via two strategies. The first, suited to pure
register transactions, is a cache of referents to two shared references.
The analog of Deutch's and Bobrow's multiple-reference table, this
cache is sufficient to manage small counts across successive
assignment statements. Thus, accurate reference counts above one
can be tracked for short intervals, like that bridging one function's
environment to its successor's. 

The second, motivated by runtime stacks that duplicate references,
avoids counting any references from the stack. It requires a local
pointer-inversion protocol in the mutator, but one still local to the
referent and the stack frame. Thus, an accurate reference count of one
can be maintained regardless of references from the recursion stack. }
}

@techreport{rous75,
author = "P. Roussel",
title = {Prolog: Manuel de R\'{e}f\'{e}rence et d'Utilisation},
institution = {G.I.A. Universit\'{e} Aix-Marseille},
year = 1975,
comment = "The first Prolog interpreter.",
}



@techreport{rovn85,
author = "Paul Rovner",
title = "On Adding Garbage Collection and Runtime Types to a Strongly-Typed,
Statically-Checked, Concurrent Language",
type = "Technical Report",
number = "CSL--84--7",
institution = PARC,
month = Jul,
year = 1985,
comment = "Reference counting can be useful for its immediacy, for
instance in {\it finalisation}, performing `clean-up' actions when objects die
(like closing files).
Developers using Mesa spend 40 percent of their development time implementing memory
management procedures and debugging errors related to explicit
storage re otoo93d"
}

@techreport{rovn85a,
author = "Paul Rovner and Roy Levin and John Wick",
title = "On Extending {M}odula-2 for Building Large, Integrated Systems",
institution = DECSRC,
address = "Palo Alto, CA",
year = 1985,
number = 3
}


@article{ruby87,
title = "Liveness Property of a Parallel Algorithm",
author = "J. Ruby",
journal = IPL,
publisher = NH,
volume = 24,
number = 4,
pages = "275--277",
year = "1987",
abstract = {The DMLSS algorithm is a well-known algorithm for concurrent
garbage collection in a LISP-like environment.  A number of proofs of its
safety and liveness properties have appeared since the algorithm was 
published
in 1975.  The author presents a new proof of a liveness property of the
algorithm.}
}


@inproceedings{ruda86,
author = "M. Rudalics",
title = "Distributed Copying Garbage Collection",
crossref = "LFP86",
pages = "364--372"
}

@techreport{ruda90,
author = "M. Rudalics",
title = {Correctness of Distributed Garbage Collection Algorithms},
number = {90--40.0},
institution = {Johannes Kepler Universit\"{a}t, Linz},
year = 1990
}

@inproceedings{ruf00,
author = {Erik Ruf},
title = {Removing Synchronization Operations from {J}ava},
crossref = {PLDI00},
note = {Escape analysis based on type unification; \cite{stee00} says it's fast}
}

@phdthesis{rugg87,
author = "Christina Ruggieri",
title = "Dynamic Memory Allocation Techniques Based on the Lifetimes of Objects",
school = "Purdue University",
address = "West Lafayette, Indiana",
year = 1987, month = aug
}

@inproceedings{rugg88,
author	 = "Christina Ruggieri and Thomas P. Murtagh",
title = "Lifetime Analysis of Dynamically Allocated Objects",
crossref = "POPL88",
pages = {285--293},
}

@techreport{runc92,
title = "Heap Profiling of Lazy Functional Programs",
author = "Colin Runciman and David Wakeling",
institution = "University of York",
number = "YCS-92-172",
URL = "ftp://ftp.cs.york.ac.uk/reports/YCS-92-172.ps.Z",
year = 1992
}

@article{runc93,
title = "Heap Profiling of Lazy Functional Programs",
author = "Colin Runciman and David Wakeling",
journal = JFP,
volume = 3,
number = 2,
pages = {217--245},
month = apr,
publisher = CUP,
URL = {http://www.cs.york.ac.uk/~colin/papers/jfp93hp.ps.gz},
year = 1993
}

@inproceedings{runc93a,
title = "Heap Profiling of a Lazy Functional Compiler",
author = "Colin Runciman and David Wakeling",
pages = {203--214},
crossref = "glasgow93",
URL = {http://www.cs.york.ac.uk/~colin/papers/ayr92.ps.gz},
}

@techreport{runc95,
title = "New Dimensions in Heap Profiling",
author = "Colin Runciman",
institution = "University of York",
number = "YCS-95-256",
URL = "ftp://ftp.cs.york.ac.uk/reports/YCS-95-256.ps.Z",
year = 1995
}

@inproceedings{runc95a,
title = {Lag, Drag and Post-Mortem Heap Profiling},
author = {Colin Runciman and Niklas R\"{o}jemo},
booktitle = {Implementation of Functional Languages Workshop},
address = {B\o{a}stad, Sweden},
month = sep,
year = 1995
}

@article{runc96,
title = "New Dimensions in Heap Profiling",
author = "Colin Runciman",
journal = JFP,
volume = 6,
number = 4,
pages = {587--620},
URL = {http://www.cs.york.ac.uk/~colin/papers/jfp96nd.ps.gz},
year = 1996
}

@inproceedings{runc96a,
title = {Heap Profiling for Space Efficiency},
author = {Colin Runciman and Niklas R\"{o}jemo},
booktitle = {Second International School on Advanced Functional Programming},
editor = {J. Launchbury and E. Meijer and T. Sheard},
address = {Olympia, WA},
publisher = SV,
series = LNCS,
volume = 1129,
month = aug,
URL = {http://www.cs.york.ac.uk/~colin/papers/advfp96.ps.gz},
pages = "34--41",
year = 1996
}

@inproceedings{runc96b,
title = {Two-pass Heap Profiling -- a Matter of Life and Death},
author = {Colin Runciman and Niklas R\"{o}jemo},
booktitle = {Selected Papers from the Eighth International Workshop on the Implementation of Functional Languages},
editor = {W. Kluge},
address = {Bonn-Bad-Godesberg},
publisher = SV,
series = LNCS,
volume = 1168,
month = sep,
URL = {http://www.cs.york.ac.uk/~colin/papers/advfp96.ps.gz},
pages = {222-232},
year = 1996
}

@article{russ77,
author = "D. L. Russell",
title = "Internal Fragmentation in a Class of Buddy Systems",
journal = "{SIAM} J. Comput.",
volume = 6,
number = 4,
month = dec,
year = 1977,
pages = "607--621"
}

@article{russ94,
author = "David M. Russinoff",
title = "A Mechanically Verified Incremental Garbage Collector",
address = "Computational Logic Inc., Austin",
journal = "Formal Aspects of Computing",
volume = 6,
pages = "359--390",
publisher = SV,
year = 1994,
comment = "Uses Boyer-Moore theorem proved to prove Ben-Ari's on-the-fly 
algorithm. Ben-Ari's original proof was wrong, and was repeated by Pixley."
}

@inproceedings{russ91,
author = "Vincent F. Russo",
title = "Garbage Collecting and Object-Oriented Operating System Kernel ",
crossref = "OOPSLA91-gc",
}

@inproceedings{sach03,
title = {Mark{C}opy: Fast Copying {GC} with Less Space Overhead},
author = "Narendran Sachindran and J Eliot B Moss",
booktitle = "Proceedings of the {ACM} Conference on Object-Oriented Systems, Languages and Applications",
address = {Anaheim, CA},
month = nov,
year = 2003,
}

@inproceedings{sach04,
title = {$\textnormal{MC}^2$: High-Performance Garbage Collection for Memory-Constrained Environments},
author = {Narendran Sachindran and J. Eliot B. Moss and Emery D. Berger},
booktitle = "Proceedings of the {ACM} Conference on Object-Oriented Systems, Languages and Applications",
address = {Vancouver, BC, Canada},
month = oct,
year = 2004,
URL = {http://www.cs.umass.edu/~emery/pubs/04-15.pdf}
}

@inproceedings{sagi99,
author = {M. Sagiv and T. Reps and R. Wilhelm},
title = {Parametric Shape Analysis via 3-valued Logic},
crossref = {POPL99},
note = {statically analyse heap paths}
}

@techreport{sahl87,
author = "Dan Sahlin",
title = "Making Garbage Collection Independent of the Amount of Garbage",
type = "Research Report",
number = "SICS/R--87/87008",
institution = "SICS",
year = 1987,
note = {Appendix to SICS research report R86009 "Garbage collection for 
Prolog based on WAM."},
abstract = "This appendix shows in detail how to make the time for the 
garbage collection algorithm presented in [AHS 86] become 
proportional to n log n, where n is the number of non-garbage 
cells.  It is assumed that the reader is familiar with [AHS 86] 
since no further presentation of the notation used is made here.  
The compaction phase of that algorithm is proportional to the 
amount of memory, i.e. proportional to the sum of garbage and non-
garbage.  This is unfortunate since for instance a garbage 
collection using copying is just proportional to the amount of 
non-garbage.  If a program generates much more garbage than non-
garbage, it might be a severe drawback of a garbage collection 
algorithm to depend on the amount of garbage.  This paper shows 
how to make the garbage collection in [AHS 86] independent of the 
amount of garbage.",
}


@techreport{sahl91,
author = "Sahlin, Dan and Carlsson, Mats",
title = "Variable Shunting for the {WAM}",
institution = "Swedish Institute of Computer Science",
year = 1991,
type = "Research report",
number = "SICS/R91--07",
month = Mar,
abstract = "This paper describes how to extend the garbage 
collection for WAM [ACHS88] so that it will shunt chains of bound 
variables if possible.  Doing so has two advantages: 1. Space is 
saved by making it possible to deallocate the intermediate cells. 
This is particularly useful when those cells are associated with 
frozen goals.  2.  Later dereferencing is speeded up by not  
having to follow long variable chains.  The main complication of 
this optimization is the treatment of the  trailed variables.  We 
claim that all possible chains of variables are shunted by this 
algorithm.  The algorithm has been implemented in SICStus Prolog, 
and benchmark results are presented in this paper.
This paper is a revised version of [Sahlin89] and is meant to be 
read in conjunction with [ACHS88] as the notation used is 
presented there and only briefly summarized here.  The full 
source code for the shunting algorithm is given in this paper."
}

@mastersthesis{salc01,
author = {Alexandru Salcianu},
title = {Pointer Analysis and its Applications for {J}ava Programs},
school = MIT,
month = sep,
year = 2001,
URL = {http://www.mit.edu/people/salcianu/publications/sm-thesis.ps}
}


@mastersthesis{salk87,
author = "Jon D. Salkild",
title = "Implementation and Analysis of Two Reference Counting Algorithms",
school = "University College", 
address = "London",
year = "1987",
comments = {Proves the incorrectness of the algorithm in
\cite{brow85} and suggests a way of fixing it.}
}


@techreport{sall84,
author = {Patrick Sall\'{e}},
title = {Syntaxe et S\'{e}mantique de {PLASMA} et {ALOG}},
institution = "LSI-ENSEEIHT, Toulouse",
year = 1984
}

@inproceedings{samp86,
author = "A. Dain Samples and David M. Ungar and Paul Hilfinger",
title = "{SOAR}: {S}malltalk Without Bytecodes",
crossref = "OOPSLA86",
pages = "107--118"
}

@inproceedings{samp92,
title = "Garbage Collection-Cooperative {C++}",
author = "A. Dain Samples",
address = "University of Cincinnati, USA",
crossref = "IWMM92",
}

@techreport{sank94,
title = "A Bibliography on Garbage Collection",
author = "Nandakumar Sankaran",
institution = "Clemson University",
month = feb,
year = 1994,
URL = "ftp://ftp.cs.clemson.edu/techreports/94-102.ps.Z",
note = "A small collection!"
}

@article{sank94a,
title = "A Bibliography on Garbage Collection and Related Topics",
author = "Nandakumar Sankaran",
journal = SIGPLAN,
volume = 29,
number = 9,
month = sep,
pages = "140--148",
year = 1994,
note = "A small collection!"
}

@inproceedings{sans91,
author = "Patrick M. Sansom",
title = "Combining Copying and Compacting Garbage Collection",
crossref = "glasgow91",
comment = "Dual-mode GC. `Lazy evaluation performs many updates which
generational GCs hate'."
}


@techreport{sans91a,
author = "Patrick M. Sansom",
title = "Dual-Mode Garbage Collection",
institution = "Department of Electronics and Computer Science, University of
Southampton",
number = "CSTR 91--07",
note = "{\em Proceedings of Third International Workshop on Implementation of
Functional Languages on Parallel Architectures}",
month = jun,
URL = "ftp://ftp.dcs.gla.ac.uk/pub/glasgow-fp/authors/Patrick_Sansom/1991_dual-mode-gc_PAPER.ps.Z",
year = 1991
}

@inproceedings{sans93,
title = "Generational Garbage Collection for {H}askell", 
author = "Patrick M. Sansom and Simon L. {Peyton Jones}", 
address = "University of Glasgow",
crossref = "FPCA93",
URL = "ftp://ftp.dcs.gla.ac.uk/pub/glasgow-fp/papers/gen-gc-for-haskell.ps.Z"
}

@techreport{sans94,
title = {Time and Space Profiling for Non-Strict, Higher-Order, Functional Languages},
author = "Patrick M. Sansom and Simon L. {Peyton Jones}",
institution = "University of Glasgow",
type = {Research Report},
number = {FP--1994--10},
year = 1994
}

@phdthesis{sans94a,
title = {Execution Profiling for Non-Strict Functional Languages},
author = "Patrick M. Sansom",
school = "University of Glasgow",
year = 1994
}

@article{sant81,
title = "On the Efficient Implementation of Retention Block-Structured Languages",
author = "di Santo, M.  and L. Nigro and W. Russo",
journal = "Int. J. Comput. Inf. Sci",
month = feb,
year = 1981,
volume = 10,
number = 1,
pages = "39--54",
abstract = {In block-structured languages, the storage associated with each
block or procedure activitation can be handled either by means of a deletion
strategy (automatic deletion on exit from the block or procedure) or by a
retention strategy (with deletion only when the storage proves
inaccessible).
The retention strategy is the more general of the two, in that it removes
all restrictions on the use of pointer, label, and procedure values. It is
also more secure, since it prevents dangling references. However, the most
widely used general purpose languages normally prefer deletion, since
retention, requiring more sophisticated storage management techniques, is
considered less efficient.
In developing techniques to implement a programming language efficiently,
the following general principle should be adhered to: Those parts of a
program which do not utilize a certain linguistic facility should not be
penalized by a significant overhead in the run-time due to the existence of
that facility in the language. In the specific case of programs
necessitating retention, this principle is of utmost importance, since a
large majority of programs run correctly in the presence of deletion. Such
programs are called well-stacking or WS programs.
From the Introduction...
There are a number of schemes in existence for implementing retention,
including the spaghetti stack of Bobrow and Wegbreit, the cacciatore
stack of Berry et al. and a garbage collector which is optimized for
a large subset of the WS programs by Berry and Sorkin. All of these
adhere to the enunciated principle only to a limited degree, since in all
cases there is some albeit small overhead distributed to all programs.
This paper describes a new implementation of retention, the
deletion-retention machine, which adheres to the principle almost
completely, certainly significantly better than any of the implementations
mentioned above. The new machine is also significantly simpler in
conception.
Simply stated, the machine follows the ALGOL 68 lifetime-checking stack
model until such time as the failure of a lifetime check indicates an
upward pointer and thus that garbage collection may be needed. At that time,
the machine switches to a garbage collection regime, using an improvement
of Berry and Sorkin's and Jonker's algorithms. After any particular
garbage collection, if all the compacted data fits the stack pattern, the
machine switches back to the ALGOL 68 model. Thus, if one's program does in
fact adhere to the stack and gives rise to no lifetime errors, no garbage
collection is ever done. No data is maintained and no checks are done that
is not already needed by a fully-checking ALGOL 68 implementation.
This clearly-written paper represents the most significant advance toward a
solution to the stated problem that this reviewer has seen. It is must
reading for anyone interested in language implementation and design.}
}

@article{sark95,
author = "Jean-Pierre Sarkis and Richie Bielak",
title = "Implementing Stacks",
journal = "Eiffel Outlook",
volume = 4,
number = 6,
pages = "6--9",
month = sep,
year = 1995
}

@mastersthesis{sati94,
author = "S. Satishkumar",
title = "Register Allocation for Accurate Garbage Collection of {C++}",
school = "Iowa State University",
month = jul,
note = "Technical report ISUTR 94--12",
year = 1994,
URL = "http://www.cs.iastate.edu/tech-reports/TR94-13.ps"
}


@inproceedings{saun64,
author = "Robert A. Saunders",
title = "The {LISP} System for the {Q--32} Computer",
pages = "220--231",
crossref = "berk64",
comments = "Uses Edwards' two pointer compactifying algorithm"
}


@article{sche88a,
author = "W. F. Schelter and M. Ballantyne",
title = "{K}yoto {C}ommon {L}isp",
journal = "AI Expert",
volume = 3,
number = 3,
pages = "75--77",
year = 1988,
comment = "AKCL conservatively marks the run-time stack rather than using a
special stack to protect objects against GC. Leaks rare if ever."
}

@article{sche88,
title = "The Implementation of a Distributed {S}malltalk",
author = "M. Schelvis and E. Bledoeg",
institution = "Oce Nederland, POB 101, 5900 MA Venlo, Netherlands",
journal = LNCS,
publisher = SV,
year = 1988,
volume = "322",
pages = "212--232"
}


@article{sche89,
title = "Incremental Distribution of Timestamp Packets --- a New Approach to 
Distributed Garbage Collection",
author = "M. Schelvis",
address = "Parcplace Systems, Mt View, Ca, 94043",
journal = Sigplan,
publisher = ACM,
year = 1989,
volume = 24,
number = 10,
pages = "37--48"
}


@inproceedings{schi90,
author = "J. Schimpf",
title = "Garbage Collection for {P}rolog Based on Twin Cells",
booktitle = "2nd {NACLP} Workshop on Logic Programming Architectures and 
Implementations",
publisher = MIT,
year = 1990,
URL = {http://www.icparc.ic.ac.uk/eclipse/reports/gc_naclp90.ps.gz}
}

@inproceedings{schn01,
title = {Automatic Persistent Memory Management for the Spotless {J}ava Virtual Machine on the {P}alm Connected Organizer},
author = {Daniel Schneider and Bernd Mathiske and Matthias Ernst and Matthew Seidl},
crossref = {JVM01},
URL = {http://www.usenix.org/events/jvm01/schneider.html}
}

@techreport{scho84,
author = "R. Schooler and James W. Stamos",
title = "Proposal for a Small {S}cheme Implementation",
institution = "MIT Laboratory for Computer Science",
type = "Technical Memo",
number = "MIT/LCS/TM--267",
month = oct,
year = 1987,
URL = "ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/listings/abstracts/TM-267.html"
}

@article{scho67,
author = "H. Schorr and W. Waite",
title = "An Efficient Machine Independent Procedure for Garbage Collection in Various List Structures",
journal = CACM, 
publisher = ACM,
volume = 10,
number = 8,
month = aug,
year = 1967,
pages = "501--506",
abstract = "Deutsch-Schorr-Waite pointer reversal algorithm."
}

@phdthesis{schm92,
author = "William J. Schmidt",
title = "Issues in the Design and Implementation of a Real-Time Garbage Collection Architecture",
year = 1992,
school = "Iowa State University",
address = "Ames, Iowa",
note = "Technical report ISUTR 92-25",
URL = "http://www.cs.iastate.edu/tech-reports/TR92-25.ps"
}
 
@techreport{schm92a,
author = "William J. Schmidt and Kelvin Nilsen",
title = "Experimental Measurements of a Real-Time Garbage Collection Architecture",
institution = "Iowa State University",
note = "Technical report ISUTR 92-26",
URL = "http://www.cs.iastate.edu/tech-reports/TR92-26.ps",
year = 1992
}

@inproceedings{schm94,
author = "William J. Schmidt and Kelvin D. Nilsen",
title = "Performance of a Hardware-Assisted Real-Time Garbage Collector",
crossref = "ASPLOS94",
pages = "76--85",
URL = {http://www.newmonics.com/webroot/technologies/gc/asplos.ps}
}

@techreport{schre94,
author = "Schreiner, Wolfgang ",
institution = "Research Institute for Symbolic Computation (RISC-Linz), Johannes Kepler University",
title = "Garbage Collection on a Stack",
year = 1994,
address = "{L}inz, {A}ustria",
URL = "http://info.risc.uni-linz.ac.at:70/9/archive/reports/paralab/gcstack.dvi.Z",
month = jan
}


@techreport{schu85,
author = "Shultis, Jon.",
title = "Imminent Garbage Collection",
institution = "University of Colorado, Department of Computer Science",
year = 1985,
number = "CU-CS-305-85"
}


@techreport{schw74,
author = "Jacob T. Schwartz",
title = "More on copy optimization of SETL programs",
number = 131,
type = "SETL Newsletter",
institution = "Courant Inst. of Mathematical Sciences, New York University",
year = 1974,
month = jun
}


@techreport{schw76,
author = "Jacob T. Schwartz",
title = "A coarser, but simpler and considerably more efficient copy optimization
technique",
number = 176,
type = "SETL Newsletter",
institution = "Courant Inst. of Mathematical Sciences, New York University",
year = 1976,
month = aug
}

@techreport{schw76a,
author = "Jacob T. Schwartz",
title = "A coarser, but simpler and considerably more efficient copy optimization",
number = 176,
type = "SETL Newsletter",
institution = "Courant Inst. of Mathematical Sciences, New York University",
year = 1976,
month = aug
}


@inproceedings{schw78,
author = "Jerald Schwarz",
title = "Verifying the Safe Use of Destructive Operations in Applicative Programs",
booktitle = "Program Transformations --- Proceedings of the 3rd International Symposium on Programming",
year = 1978,
pages = "395--411"
}

@manual{scriptx,
title = "Script{X} Architectural Overview",
label = "Kaleida",
organization = "Kaleida Labs.",
}

@techreport{seid97,
author = {Matthew L. Seidl and Benjamin Zorn}, 
title = {Predicting References to Dynamically Allocated Objects}, 
institution = {University of Colorado}, 
number = {CU-CS-826-97}, 
month = jan,
year = 1997,
URL = {http://www.cs.colorado.edu/~seidl/papers/TR-ref-pred.ps}
}

@inproceedings{seid99,
title = {Low Cost Methods for Predicting Heap Object Behavior}, 
author = {Matthew L. Seidl and Benjamin Zorn}, 
booktitle = {Second Workshop on Feedback Directed Optimization},
pages = {83--90}, 
address = {Haifa, Israel},
month = nov,
year = 1999,
URL = {http://www.cs.colorado.edu/~seidl/papers/fdo.page.ps}
}

@techreport{seid99a,
title = {Implementing Heap-Object Behavior Prediction Efficiently and Effectively}, 
author = {Matthew L. Seidl and Benjamin Zorn}, 
institution = {University of Colorado}, 
number = {CU-CS-893-99}, 
month = {dec},
year = 1999,
note = {Submitted to Software - Practice and Experience},
URL = {http://www.cs.colorado.edu/~seidl/papers/TR-journal.ps}
}

@inproceedings{seli90,
author = "Robert Seliger",
title = "Extending {C++} to Support Remote Procedure Call, Concurrency,
Exception Handling and Garbage Collection",
booktitle = "Usenix {C++} Conference Proceedings",
editor = "",
pages = "241--264",
year = 1990,
publisher = UA
}

@inproceedings{seli95,
title = "Incremental Mature Garbage Collection using the Train Algorithm",
author = "Jacob Seligmann and Steffen Grarup",
address = "University of Aarhus",
URL = "http://www.daimi.aau.dk/~beta/Papers/Train/train.ps",
pages = {235--252},
crossref = "ECOOP95",
comment = "Implements and fixes bug in the train algorithm"
}

@phdthesis{serr94,
author = "Manuel Serrano",
title = "Vers un Compilation Portable {\em et} Performante des Langages Fonctionnels",
month = dec,
year = 1994,
school = {Universit\'{e} Paris 6},
comment = "uses BDW conservative garbage collector for Scheme and ML compilers. Bigloo"
}

@inproceedings{serr96,
author = {Manuel Serrano and Marc Feeley},
title = {Storage Use Analysis and its Applications},
crossref = {ICFP96},
URL = {http://www.iro.umontreal.ca/~feeley/papers/icfp96.ps.gz}
}
     
@inproceedings{serr00,
title = {Understanding Memory Allocation of {S}cheme Programs},
author = {Manuel Serrano and Hans-J Boehm},
crossref = {ICFP2000}
}
@inproceedings{sewa92,
title = "Generational Garbage Collection for Lazy Graph Reduction",
author = "Julian Seward",
address = "University of Manchester",
crossref = "IWMM92",
}

@inproceedings{shah00,
author = {Ran Shaham and Elliot K.  Kolodner and Mooly Sagiv},
title = {On the Effectiveness of {GC} in {J}ava},
URL = {http://citeseer.nj.nec.com/shaham00effectiveness.html},
crossref = {ISMM2000},
abstract = {
We study the effectiveness of garbage collection (GC) algorithms by
measuring the time difference between the actual collection time of an
object and the potential earliest collection time for that object. Our ultimate
goal is to use this study in order to develop static analysis techniques that
can be used together with GC to allow earlier reclamation of objects. The
results may also be used to pinpoint application source code that could be
rewritten in a way that would allow more timely GC. Specifically, we
compare the objects reachable from the root set to the ones that are
actually used again. The idea is that GC could reclaim unused objects even
if they are reachable from the root set. Thus, our experiments indicate a kind
of upper bound on storage savings that could be achieved. We also try to
characterize these objects in order to understand the potential benefits of
various static analysis algorithms. The Java Virtual Machine (JVM) was
instrumented to measure objects that are reachable, but not used again, and
to characterize these objects. Experimental results are shown for the
SPECjvm98 benchmark suite. The potential memory savings for these
benchmarks range from 23\% to 67\%
}
}

@inproceedings{shah01,
title = {Heap Profiling for Space-Efficient {J}ava},
author = {Ran Shaham and Elliot Kolodner and Mooly Sagiv},
crossref = {PLDI01}
}

@inproceedings{shah02,
title = {Estimating the Impact of Liveness Information on Space Consumption in {J}ava},
author = {Ran Shaham and Elliot Kolodner and Mooly Sagiv},
crossref = {ISMM02},
pages = {64--75}
}

@mastersthesis{shan89,
author = "Shang, Heping",
title = "Consistent Global State Algorithms and an Application in Distributed Garbage Collection",
year = 1989,
school = "Concordia University, Canada"
}

@techreport{shap90,
author = {Marc Shapiro and Olivier Gruber and David Plainfoss\'{e}},
title = "A Garbage Detection Protocol for a Realistic Distributed Object-Support System",
institution = "INRIA-Rocquencourt",
type = "Rapports de Recherche",
number = 1320,
month = nov,
URL = "ftp://ftp.diku.dk/pub/GC90",
year = 1990,
comment = "Node-group collector",
note = "Superseded by \cite{shap91}"
}


@inproceedings{shap91,
author = "Marc Shapiro",
title = "A Fault-Tolerant, Scalable, Low-Overhead Distributed Garbage 
Collection Protocol",
booktitle = "Proceedings of the Tenth Symposium on Reliable Distributed 
Systems",
address = "Pisa",
month = sep,
year = 1991,
URL = "http://www-sor.inria.fr/SOR/docs/DGC_rds91.html"
}


@inproceedings{shap92,
author = {Marc Shapiro and Peter Dickman and David Plainfoss\'{e}},
title = "Robust, Distributed References and Acyclic Garbage Collection",
booktitle = "Symposium on Principles of Distributed Computing",
address = "{V}ancouver, {C}anada",
publisher = ACM,
pages = {135--146},
month = aug,
year = 1992,
URL = "http://www-sor.inria.fr/SOR/docs/RDRAGC_podc92.html",
note = "Superseded by \cite{shap92a}"
}

@techreport{shap92a,
author = {Marc Shapiro and Peter Dickman and David Plainfoss\'{e}},
title = "{SSP} Chains: Robust, Distributed References Supporting Acyclic Garbage Collection",
institution = INRIA,
type = "Rapports de Recherche",
number = 1799,
month = nov,
year = 1992,
URL = "http://www-sor.inria.fr/SOR/docs/SSPC_rr1799.html",
note = "Also available as Broadcast Technical Report 1"
}


@inproceedings{shap92b,
author = "Marc Shapiro and Julien Maisonneuve and Pierre Collet",
title = "Implementing References as Chains of Links",
crossref = "IWOOOS92",
}

@techreport{shap93,
author = "Marc Shapiro",
title = "Flexible Bindings for Fine-Grain and Fragmented Objects in Distributed Systems",
institution = INRIA,
type = "Rapports de Recherche",
number = "2007",
year = 1993
}

@techreport{shap94,
author = "Marc Shapiro and Paulo Ferreira",
title = "Larchant--{RDOSS}: a Distributed Shared Persistent Memory and its Garbage Collector",
institution = INRIA,
month = nov,
year = 1994,
note = "Superseded by \cite{shap95}",
URL = "http://www-sor.inria.fr/SOR/docs/RDOSS_rr2399.html"
}

@inproceedings{shap94a,
author = "Shapiro, Marc and Plainfoss{\'e}, David and Ferreira, Paulo and Amsaleg, Laurent",
title = "Some Key Issues in the Design of Distributed Garbage Collection and References",
booktitle = "Unifying Theory and Practice in Distributed Systems",
year =  1994,
address = "Dagstuhl (Germany)",
month = sep,
URL = "http://www-sor.inria.fr/SOR/docs/key-issues-GC_utpdcs94.html"
}


@inproceedings{shap95,
author = "Marc Shapiro and Paulo Ferreira",
title = "Larchant--{RDOSS}: a Distributed Shared Persistent Memory and its Garbage Collector",
booktitle = "Workshop on Distributed Algorithms",
editor = {J.-M. H\'{e}lary and M. Raymond},
series = LNCS,
number = 972,
pages = "198--214",
address = "Le Mont Saint-Michel",
month = sep,
year = 1995,
URL = "http://www-sor.inria.fr/SOR/docs/LRDSPMGC_wdag95.html"
}

@inproceedings{shap97,
author = {Marc Shapiro and Sytse Kloosterman and Fabio Riccardi},
title = {{PerDiS} --- a Persistent Distributed Store for Cooperative Applications},
booktitle = {Proceedings of 3rd Cabernet Plenary Workshop},
year = 1997,
address = {Rennes (France)},
month = apr,
URL = {ftp://ftp.inria.fr/INRIA/Projects/SOR/PPDSCA_cabernet97.ps.gz},
abstract = {The PerDiS platform deploys a novel technology for the
distributed sharing of information: a persistent distributed store,
which provides a shared memory abstraction which is tranparently made
persistent thanks to distributed garbage collection. This data sharing
platform supports interactive concurrent engineering applications in a
virtual enterprise. In this paper we give an overview of the project,
its motivation and the PerDiS platform architecture. We also address
some expected problems and related work. }
}

@inproceedings{shap00,
title = {Recent Advances in Distributed Garbage Collection},
author = {Marc Shapiro and Le Fessant, Fabrice and Paulo Ferreira},
crossref = "krak00",
pages = {104--126},
URL = {http://www-sor.inria.fr/publi/RAIDGC_lncs1752.html}
}

@inproceedings{shar91,
title = "Parallel Generational Garbage Collection",
author = "Ravi Sharma and Mary Lou Soffa",
crossref = "OOPSLA91",
pages = "16--32",
}


@techreport{shaw87,
author = "Robert A. Shaw",
title = "Improving Garbage Collector Performance in Virtual Memory",
institution = "Stanford University",
year = 1987,
number = "CSL--TR--87--323",
month = mar,
note = "Also Hewlett-Packard Laboratories report STL--TM--87--05, Palo Alto, 1987"
}


@phdthesis{shaw88,
author = "Robert A. Shaw",
title = "Empirical Analysis of a {L}isp System",
school = "Stanford University",
note = " Technical Report CSL--TR--88--351",
year = 1988,
comment = "Write barrier."
}

@article{shen74,
author = "K. K. Shen and J. L. Peterson",
title = "A Weighted Buddy Method for Dynamic Storage Allocation",
journal = CACM,
publisher = ACM,
volume = 17,
number = 10,
month = oct,
year = 1974,
pages = "558--562"
}

@inproceedings{shin85,
author = "Heonshik Shin and Miroslaw Malek",
title = "Parallel Garbage Collection with Associative Tag",
booktitle = "Proceedings of {IEEE} Conference on Parallel Processing",
publisher = IEEE,
pages = "369--375",
year = 1985
}

@article{shiv92,
author = {N.G. Shivaratri and P. Krueger and M. Singhal},
title = {Load Distributing for Locally Distributed Systems},
journal = {Computer},
volume = 25,
number = 12,
pages = {33--44},
month = dec,
year = 1992
}

@inproceedings{shiv99,
author = {O. Shivers and J.W. Clark and R. McGrath},
title = {Atomic Heap Transactions and Fine-Grain Interrupts},
crossref = {ICFP99}
}

@article{shor75,
author = "J. E. Shore",
title = "On the External Storage Fragmentation Produced by First-Fit
and Best-Fit Allocation Strategies",
journal = CACM,
publisher = ACM,
volume = 18,
number = 8,
month = aug,
year = 1975,
pages = "433--440"
}

@article{shor77,
author = "J. E. Shore",
title = "Anomalous Behavior of the Fifty-Percent Rule in Dynamic Memory Allocation",
journal = CACM,
publisher = ACM,
volume = 20,
number = 11,
month = nov,
year = 1977,
pages = "558--562"
}

@inproceedings{shuf01,
title = {Characterizing the Memory Behavior of Java Workloads: A Structured View and Opportunities for Optimizations},
author = {Yefim Shuf and Mauricio Serrano and Manish Gupta and Jaswinder Pal Singh},
booktitle = {SIGMETRICS'01},
month = jun,
year = 2001,
abstract = {This paper studies the memory behavior of important Java
workloads used in benchmarking Java Virtual Machines (JVMs), based on
instrumentation of both application and library code in a
state-of-the-art JVM, and provides structured information about these
workloads to help guide systems' design. We begin by characterizing the
inherent memory behavior of the benchmarks, such as information on the
breakup of heap accesses among different categories and on the hotness
of references to fields and methods. We then provide detailed
information about misses in the data TLB and caches, including the
distribution of misses over different kinds of accesses and over
different methods. In the process, we make interesting discoveries
about TLB behavior and limitations of data prefetching schemes
discussed in the literature in dealing with pointer-intensive Java
codes. Throughout this paper, we develop a set of recommendations to
computer architects and compiler writers on how to optimize computer
systems and system software to run Java programs more efficiently. This
paper also makes the first attempt to compare the characteristics of
SPECjvm98 to those of a server-oriented benchmark, pBOB, and explain
why the current set of SPECjvm98 benchmarks may not be adequate for a
comprehensive and objective evaluation of JVMs and just-in-time (JIT)
compilers.

We discover that the fraction of accesses to array elements is quite
significant, demonstrate that the number of "hot spots" in the
benchmarks is small, and show that field reordering cannot yield
significant performance gains.  We also show that even a fairly large
L2 data cache is not effective for many Java benchmarks. We observe
that instructions used to prefetch data into the L2 data cache are
often squashed because of high TLB miss rates and because the TLB does
not usually have the translation information needed to prefetch the
data into the L2 data cache. We also find that co-allocation of
frequently used method tables can reduce the number of TLB misses and
lower the cost of accessing type information block entries in virtual
method calls and runtime type checking}
}

@inproceedings{shuf02,
title = {Exploiting Prolific Types for Memory Management and Optimizations},
author = {Yefim Shuf and Manish Gupta and Rajesh Bordawekar and Jaswinder Pal Singh},
crossref = {POPL02}
}

@inproceedings{shuf02a,
title = {Creating and Preserving Locality of {J}ava Applications at Allocation and Garbage Collection Times},
author = {Yefim Shuf and Manish Gupta and Hubertus Franke and Andrew Appel and Jaswinder Pal Singh},
crossref = {OOPSLA02},
abstract = {The growing gap between processor and memory speeds is
motivating the need for optimization strategies that improve data
locality. A major challenge is to devise techniques suitable for
pointer- intensive applications.  This paper presents two techniques
aimed at improving the memory behavior of pointer-intensive
applications with dynamic memory allocation, such as those written in
Java. First, we present an allocation time object placement technique
based on the recently introduced notion of "prolific" (frequently
instantiated) types.  We attempt to co-locate, at allocation time,
objects of prolific types that are connected via object references.
Then, we present a novel technique for traversing live objects at
garbage collection (GC) time. The benefits of this techniques are
twofold:  (i) it improves performance of GC due to better locality
during a heap traversal and (ii) it restructures surviving objects in a
way that enhances locality.  On multiprocessors, this technique can
further reduce overhead due to synchronization and false sharing. The
experimental results, on a well-known suite of Java benchmarks
(SPECjvm98, SPECjbb2000, and jOlden), from an implementation of these
techniques in the Jikes RVM, are very encouraging. The object
co-allocation technique improves application performance by up to 21\%
(10\% on average) in the Jikes RVM configured with a non-copying
mark-and-sweep collector. The locality-based traversal technique
reduces GC times by up to 20\% (10\% on average) and improves
performance of applications by up to 14\% (6\% on average) in the Jikes
RVM configured with a copying semi-space collector. Both techniques
combined can improve application performance by up to 22\% (10\% on
average) in the Jikes RVM configured with a non-copying mark-and-sweep
collector.}
}

@mastersthesis{sieb97,
author = {Fridtjof Siebert},
title = {Implementierung eines Eiffel-Compilers f\"{u}r SUN/SPARC},
school = {Universitaet Stuttgart},
year = 1997,
URL = {http://www.fridi.de/rts/papers/da97_fsiebert.pdf},
note = {Diplomarbeit 1484. In German}
}

@inproceedings{sieb98,
author = {Fridtjof Siebert},
title = {Guaranteeing Non-Disruptiveness and Real-Time Deadlines in an Incremental Garbage Collector},
pages = {130-137},
crossref = {ISMM98},
abstract = {For Garbage Collection (GC) to be a generally accepted means of
memory management it is required to prove its efficiency. This paper
presents a scheme that guarantees that an incremental Garbage
Collector will have completed its collection cycle before the system
runs out of memory. Furthermore, it is shown that the work that has to
be done by the collector in one incremental step is limited by a small
constant depending on the percentage of total memory used by the
application program. This result then allows a suitable trade-off
between memory demand and GC overhead to be found. },
URL = {http://www.fridi.de/rts/papers/ismm98_fsiebert.pdf}
}

@inproceedings{sieb99,
author = {Fridtjof Siebert},
title = {Real-Time Garbage Collection in Multi-Threaded Systems on a Single Processor},
booktitle = {20th IEEE Real-Time Systems Symposium (RTSS'99)}, 
address = {Phoenix, Arizona},
abstract = {We show the difficulties that arise for the implementation
of a real-time garbage collector in a multi-threaded system. A
mechanism for synchronization between threads and the garbage collector
activities is proposed for a single processor system. It is shown how
this mechanism can be used to maintain exact information on roots, to
implement efficient write-barriers, to do incremental or even
constant-time root-scanning and to guarantee short pre-emption time of
garbage collector activity.  Special aspects of an implementation for
Java that are affected by this mechanism will also be addressed.
Finally, experimental data is presented to show that the proposed
mechanisms can efficiently be used in real programs.},
URL = {http://www.fridi.de/rts/papers/rtss99_fsiebert_long.pdf},
year = 1999
}

@inproceedings{sieb99a,
author = {Fridtjof Siebert},
title = {Hard Real-Time Garbage Collection in the {J}amaica {V}irtual {M}achine},
booktitle = {Sixth International Conference on Real-Time Computing Systems and Applications (RTCSA'99)},
address = {Hong Kong},
abstract = {Java's automatic memory management is the main reason that
prevents Java from being used in hard real-time
environments. We present the garbage collection mechanism that is
used by the Jamaica Virtual Machine, an implementation of the Java
Virtual Machine Specification. This mechanism differs
significantly from existing implementations in the way threads are
implemented, root references are found and in the object layout
that is used. The implementation provides hard real-time
guarantees while it allows unrestricted use of the Java language.
Even dynamic allocation of normal garbage-collected Java objects
is possible with hard real-time guarantees.},
URL = {http://www.fridi.de/rts/papers/rtcsa99_fsiebert.pdf},
year = 1999
}

@inproceedings{sieb00,
author = {Fridtjof Siebert},
title = {Eliminating External Fragmentation in a Non-Moving Garbage Collector for {J}ava},
booktitle = {Compilers, Architectures and Synthesis for Embedded Systems (CASES2000)},
address = {San Jose}, 
month = nov,
year = 2000,
abstract = {Fragmentation can cause serious loss of memory in systems
that are using dynamic memory management. Any useful memory management
system must therefore provide means to limit fragmentation. Todays
garbage collector implementations often do this by moving objects in a
way that free memory is non-fragmented. This paper presents a new
object model that is based on fixed size blocks. The model eliminates
external fragmentation without the need to move objects. A Java virtual
machine and a static Java bytecode compiler that use this object model
have been implemented and analysed using the SPECjvm98 benchmark suite.
This Java implementation allows for deterministic memory management as
needed in real-time systems that is difficult to achieve with moving
collectors and unparalleled by current implementations.},
URL = {http://www.aicas.com/papers/cases2000_fsiebert.pdf}
}

@inproceedings{sieb01,
author = {Fridtjof Siebert and Andy Walter},
title = {Deterministic Execution of {J}ava's Primitive Bytecode Operations},
crossref = {JVM01},
abstract = {For the application of Java in realtime and safety critical
domains, an analysis of the worst-case execution times of primitive
Java operations is necessary. All primitive operations must either
execute in constant time or have a reasonable upper bound for their
execution time. The difficulties that arise for a Java virtual machine
and a Java compiler in this context will be presented here. This
includes the implementation of Javas class and interface model, class
initialization, monitors and automatic memory management.A new Java
virtual machine and compiler that solves these difficulties has been
implemented and its performance has been analysed.},
URL = {http://www.aicas.com/papers/jvm01_siebert_walter.pdf}
}

@inproceedings{sieb01a,
author = {Fridtjof Siebert},
title = {Constant-Time Root Scanning for Deterministic Garbage Collection},
booktitle = {Tenth International Conference on Compiler Construction (CC2001)},
address = {Genoa},
month = apr,
year = 2001,
abstract = {Root scanning is the task of identifying references to heap
objects that are stored outside of the heap itself, in global and local
variables and on the execution stack. Root scanning is particularly
difficult within an incremental garbage collector that needs to be
deterministic or give hard real-time guarantees. Here, a method that
allows exact root scanning is presented. The basic idea is to ensure
that copies of all root references exist on the heap whenever the
garbage collector might become active. This approach reduces the root
scanning phase of the garbage collection cycle to an efficient
constant-time operation. A Java virtual machine and a static Java
byte-code compiler that use this technique have been implemented and
analysed using the SPECjvm98 benchmark suite. This Java implementation
allows for deterministic memory management as needed in real-time
systems that is difficult to achieve with traditional methods to
perform root scanning.},
URL = {http://www.aicas.com/papers/cc01_fsiebert.pdf}
}

@book{sieb02,
author = {Fridtjof Siebert},
title = {Hard Realtime Garbage Collection in Modern Object Oriented Programming Languages},
publisher ={aicas Books},
year = 2002
}

@article{sikl72,
author = "L. Siklossy",
title = "Fast and Readonly Algorithms for Traversing Trees Without an Auxiliary Stack",
journal = IPL,
publisher = NH,
volume = 1,
number = 4,
month = jun,
year = 1972,
pages = "149--152",
comments = {algorithm for traversing trees without a stack or mark bits},
}


@mastersthesis{sing88,
author = "Singh, Ramanand",
title = "A Realization of Multiprocessing Garbage Collection Algorithm for 
Rule-Based Expert Systems",
year = 1988,
school = "West Virginia University"
}

@mastersthesis{sing90,
author = "Singh, Tajinder P.",
title = "Hardware Design of a Real-Time Copying Garbage Collection System",
school = "Iowa State University, Department of Computer Science",
year = 1990,
number = "TR90-21",
month = Aug,
abstract = "This thesis presents the design of a real-time copying-
type garbage collection system which is capable of providing 
better  real-time response and throughput than is currently 
available. The improvement is achieved on the basis of three 
factors: a special hardware module to aid the memory management 
unit for speedy execution of memory requests, a concurrent 
garbage collection processor, and delayed copying for large 
objects to improve the real-time response.  The hardware design 
is presented in the form of AHPL code.  The simulation results 
obtained justify the desirability of the system.  The drawbacks 
of the suggested system are considered and a suggestion is made 
for further improvements."
}

@article{sing92a,
author = "Jaswinder Pal Singh and Harold S. Stone and Dominique Thiebaut",
title = "A Model of Workloads and its Use in Miss-Rate Prediction for
Fully-Associative Caches",
journal = IEEETransComp,
publisher = IEEE,
volume = 41,
number = 7,
month = jul,
year = 1992,
pages = "811--825"
}

@inproceedings{sing92,
author = "Singhal, Vivek and Sheetal V. Kakkad and Paul R. Wilson",
title = "{T}exas: an Efficient, Portable Persistent Store",
crossref = "IWPOS92",
}

@inproceedings{sire96,
title = {Writing an Operating System Using {M}odula-3},
author = {Emin G\"{u}n Sirer and Stefan Savage and Przemyslaw Pardyak and Greg P. DeFouw and Brian N. Bershad},
booktitle = {Workshop on Compiler Support for Systems Software},
year = 1996,
URL = {http://www.cs.washington.edu/homes/egs/papers/m3os.ps},
comment = {Describes their experience with using Modula-3 to implement SPIN}
}

@article{skot02,
title = {Estimating Internal Memory Fragmentation for {J}ava Programs},
author = {Therapon Skotiniotis and J. Morris Chang},
journal = {Journal of Systems and Software},
volume = 64,
number = 3,
month = dec, 
year = 2002,
pages = {235--246},
abstract = {Dynamic memory management has been an important part of a
large class of computer programs and with the recent popularity of
object oriented programming languages, more specifically Java, high
performance dynamic memory management algorithms continue to be of
great importance. In this paper, an analysis of Java programs, provided
by the SPECjvm98 benchmark suite, and their behavior, as this relates
to fragmentation, is performed. Based on this analysis, a new model is
proposed which allows the estimation of the total internal
fragmentation that Java systems will incur prior to the programs
execution. The proposed model can also accommodate any variation of
segregated lists implementation. A comparison with a previously
introduced fragmentation model is performed as well as a comparison
with actual fragmentation values that were extracted from 
Finally the idea of a test-bed application that will use the proposed
model to provide to programmers/developers the ability to know, prior
to a programs execution, the fragmentation and memory utilization of
their programs, is also introduced. With this application at hand
developers as well as designers of applications could better assess the
stability, efficiency as well reliability of their applications at
compile time.},
URL = {http://www.sciencedirect.com/science?_ob=ArticleURL&_udi=B6V0N-47TNY25-1&_coverDate=12%2F15%2F2002&_alid=74011184&_rdoc=1&_fmt=&_orig=search&_qd=1&_cdi=5651&_sort=d&_acct=C000010239&_version=1&_urlVersion=0&_userid=125871&md5=548c0452d7145eaaf6c7b1132bc62af7},
comment = {Entirely unconvincing.}
}


@inproceedings{skub97,
author = {M. Skubiszewski and P. Valduriez},
title = {Concurrent Garbage Collection in {O2}},
booktitle = {{VLDB'97} Proceedings of 23rd International Conference on
Very Large Databases},
editor = {M. Jarke and M.J. Carey and K.R. Dittrich and F.H. Lochovsky
and P. Loucopoulos and M.A. Jeusfeld},
address = {Athens},
month = may,
pages = {356--365},
publisher = MK,
year = 1997
}

@article{slat91,
author = "Michael Slater",
title = "{PA} Workstations Set Price/Performance Records",
journal = "Microprocessor Report",
volume = 5,
number = 6,
month = apr,
year = 1991
}

@article{slus87,
author = "Maciej Slusarek",
title = "An Off-Line Storage Allocation Algorithm",
journal = IPL,
publisher = NH,
volume = 24,
number = 2,
month = jan,
year = 1987,
pages = "71--75"
}

@techreport{smet93,
author = "S. Smetsers and E. Barendsen and van Eekelen, M. J. C. D and R. Plasmeijer",
title = "Guaranteeing Safe Destructive Updates through a Type System  with Uniqueness Information for Graphs",
institution = "University of Nijmegen",
number = "93--4",
year = 1993
}

@article{smit76,
author = "Alan J. Smith",
title = "A Modified Working Set Paging Algorithm",
journal = IEEETransSWE,
publisher = IEEE,
volume = "C-25",
number = 9,
month = sep,
year = 1976,
pages = "907--914"
}

@article{smit78,
author = "Alan J. Smith",
title = "Sequential Program Prefetching in Memory Hierarchies",
journal = IEEETransComp,
publisher = IEEE,
volume = 11,
number = 12,
month = dec,
year = 1978,
pages = "7--21"
}

@article{smit82,
author = "Alan J. Smith",
title = "Cache Memories",
journal = "Computing Surveys",
publisher = ACM,
volume = 14,
number = 3,
month = sep,
year = 1982,
pages = "473--530"
}

@inproceedings{smit85,
author = "Alan J. Smith",
title = "Cache Evaluation and the Impact of Workload Choice",
crossref = "ISCA85",
pages = "64--73"
}

@article{smit86,
author = "Alan J. Smith",
title = "Bibliography and Readings on CPU Cache Memories and Related Topics",
journal = "Computer Architecture News",
volume = 14,
number = 1,
year = 1986,
month = jan,
pages = "22--42"
}

@article{smit87,
author = "Alan J. Smith",
title = "Line (Block) Size Choice for CPU Cache Memories",
journal = IEEETransComp,
publisher = IEEE,
volume = "C-36",
number = 9,
month = sep,
year = 1987,
pages = "1063--1075"
}

@techreport{smit89,
author = "Jane Smith",
title = "A Garbage Collector for {FP9}",
institution = "University of New Dundee",
year = 1989
}

@techreport{smit97,
author = {Frederick Smith and Greg Morrisett},
title = {Mostly Copying Collection: A Viable Alternative to Conservative Mark-Sweep},
institution = {Cornell},
year = 1997
}

@inproceedings{smit98,
author = {Frederick Smith and Greg Morrisett },
title = {Comparing Mostly-Copying and Mark-Sweep Conservative Collection},
pages = {68--78},
crossref = {ISMM98},
abstract = {Many high-level language compilers generate C code and then invoke
a C compiler for code generation, register allocation, stack
management, and low-level optimization. To date, most of these
compilers link the resulting code against a conservative mark-sweep
garbage collector in order to reclaim unused memory. We introduce a
new collector, MCC, based on an extension of mostly-copying
collection. 

We analyze the various design decisions made in \mcc and provide a
performance comparison to the most widely used conservative
mark-sweep collector (the Boehm-Demers-Weiser collector). Our
results show that a good mostly-copying collector can outperform a
mature highly-optimized mark-sweep collector when physical
memory is large relative to the live data. A surprising result of our
analysis is that cache behavior has a greater impact on overall
performance than either collector time, or allocation code. }
}

@article{snep87,
title = "Algorithms for On-The-Fly Garbage Collection Revisited",
author = "van de Snepscheut, Jan",
pages = "211--216",
journal = IPL,
publisher = NH,
year = "1987",
month = mar,
volume = 24,
number = 4
}

@techreport{snyd79,
author = "A. Snyder",
title = "A Machine Architecture to Support an Object-Oriented Language",
institution = "MIT Laboratory for Computer Science",
type = "Technical Memo",
number = "MIT/LCS/TR--209",
month = mar,
year = 1979,
URL = "ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/listings/abstracts/TR-209.html"
}

@techreport{soba88,
author = "Sobalvarro, Patrick ",
institution = "{MIT} {AI} {L}ab",
title = "A Lifetime-Based Garbage Collector for {L}isp Systems on General-Purpose Computers",
year = 1988,
URL = "ftp://publications.ai.mit.edu/ai-publications/1994/AITR-1417.ps.Z",
month = feb,
number = "{AITR}-1417",
note = "Bachelor of Science thesis"
}

@techreport{soma04,
author = {Sunil Soman and Chandra Krintz and David Bacon},
title = {Dynamic Selection of Application-Specific Garbage Collectors},
institution = {UCSB},
number = {2004--09},
month = jan,
year = 2004,
URL = {http://www.cs.ucsb.edu/~ckrintz/papers/2004-09.pdf},
abstract = {In this paper, we describe a novel execution environment
that can dynamically switch between garbage collection (GC) systems. As
such, it enables application-specific GC selection. In addition, the
system can switch between different GC systems while the program is
executing. Our system is novel in that it is able to switch between a
wide range of diverse collection systems. To empirically evaluate our
system, we implemented annotation-guided GC selection and we show its
efficacy for a wide range of benchmarks and heap sizes. In addition, we
implemented a simple heuristic that automatically identifies when to
switch collectors when program execution behavior warrants it. Our
system introduces an average overhead of 4\% for both annotation-guided
and automatic switching. Perhaps more importantly however, we
significantly improve performance over selecting the wrong collection
system (by 19\% using annotation-guided selection and by 16\% using
automatic switching, on average).}
}

@inproceedings{sous93,
author = "Pedro Sousa",
title = "Garbage Collection of Persistent Objects in a Distributed Object-Oriented Platform",
crossref = "OOPSLA93-gc",
}

@inproceedings{spar93,
title = "Fixing Some Space Leaks without a Garbage Collector",
author = "Jan Sparud",
address = "Chalmers University of Technology",
crossref = "FPCA93",
}

@article{sper96a,
title = "Automating Memory Management",
author = "Michael Spertus",
journal = "Object Currents",
URL = "http://www.sigs.com/publications/docs/oc/9602/oc9602.c.spertus.html",
publisher = "SIGS Publications, Inc",
month = jan,
year = 1996,
}

@article{sper96,
title = "Garbage Collection in {C++}",
author = "Michael Spertus",
journal = "Object magazine",
publisher = "SIGS Publications, Inc",
volume = 5,
number = 9,
month = mar,
year = 1996,
comment = "Largely pro-GC propaganda from President of Geodesic Systems"
}

@article{sper97,
title = {{C++} and Garbage Collection},
author = "Michael Spertus",
journal = Dobbs,
volume = 22,
number = 12,
month = dec,
pages = {36--41},
year = 1997
}

@misc{spin,
key = "SPIN",
title = "The {SPIN} Operating System",
howpublished = "A collection of papers avilable on the WWWW",
URL = "http://www.cs.washington.edu/research/projects/spin/www/",
comment = "An operating system written in Modula-3 that, according to David
Chase, takes advantage of system-level optimisations made possible by GC"
}

@article{sris99,
author = {W. Srisa-an and C. D. Lo and J. Morris Chang},
title = {A Hardware Implementation of Realloc function},
journal = {Integration, the {VLSI} Journal},
volume = 28,
pages = {173--184},
publisher = ES,
year = 1999
}

@inproceedings{sris99a,
author = {W. Srisa-an and C. D. Lo and J. Morris Chang},
title = {A Hardware Implementation of Realloc function},
booktitle = {Proceedings of WVLSI'99 IEEE Annual Workshop on VLSI},
address = {Orlando, FL},
month = apr,
pages = {697--699},
year = 1999
}

@inproceedings{sris00,
author = {W. Srisa-an and Chia-Tien Dan Lo and J. Morris Chang},
title = {Active Memory: Garbage-Collected Memory for Embedded Systems},
booktitle = {Second Annual Workshop on Hardware Support for Objects and Microarchitectures for {J}ava},
address = {Austin, TX},
month = sep,
year = 2000,
pages = {11--15}
}

@inproceedings{sris00a,
author = {W. Srisa-an and Chia-Tien Dan Lo and J. Morris Chang},
title = {Scalable Hardware-algorithm for Mark-sweep Garbage Collection},
booktitle = {Proceedings of Euromicro Conference on Digital System Design},
address = {Maastricht, Netherlands},
month = sep,
year = 2000,
pages = {274--279}
}

@inproceedings{sris00b,
author = {W. Srisa-an and J. Morris Chang and Chia-Tien Dan Lo},
title = {Do Generational Schemes Improve the Garbage Collection Efficiency?},
booktitle = {Proceedings of IEEE International Symposium on Performance Analysis of Systems and Software},
address = {Austin, TX},
publisher = IEEE,
month = apr,
year = 2000,
pages = {58--63},
URL = {http://ieeexplore.ieee.org/iel5/6790/18223/00842283.pdf}
}

@inproceedings{sris00c,
author = {J. Morris Chang and W. Srisa-an and Chia-Tien Dan Lo},
title = {Architectural Support for Dynamic Memory Management},
booktitle = {Proceedings of IEEE International Conference on Computer Design},
address = {Austin, TX}, 
month = sep,
year = 2000, 
pages = {99-104}
}

@article{sris02,
author = {W. Srisa-an and Chia-Tien Dan Lo and J. Morris Chang},
title = {Object Resizing and Reclamation through the Use of Hardware Bit-maps},
journal = {International Journal of Microprocessors and Microsystems}, 
publisher = {Elsevier Science},
volume = 25, 
year = 2002, 
pages = {459--467}
}

@inproceedings{sris02a,
author = {W. Srisa-an and Chia-Tien Dan Lo and J. Morris Chang},
title = {Performance Enhancements to the Active Memory System},
booktitle = {Proceedings of IEEE International Conference on Computer Design, (ICCD 2002)}, 
address = {Freiburg, Germany}, 
month = sep, 
year = 2002, 
pages = {249--256}
}

@article{sris03,
author = {W. Srisa-an and Chia-Tien Dan Lo and J. Morris Chang},
title = {Active Memory Processor: A Hardware Garbage Collector for Real-time {J}ava Embeded Devices},
journal = {IEEE Transactions on Mobile Computing}, 
volume = 2,
number = 2,
month = {April--June},
year = 2003, 
pages = {89--101}
}

@article{sris03a,
author = {W. Srisa-an and Chia-Tien Dan Lo and J. Morris Chang},
title = {Hardware Support for Garbage Collection in Embedded Systems Using the Active Memory Module},
journal = {International Journal of Microprocessors and Microsystems}, 
publisher = {Elsevier Science},
year = {to appear}
}

@techreport{stal80,
author = "Richard M. Stallman",
title = "Phantom Stacks: If You Look Too Hard, They Aren't There",
institution = "MIT AI Laboratory",
type = "AI Memo",
number = 556,
month = jul,
year = 1980
}

@techreport{stam82,
author = "Stamos, James W.",
title = "A Large Object-Oriented Virtual Memory: Grouping Strategies,
Measurements, and Performance",
institution = PARC,
number = "SCG-82-2",
month = May,
year = 1982    
}


@article{stam84,
title = "Static Grouping of Small Objects to Enhance Performance of a Paged Virtual Memory",
author = "Stamos, James W.",
journal = TransCompSys,
publisher = ACM,
volume = 2,
number = 3,
month = May,
year = 1984, 
pages = "155--180",
comment = "Using the garbage collector to improve performance"
}


@techreport{stam86,
author = "James W. Stamos",
title = "Programmer-Invoked Local Garbage Collection: A Design",
number = "unpublished draft",
institution = "MIT",
year = 1986     }



@book{stan80,
author = "Thomas A. Standish",
title = "Data Structures Techniques",
publisher = AW,
year = 1980,  
comments = {book with sections on garbage collection --- valuable reference},
}

@mastersthesis{stap90,
author = "Stapleton, Sue M",
title = "Real-Time Garbage Collection for General Purpose Languages",
school = "Iowa State University, Department of Computer Science",
year = 1990,
number = "TR90-13",
month = Aug,
abstract = "Programming languages that support dynamically 
allocated memory enable programmers to abstract memory 
management, freeing the development process from time consuming 
details and troublesome bugs associated with allocation and 
reclamation of dynamically allocated memory.  The garbage 
collection scheme described in this paper is real time in the 
sense that allocation of memory is performed in time proportional 
to the size of the memory request and all other memory operations 
execute in constant time.  The scheme is general purpose in that 
it defines a memory protocol whereby multiple languages and 
applications are able to share access to a global garbage 
collected memory.
The algorithm presented in this paper is based upon Baker's 
algorithm for real-time garbage collection of lists.  This 
algorithm differs from Baker's in that it supports arbitrarily 
large objects, including overlapping slices of large arrays."
}

@article{stee75,
author = "Guy L. Steele",
title = "Multiprocessing Compactifying Garbage Collection",
journal = CACM, 
publisher = ACM,
volume = 18,
number = 9,
pages = "495--508",
month = Sep,
comments = "First parallel garbage collection algorithm.
Uses a stack (rather than colours a la Dijkstra) to communicate between
mutator and collector.
Complex because it includes compaction, parameter passing mechanism,
synchronisation as well as GC.",
year = "1975"}


@article{stee76,
author = "Guy L. Steele",
title = "Corrigendum: Multiprocessing Compactifying Garbage Collection",
journal = CACM, 
publisher = ACM,
volume = 19,
number = 6,
pages = "354",
month = Jun,
comments = "Correction to the algorithm in \cite{stee75}",
year = "1976"}


@techreport{stee77,
author = "Guy L. Steele",
title = "Data Representation in {PDP-10} {MACLISP}",
institution = MITAI,
type = {AI Memo},
number = 421,
year = 1977,
}


@techreport{stee78,
author = "Guy L. Steele",
title = "{RABBIT}: A Compiler for {SCHEME}",
institution = MIT,
year = 1978,
month = may
}


@phdthesis{stee87,
author = "Steenkiste, Peter",
title = "Lisp on a Reduced-Instruction-Set Processor:  Characterization and
Optimization",
school = "Stanford University",
address = "Also appears as Technical Report CSL-TR-87-324, Stanford University Computer System Laboratory, Palo Alto, CA",
month = mar,
year = 1987 
}

@inproceedings{stee87a,
author = "Peter Steenkiste and John Hennessy",
title = "Tags and Type Checking in {LISP}: Hardware and Software Approaches",
crossref = "ASPLOS87",
pages = "50--59",
}

@inproceedings{stee89,
author = "Peter Steenkiste",
title = "The Impact of Code Density on Instruction Cache Performance",
booktitle = "Proceedings of Sixteenth Annual International Symposium on
Computer Architecture",
pages = "252--259",
month = may,
year = 1989
}

@inproceedings{stee00,
author = {Bjarne Steensgaard},
title = {Thread-Specific Heaps for Multi-Threaded Programs},
crossref = {ISMM2000},
abstract = {
Given an escape analysis, a memory management system may allocate
thread-specific data in thread-specific heaps and allocate shared data in a
shared heap. Garbage collection of data in a thread-specific heaps can be
done independent of other threads and of data in their thread-specific
heaps. For multi-threaded programs, thread-specific heaps allow less
garbage collection latency for active threads. On multi-processor
computers, thread-specific heaps allow concurrent garbage collection of
different thread-specific heaps with minimal synchronization overhead. We
present an escape analysis and a sample memory management system
using thread-specific heaps. 
}
}

@inproceedings{stef93,
author = {Darko Stefanovi\'{c}},
title = "The Garbage Collection Toolkit as an Experimentation Tool",
crossref = "OOPSLA93-gc",
URL = {ftp://ftp.cs.umass.edu/pub/osl/papers/gc-workshop93b.ps.Z}
}

@mastersthesis{stef93a,
author = {Darko Stefanovi\'{c}},
title = {Generational Copying Garbage Collection for {S}tandard {ML}: a Quantitative Study},
school = {University of Massachusetts},
year = 1993
}

@inproceedings{stef94,
author = {Darko Stefanovi\'{c} and J. Eliot B. Moss},
title = "Characterisation of Object Behaviour in {S}tandard {ML} of {N}ew {J}ersey",
crossref = "LFP94",
pages = {43-54},
URL = {ftp://ftp.cs.umass.edu/pub/osl/papers/lfp94.ps.Z}
}

@techreport{stef98,
author = {Darko Stefanovi\'{c} and J. Eliot B. Moss and Kathryn S.  McKinley},
title = {On Models for Object Lifetime},
institution = {University of Massachussets},
month = feb,
year = 1998,
}

@techreport{stef98a,
author = {Darko Stefanovi\'{c} and J. Eliot B. Moss and Kathryn S.  McKinley},
title = {Oldest-First Garbage Collection},
institution = {University of Massachussets},
number = {98--81},
month = apr,
year = 1998,
}

@phdthesis{stef99,
author = {Darko Stefanovi\'{c}},
title = {Properties of Age-Based Automatic Memory Reclamation Algorithms},
school = {University of Massachusetts},
year = 1999
}

@techreport{stef99a,
author = {Darko Stefanovi\'{c} and J. Eliot B. Moss and Kathryn S.  McKinley},
title = {Age-Based Garbage Collection},
institution = {University of Massachussets},
month = apr,
year = 1999,
URL = {ftp://ftp.cs.umass.edu/pub/osl/papers/oopsla99.ps.Z},
note = {preliminary version of a paper to appear in OOPSLA'99}
}

@inproceedings{stef99b,
author = {Darko Stefanovi\'{c} and Kathryn S. McKinley and J. Eliot B. Moss},
title = {Age-Based Garbage Collection},
booktitle = "Proceedings of the {ACM} Conference on Object-Oriented Systems, Languages and Applications",
address = {Denver, CO},
volume = "34(10)",
month = oct,
year = 1999,
pages = {370-381}
}

@inproceedings{stef00,
author = {Darko Stefanovic and Kathryn S. McKinley and J. Eliot B. Moss},
title = {On Models for Object Lifetime Distributions},
crossref = {ISMM2000},
abstract = {
Analytical models of object lifetimes are appealing because they would
enable mathematical analysis or fast simulation of the memory
management behavior of programs. In this paper, we investigate models
for object-oriented programs such as Java and Smalltalk. We present
analytical models and compare them with observed lifetimes for 58
Smalltalk and Java programs. We find that observed lifetime
distributions do not match previously proposed object lifetime models,
but do agree in salient shape characteristics with the gamma
distribution family used in statistical survival analysis for general
populations.
}
}

@unpublished{sten76,
author = {V. Stenning},
title = {On-the-fly Garbage Collection},
note = {Unpublished notes, cited by \cite{grie77}},
year = 1976,
comment = {The Woodger-Stenning scenario, cited by \cite{grie77}}
}

@article{step83,
author = "C. J. Stephenson",
title = "Fast Fits: New Methods of Dynamic Storage Allocation",
journal = "Operating Systems Review",
publisher = ACM,
volume = 15,
number = 5,
month = oct,
year = 1983,
note = "Also in Proceedings of Ninth Symposium on Operating Systems Principles,
Bretton Woods, New Hampshire, October 1983"
}

@inproceedings{stic99,
author = {James M. Stichnoth and Guei-Yuan Lueh and Michal Cierniak},
title = {Support for Garbage Collection at Every Instruction in a {J}ava Compiler},
crossref = {PLDI99},
pages = {118--127}, URL = {http://riss.keris.or.kr:8080/pubs/citations/proceedings/pldi/301618/p118-stichnoth/}
}

@techreport{ston82,
author = "Harold S. Stone",
title = "Parallel Memory Allocation Using the {FETCH}-{AND}-{ADD} Instruction",
institution = "IBM Thomas J. Watson Research Center",
address = "Yorktown Heights, New York",
month = nov,
year = 1982
}

@article{ston92,
author = "Harold S. Stone and John Turek and Joel L. Wolf",
title = "Optimal Partitioning of Cache Memory",
journal = IEEETransComp,
publisher = IEEE,
volume = 41,
number = 9,
month = sep,
year = 1992,
pages = "1054--1068"
}

@inproceedings{stoy84,
author = "Will R. Stoye and T. J. W. Clarke and Arthur C. Norman",
title = "Some Practical Methods for Rapid Combinator Reduction",
crossref = "LFP84",
pages = "159--166",
comment = "
The SKIM -- special purpose Turner combinator machine.
Useful empirical data.
Few cells shared, many are short lived."
}

@phdthesis{stout97,
author = "David Stoutamire",
title = "Portable, Modular Expression of Locality",
school = "University of California at Berkeley",
URL = "http://www.stoutamire.com/david/berkeley_thesis.ps.gz",
year = 1997,
abstract = {
It is difficult to achieve high performance while programming in the
large. In particular, maintaining locality hinders portability and
modularity. Existing methodologies are not sufficient: explicit
communication and coding for locality require the programmer to violate
encapsulation and compositionality of software modules, while automated
compiler analysis remains unreliable.

This thesis presents a performance model that makes thread and object
locality explicit. Zones form a runtime hierarchy that reflects the
intended clustering of threads and objects, which are dynamically
mapped onto hardware units such as processor clusters, pages, or cache
lines. This conceptual indirection allows programmers to reason in the
abstract about locality without committing to the hardware of a
specific memory system. Zones complement conventional coding for
locality and may be added to existing code to improve performance
without affecting correctness.

The integration of zones into the Sather language is described,
including an implementation of memory management customized to
parameters of the memory system. }
}

@article{stra89,
title = "Object Management in a Persistent {S}malltalk System",
author = "A. Straw and F. Mellender and S. Riegel",
institution = "Eastman Kodak Co., Advanced Computer Research Laboratory,
901 Elmgrove Rd, Rochester, NY, 14653",
journal = SPE,
publisher = Wiley,
year = 1989,
volume = 19,
number = 8,
pages = "719--737",
abstract = {The main goal of the Alltalk project is to provide transparent
database support to the Smalltalk programmer.  As a first step towards this
goal, the current version of Alltalk extends Smalltalk-80 by providing
persistence to Smalltalk objects without adding a database sublanguage, new
language syntax, classes or methods.  This paper describes the implementation
of object management in Alltalk, including database layout, database access
methods, in-memory object management and high-level interface from the
interpreter.  It also discusses how the object manager is integrated in a
unique way with the operations of the Alltalk garbage collector and 
interpreter.}
}

@book{stro91,
author = "Bjarne Stroustrup",
title = "The {C++} Programming Language",
publisher = AW,
edition = "Second",
month = dec,
year = 1991
}

@misc{stro96,
title = "Proposal to Acknowledge that Garbage Collection for {C++} is Possible",
author = "Bjarne Stroustrup",
address = "AT\&T Research, Murray Hill, NJ",
month = may,
year = 1996,
note = "From the C++ core language mailing list, 27 May 1996",
abstract = {The ARM, "The C++ Programming Language (2nd edition)", and
"The Design and Evolution of C++" all mention that automatic garbage collection
of C++ is possible, but that an implementation is not required to
provide a garbage collector. This is a proposal to make this explicit
in the standard and to specify a couple of details of what it means
to collect garbage. The proposal is for clarification rather than
significant normative changes.
 
Introduction

The most loudly proclaimed fundamental weakness of C++ these days
is the absence of automatic garbage collection. This criticism is
harming C++'s reputation, scaring potential users away, and restricting
the range of applications for which C++ is a strong contender as an
implementation language. For many applications automatic garbage
collection is indeed a very powerful tool and the right tool for
the job.

It is my firm opinion that the complaints about the lack of garbage
collection in C++ will continue, will become louder as more alternative
languages provide garbage collection, and that the cases where the
complaint is based on valid reasons will become more frequent.

My defense has traditionally been that garbage collection is possible
for C++ and that garbage collecting implementations do indeed exist.
Currently both public domain and commercial garbage collectors for C++
are shipping. Nothing in the definition of C++ requires garbage
collection - and if it did serious harm would be done to many C++
users - but on the other hand nothing prevents it from being done
either. See D&E for a fairly detailed discussion of C++ and garbage
collection.

However, the "permitted but not required" position is weakened by
being implicit rather than explicit in the draft standard and by
a couple of possible alternatives in the meaning of "garbage
collection for C++." I therefore propose to make "permitted but not
required" explicit by defining what it means to be "garbage."

My proposal reflects my opinion that we now have seen enough
implementations to know that automatic garbage collection is
viable for C++ and also a convergence of opinion of how to handle
the unspecified cases. I expect to see a significant increase in
the use of garbage collectors with C++ over the next few years.
Providers and users of garbage collectors or C++ would like their
implementations to be standards conforming and to know precisely
what that means.

Most of the suggestions below are clarifications and only one
affects conformance.}
}

@inproceedings{stro98,
title = {Schedule-Independent Storage Mapping for Loops},
author = {M. Strout and L. Carter and J. Ferrante and B. Simon},
crossref = {ASPLOS98},
comment = {was "Finding a Storage Reuse Pattern for any Legal Loop Schedule"}
}


@article{stum90,
author = "M. Stumm and Songnian Zhou",
title = "Algorithms Implementing Distributed Shared Memory",
journal = "IEEE Computing",
publisher = IEEE,
volume = 23,
number = 5, 
month = May,
year = 1990
}

@inproceedings{stum90a,
author = "Michael Stumm and Songnian Zhou",
title = "Fault Tolerant Distributed Shared Memory",
booktitle = "Proceedings of IEEE International Conference on Parallel Distributed Computing",
publisher = IEEE,
month = dec,
year = 1990
}

@techreport{styg67,
author = "P. Stygar",
title = "{LISP} 2 Garbage Collector Specifications",
institution = "System Development Corporation",
number = "TN-3417/500/00",
month = apr,
year = 1967
}

@inproceedings{subr91,
author = "Indira Subramanian",
title = "Managing Discardable Pages with an External Pager",
booktitle = "USENIX Mach Symposium",
publisher = UA,
address = "Monterey, CA",
month = nov,
year = 1991,
pages = "77--85"
}

@inproceedings{sugi83,
author = "Sugimoto, S. and others",
title = "A Multi-Microprocessor System for {C}oncurrent {L}isp",
booktitle = "International Conference on Parallel Processing",
year = 1983,
month = jun
}

@inproceedings{suga03,
author = {Toshio Suganuma and Toshiaki Yasue and and Toshio Nakatani},
title = {A Region-Based Compilation Technique for a {J}ava Just-In-Time Compiler},
crossref = "PLDI03"
}

@inproceedings{sull91,
author ={Mark Sullivan and Ram Chillarege},
title = {Software Defects and their Impact on System Availability --
A Study of Field Failures in Operating Systems},
booktitle = {Digest of the 21st International Symposium on Fault Tolerant Computing},
pages = {2--9},
month = jun,
year = 1991,
comment = {Authors ascribe almost half the errors in IBM MVS to pointer
and array access errors}
}

@article{sult02,
author = {Florin Sultan and Thu D. Nguyen and Liviu Iftode},
title = {Lazy Garbage Collection of Recovery State for Fault-Tolerant Distributed Shared Memory},
journal = {{IEEE} Transactions on Parallel and Distributed Systems},
volume = 13,
number = 10,
month = oct,
year = 2002,
pages = { 673-686},
URL = {http://csdl.computer.org/comp/trans/td/2002/07/l7toc.htm},
note = {This paper contains some errors which led to the paper being reprinted in \cite{sult02a}}
}

@article{sult02a,
author = {Florin Sultan and Thu D. Nguyen and Liviu Iftode},
title = {Lazy Garbage Collection of Recovery State for Fault-Tolerant Distributed Shared Memory},
journal = {{IEEE} Transactions on Parallel and Distributed Systems},
volume = 13,
number = 10,
month = oct,
year = 2002,
pages = {1085--1098},
URL = {http://csdl.computer.org/comp/trans/td/2002/10/lxtoc.htm}
}

@inproceedings{sun97,
title = {A {S}malltalk Memory Profiler and its Performance Enhancement},
author = {Jingyu Sun and Edward F. Gehringer},
URL = {ftp://ftp.dcs.gla.ac.uk/pub/drastic/gc/was-rtf.ps},
crossref = {OOPSLA97-gc}
}

@inproceedings{suzu95,
title = "{MOA} --- A Fast Sliding Compaction Scheme for a Large Storage Space",
author = "Mitsugu Suzuki and Hiroshi Koide and Motoaki Terashima",
address = "The University of Electro-Communications, Tokyo",
crossref = "IWMM95",
}

@article{suzu95a,
author = "Mitsugu Suzuki and Motoaki Terashima",
title = "Time- and Space-Efficient Garbage Collection Based on Sliding Compaction",
journal = "Transaction of Information Processing (IPSJ)",
volume = 36,
number = 4,
pages = "925--931",
year = 1995
}

@techreport{swan86,
author = "M. Swanson",
title = "An Improved Portable Copying Garbage Collector",
institution = "University of Utah",
type = "{OPnote}",
number = "86--03",
month = feb,
year = 1986
}

@techreport{swin86,
author = "Daniel C. Swinehart and Polle T. Zellweger and Richard J. Beach 
and Robert B. Hagmann",
title = "A Structural View of the {C}edar Programming Environment",
institution = "Xerox Corporation",
number = "CSL--86--1",
year = 1986
}

@article{szok77,
title = "Some Remarks on New Instances and Garbage Collection",
author = {P\'{e}ter Sz\"{o}ke},
note = "Proceedings of Strathclyde Algol-68 Conference",
journal = SIGPLAN,
publisher = ACM,
volume = 12,
number = 6,
month = Jun,
year = 1977
}

@inproceedings{szyn99,
author = {R. Szymanek and K. Kuchcinski},
title = {Design Space Exploration in System Level Synthesis under Memory Constraints},
booktitle = {Euromicro 35},
address = {Milan},
month = sep,
year = 1999,
URL = {http://www.dna.lth.se/Research/ESD/doc/pub_1.pdf}
}

@inproceedings{szyn00,
author = {R. Szymanek and K. Kuchcinski},
title = {Task Assignment and Scheduling under Memory Constraints},
booktitle = {Euromicro 2000},
year = 2000,
URL = {http://www.dna.lth.se/Research/ESD/doc/EuroMicro2000_pub_4.pdf}
}

@inproceedings{szyn01,
author = {R. Szymanek and K. Kuchcinski},
title = {A Constructive Algorithm for Memory-Aware Task Assignment and Scheduling},
booktitle = {Ninth International Symposium on Hardware/Software Codesign},
address = {Copenhagen},
month = apr,
year = 2001,
URL = {http://www.dna.lth.se/Research/ESD/doc/Codes_2001.pdf}
}

@mastersthesis{szym01a,
author = {R. Szymanek},
title = {Memory Aware Task Assignment and Scheduling for Multiprocessor Embedded Systems},
school = "Department of Computer Science, Lund University",
month = jun,
year = 2001,
ISSN = {1404-1219},
URL = {http://www.dna.lth.se/Research/ESD/doc/radek_lic.ps.gz}
}
@mastersthesis{tadm78,
author = "M. Tadman",
title = "Fast-Fit: A New Hierarchical Dynamic Storage Allocation Technique",
school = "UC Irvine, Computer Science Department",
year = 1978
}

@inproceedings{take90,
author = "Tomohiro Takeda",
title = "A Garbage Collecting Method for Object-Oriented Concurrent
Languages",
crossref = "OOPSLA90-gc",
}

@book{tane88,
author = "Andrew S. Tanenbaum",
title = "Computer Networks",
edition = "Second",
publisher = PH,
year = 1988
}

@inproceedings{tara92,
title = "Ecological Memory Management in a Continuation Passing {P}rolog Engine",
author = "P. Tarau",
address = {Universit\'{e} de Moncton, Canada},
crossref = "IWMM92",
}

@inproceedings{tard93,
author = "David Tarditi and Amer Diwan",
title = "The Full Cost of a Generational Copying Garbage Collection Implementation",
crossref = "OOPSLA93-gc",
URL = "ftp://ftp.cs.umass.edu/pub/osl/papers/gc-workshop93a.ps.Z"
}

@techreport{tard94,
author = "David Tarditi and Amer Diwan",
title = "Measuring the Cost of Storage Management",
institution = CMU,
number = "CMU-CS-94-201",
year = 1994,
URL = "http://www.cs.cmu.edu/afs/cs.cmu.edu/project/fox-1/dtarditi/dist/CMU-CS-94-201.ps",
note = "Accepted for publication in " # LSC
}

@article{tard96,
author = "David Tarditi and Amer Diwan",
title = "Measuring the Cost of Storage Management",
journal = LSC,
volume = 9,
number = 4,
year = 1996,
}

@inproceedings{tard00,
author = {David Tarditi},
title = {Compact Garbage Collection Tables},
crossref = {ISMM2000},
abstract = {
Garbage collection tables for finding pointers on the stack can be
represented in 20-25\% of the space previously reported. Live pointer
information is often the same at many call sites because there are few
pointers live across most call sites. This allows live pointer information to be
represented compactly by a small index into a table of descriptions of
pointer locations. The mapping from program counter values to those small
indexes can be represented compactly using several techniques. The
techniques all assign numbers to call sites and use those numbers to index
an array of small indexes. One technique is to represent an array of return
addresses by using a two-level table with 16-bit offsets. Another technique
is to use a sparse array of return addresses and interpolate the exact
number via disassembly of the executable code. 
}
}

@article{tarj72,
author = {R. Tarjan},
title = {Depth-first search and linear graph algorithms},
journal = {{SIAM} Journal of Computing},
volume = 1,
number = 2,
year = 1992
}

@inproceedings{taur97,
author = {Kenjiro Taura and Akinori Yonezawa},
institution = {University of Tokyo},
title = {An Effective Garbage Collection Strategy for Parallel Programming
Languages on Large Scale Distributed-Memory Machines},
crossref = {PPoPP97},
pages = {264--275},
URL = {ftp://ftp.yl.is.s.u-tokyo.ac.jp/pub/papers/ppopp97-effective-a4.ps.gz}
}

@phdthesis{taur97a,
title = {Efficient and Reusable Implementation of Fine-Grain Multithreading and Garbage Collection on Distributed-Memory Parallel Computers},
author = {Kenjiro Taura and Akinori Yonezawa},
school = {University of Tokyo},
URL = {http://web.yl.is.s.u-tokyo.ac.jp/pub/papers/},
year = 1997
}


@inproceedings{tayl86,
author = "George S. Taylor and Paul N. Hilfinger and James R. Larus and David A. Patterson and Benjamin G. Zorn",
title = "Evaluation of the {SPUR} {Lisp} Architecture",
booktitle = "Proceedings  of the Thirteenth Symposium on Computer Architecture",
month = jun,
year = 1986
}

@book{tayl89,
title = "Parallel Logic Programming Techniques",
author = "S. Taylor",
publisher = PH,
year = "1989",
pages = "205",
isbn = "0--13--648767--X",
abstract = {This book explains the basics of parallel programming at a high level,
assuming that the reader is acquainted both with implementations of
sequential Prolog based on the Warren abstract machine (WAM) and with
fundamental concepts of parallel logic programming languages.
Chapter 4 covers the run-time environment for parallel logic programs. 
An implementation of an abstract interpreter demonstrates problems such as
system-wide garbage collection and detection of global termination. The
author presents a suitable algorithm for each problem.  }
}


@article{tel87,
title = "The Derivation of On-The-Fly Garbage Collection Algorithms from
Distributed Termination Detection Protocols",
author = "Gerard Tel and Richard B. Tan and van Leeuwen, Jan ",
institution = "State University of  Utrecht, Department of Computer Science, POB 80012, 3508 TD Utrecht,  
Netherlands",
journal = LNCS,
publisher = SV,
year = 1987,
volume = 247,
pages = "445--455"
}


@article{tel88,
title = "The Derivation of Graph Marking Algorithms from Distributed 
Termination Detection Protocols",
author = "Gerard Tel and Richard B. Tan and van Leeuwen, Jan ",
address = "University of  Utrecht, Department of Computer Science, 3508 TA Utrecht, Netherlands",
journal = "Science Of Computer Programming",
year = 1988,
volume = 10,
number = 2,
pages = "107--137"
}


@inproceedings{tel91,
title = "The Derivation of Distributed Termination Detection Algorithms 
from Garbage Collection Schemes --- (Extended Abstract)",
author = "Gerard Tel and Friedmann Mattern",
institution = "{Department of Computer Science, Utrecht University, Netherlands} and
{University of  Kaiserslautern, Department of Computer Science, Germany}",
crossref = "PARLE91",
comment = "Every active process and every message contains a reference to an object Z.
Z unreachable is equivalent to termination."
}


@article{tel93,
title = "The Derivation of Distributed Termination Detection Algorithms 
from Garbage Collection Schemes",
author = "Gerard Tel and Friedmann Mattern",
institution = "{Department of Computer Science, Utrecht University, Netherlands} and
{University of  Kaiserslautern, Department of Computer Science, Germany}",
journal = TOPLAS,
publisher = ACM,
year = 1993,
month = Jan,
volume = 15,
number = 1,
comment = "Termination detection problem for sidtributed algorithms can be modelled as an
instance of the GC problem."
}

@book{tel91a,
author = "Gerard Tel",
title = "Topics in Distributed Algorithms",
publisher = CUP,
address = "New York",
series = "Cambridge international series on parallel computation",
volume = 1,
year = 1991,
ISBN = {0-521-47376-6}
}

@book{tel94,
author = "Gerard Tel",
title = "Introduction to Distributed Algorithms",
publisher = CUP,
year = 1994,
ISBN = {0-521-47069-2}
}


@techreport{temp91,
author = "J. Templ",
title = "Oberon Technical Notes: Garbage Collection on Open Arrays",
pages = "48--54",
month = mar,
URL = "ftp://neptune.inf.ethz.ch/doc/tech-reports/1991/156.ps.Z",
year = 1991,
type = "ETH Technical Report",
number = 156,
institution = {ETH Eidgen\"{o}ssische Technische Hochschule Z\"{u}rich}
}

@article{tera78,
author = "Motoaki Terashima and  Eiichi Goto",
title = "Genetic Order and Compactifying Garbage Collectors",
journal = IPL,
publisher = NH,
volume = 7,
number = 1,
month = Jan,
year = 1978,
pages = "27--32",
comments = {algorithm for compacting varisized cells},
}

@article{terr88,
author = "Douglas B. Terry and Daniel C. Swinehart",
title = "Managing Stored Voice in the Etherphone System",
journal = TransCompSys,
publisher = ACM,
volume = 6,
number = 1,
pages = 	"3--27",
month = 	feb,
year = 1988,
abstract = "The voice mailer in the Etherphone system provides
facilities for recording, editing, and playing stored
voice in a distributed personal-computing environment.
It provides the basis for applications such as voice
mail, annotation of multimedia documents, and voice
editing using standard text-editing techniques. To
facilitate sharing, the voice manager stores voice on a
special voice file server that is accessible via the
local internet. Operations for editing a passage of
recorded voice simply build persistent data structures
to represent the edited voice. These data structures,
implementing an abstraction called voice ropes, are
stored in a server database and consist of lists of
intervals within voice files. Clients refer to voice
ropes solely by reference. Interests, additional
persistent data structures maintained by the server,
serve two purposes: First, they provide a sort of
directory service for managing the voice ropes that
have been created. More importantly, they provide a
reliable reference-counting mechanism, permitting the
garbage collection of voice ropes that are no longer
needed. These interests are grouped into classes; for
some important classes, obsolete interests can be
detected and deleted by a class-specific algorithm that
runs periodically."
}

@manual{texa87,
key = "Explorer, 1987",
organisation = "Texas Instruments",
title = "Explorer (tm) System Software Design Notes",
note = "Texas Instruments part number 2243208--0001*A",
month = jun,
year = 1987
}


@inproceedings{thac87,
author = "Charles P. Thacker and Lawrence R. Stewart and Edwin H. Satterthwaite",
title = "Firefly: A Multiprocessor Workstation",
crossref = "ASPLOS87",
pages = "164--172",
note = "Also DEC SRC Research report 23, December 1987"
}



@article{thaz87,
title = "On the Structural Locality of Reference in {L}isp List Access
Streams",
author = "M. J. Thazhuthaveetil and A. R. Pleszkun",
address = "{Penn State University, Department of Elect Engn} and
{University of  Wisconsin, Department of Computer Science, Madison, WI}",
journal = IPL,
publisher = NH,
year = 1987,
volume = 26,
number = 2,
pages = "105--110"
}

@article{thes77,
author = "Arne Thesen and Tad Pinkerton",
title = "Predicting the Availability of Contiguous Memory",
journal = "International Journal of Computer and Information Sciences",
volume = 6, 
number = 4,
pafges = "279--287",
month = dec,
year = 1977
}

@article{thie89,
author = "Dominique Thiebaut",
title = "The Fractal Dimension of Computer Programs and its Application
to the Prediction of the Cache Miss Ratio",
journal = IEEETransComp,
publisher = IEEE,
month = jul,
year = 1989,
pages = {1012--1026}
}

@article{thie92,
author = "Dominique Thiebaut and Joel L. Wolf and Harold S. Stone",
title = "Synthetic Traces for Trace-Driven Simulation of Cache Memories",
journal = IEEETransComp,
publisher = IEEE,
volume = 41,
number = 4,
month = apr,
year = 1992,
pages = "388-410"
}

@techreport{thom96,
author = {Clark D. Thomborson},
title = {When Virtual Memory isn't Enough},
institution = {University of Auckland},
number = 136,
URL = {http://www.cs.auckland.ac.nz/~techrep/TR136/doc.ps},
month = nov,
year = 1996
}

@phdthesis{thom87,
author = "James G. Thompson",
title = "Efficient Analysis of Caching Systems",
school = UCB,
month = oct,
year = 1987,
note = "Also technical report UCB/CSD 87/374"
}

@techreport{thom81,
author = "R. E. Thomas",
title = "A Dataflow Computer with Improved Asymptotic Performance",
institution = "MIT Laboratory for Computer Science",
year = 1981,
number = "MIT/LCS/TR--265",
comment = {Weighted reference counting},
}

@phdthesis{thom93,
author = "Stephen P. Thomas",
title = "The Pragmatics of Closure Reduction",
school = "The Computing Laboratory, University of Kent at Canterbury",
month = oct,
year = 1993,
comment = "Tailored GC. GC routines are generated at compile time for 
each closure. Uses a copying collector but it must be recursive as
different slots in environment frames may be traced by different
routines."
}

@techreport{thom94,
author = "Stephen P. Thomas and Richard E. Jones",
title = "Garbage Collection for Shared Environment Closure Reducers",
institution = "University of Kent and University of Nottingham",
number = "31--94",
URL = "http://www.cs.ukc.ac.uk/pubs/1994/147/",
month = dec,
year = 1994,
annote = "Describes some of the issues facing the implementor of a
	  garbage collector for TIM.
	  Covers space leaks, need for recursion, tailored garbage collections."
}

@unpublished{thom95,
author = "Stephen P. Thomas",
title = "Having Your Cake and Eating It: Recursive Depth-First Copying Garbage 
Collection with No Extra Stack",
institution = "University of Nottingham",
month = may,
year = 1995,
note = "Personal communication"
}

@article{thom95a,
title = "Garbage Collection in Shared-Environment Closure Reducers:
Space-Efficient Depth First Copying using a Tailored Approach",
author = "Stephen P. Thomas",
pages = "1--7",
journal = IPL,
month = oct,
year = 1995,
volume = 56,
number = 1,
}

@unpublished{thom88,
author = "Simon J. Thompson and Rafael D. Lins",
title = "Cyclic Reference Counting: A Correction to {B}rownbridge's Algorithm", 
address = "The University of Kent at Canterbury, England", 
year = 1988,
note = "Unpublished notes",
comments = {Presents a correction to Brownbridge's algorithm which is
similar to the one suggested in \cite{salk87}}
}

@article{thor72,
author = "Lars-Erik Thorelli",
title = "Marking Algorithms",
journal = "BIT",
volume = 12,
number = 4,
year = 1972,
pages = "555--568",
comments = {variant of Deutsch-Schorr-Waite algorithm for varisized cells.},
}


@article{thor76,
author = "Lars-Erik Thorelli",
title = "A Fast Compactifying Garbage Collector",
journal = "BIT",
volume = 16,
number = 4,
year = 1976,
pages = "426--441",
comments = {variant of Deutsch-Schorr-Waite algorithm for varisized cells.},
}

@book{tick88,
author = {E. Tick},
title = {Memory performance of {P}rolog Architectures},
publisher = {Kluwer},
year = 1988
}

@inproceedings{tick92,
title = "A Compile Time Memory-Reuse Scheme for Concurrent Logic Programs",
author = "E. Tick and S. Duvvuru and R. Sundararajan",
address = "University of Oregon, USA",
crossref = "IWMM92",
}

@techreport{ting75,
author = "D. W. Ting",
title = "Some Results of the Space Requirements of Dynamic Memory Allocation Algorithms",
institution = "Cornell University Department of Computer Science",
number = "75-229",
month = feb,
year = 1975
}

@techreport{toft94,
author = {Mads Tofte and Jean-Pierre Talpin},
title = {A Theory of Stack Allocation in Polymorphically Typed Languages},
number = {Computer Science 93/15},
institution = {University of Copenhagen},
month = jul,
year = 1993
}

@inproceedings{toft94a,
author = {Mads Tofte and Jean-Pierre Talpin},
title = {Implementation of the Typed Call-by-Value $\lambda$-Calculus using a Stack of Regions},
crossref = {POPL94},
URL = {http://www.acm.org/sigplan/proceedings/popl94/PS/S6P1.PS},
pages = {188--201}
}

@article{toft97,
author = {Mads Tofte and Jean-Pierre Talpin},
title = {Region-Based Memory Management},
journal = {Information and Computation},
month = feb,
year = 1997,
URL = {http://www.diku.dk/research-groups/topps/activities/kit2/infocomp97.ps},
note = {An earlier version of this was presented at \cite{POPL94}}
}

@techreport{toft97a,
author = {Mads Tofte and Lars Birkedal and Martin Elsman and Niels Hallenberg and Tommy H{\o}jfeld Olesen and Peter Sestoft and Peter Bertelsen},
title = {Programming with {R}egions in the {ML} {K}it},
number = {DIKU-TR-97/12},
institution = DIKU,
month = apr,
year = 1997,
URL = {http://www.diku.dk/research-groups/topps/activities/kit2/diku97-12.a4.ps.gz}
}

@inproceedings{toft98,
author = {Mads Tofte},
title = {A Brief Introduction to {R}egions},
pages = {186--195},
crossref= {ISMM98},
abstract = {Region-based memory management is a novel form of memory
management for ML-like languages. At runtime, the store is organised as
a stack of so-called regions. A static analysis, called region
inference, determines when regions are allocated and de-allocated and,
for every value-producing expression, into what region the value should
be stored.

The talk gives and overview of the compilation steps that are involved
in region-based memory management for Standard ML. The main emphasis of
the talk is on organisation of a region-based runtime system. The work
is based on experience with the ML Kit with Regions, a new Standard ML
compiler which used regions, instead of traditional garbage collection
techniques, for memory management.}
}

@article{toft98a,
author = {Mads Tofte and Lars Birkedal},
title = {A Region Inference Algorithm},
journal = TOPLAS,
volume = 20,
number = 4,
pages = {734--767},
month = jul,
year = 1998
}

@techreport{toft01,
author = {Mads Tofte and Lars Birkedal and Martin Elsman and Niels Hallenberg and Tommy H{\o}jfeld Olesen and Peter Sestoft},
title = {Programming with {R}egions in the {ML} {K}it, version 4},
institution = {IT University of Copenhagen},
month = oct,
year = 2001,
}

@inproceedings{tolm94,
author = "Andrew Tolmach",
title = "Tag-Free Garbage Collection Using Explicit Type Parameters",
pages = "1--11",
crossref = "PLDI94",
URL = "ftp://ftp.cs.pdx.edu/pub/faculty/apt/tagfree_gc.ps",
}

@phdthesis{tong97,
author    = "Guanshan Tong",
title     = "Leveled Garbage Collection For Automatic Memory Management",
school    = "University of Chicago",
URL="http://www.cs.uchicago.edu/~guanshan/Dissertation/dissertation.ps",
month     = nov,
year      = 1997,
abstract = {Generational garbage collection is one of the most popular
memory management techniques. However, poor predictions of object
lifetimes can greatly reduce the effectiveness of generational 
garbage collectors. Some research has addressed this problem, 
but without much success.
This dissertation presents Leveled Garbage Collection, a new 
algorithm that is not based on object ages. It uses a heap 
structure and collection scheme similar to those of generational
garbage collectors, and has a non-age-based promotion policy 
that doesn't promote all of the live objects, but still 
guarantees ample free space immediately after each garbage 
collection.
Performance evaluation shows that Leveled Garbage Collection
not only substantially outperforms generational garbage 
collectors on a wide range of problems, but also demonstrates 
superior virtual memory performance. }
}

@article{topo79,
author = "R. Topor",
title = "The Correctness of the {S}chorr--{W}aite List Marking Algorithm",
journal = ActInf,
publisher = SV,
volume = 11,
number = 3,
year = 1979,
comments = {proves the correctness of the link reversal algorithm by Deutsch-Schorr-Waite},
}


@phdthesis{tour88,
author = {Toura\"{i}vane},
title = {La R\'{e}cup\'{e}ration de M\'{e}moire dans les Machines 
Non-D\'{e}terministes},
school = {Universit\'{e} d'Aix-Marseille},
year = 1988,
}

@techreport{toua88,
author = "Touati, Herv\'{e}",
title = "A Prolog Garbage Collector for {A}quarius",
institution = UCB,
number = "UCB//CSD-88-443",
month = aug,
year = 1988,
abstract = "Our design is the result of an attempt to incorporate into
Prolog implementations the ideas which made generation scavenging
successful for Lisp and Smalltalk. The main challenge was to take
Prolog technique of memory recovery upon backtracking based on
stack deallocation. We were able to do so with little extra overhead
top of the global stack. This strategy has several advantages: it
improves the locality of the executing program by keeping the data
structures compacted and by allocating new objects in a fixed part
of the address space; it improves the locality and the predictability
of the garbage collection, which can concentrate its efforts on the
fixed size area where new objects are allocated; and it allows us to
use simpler, time-efficient garbage collection algorithms. The
performance of the algorithm is further enhanced by the use of
copying algorithms whenever made possible by the deterministic
nature of the executing program."
}

@inproceedings{toua88a,
author = {Touati, Herv\'{e} and Toshiyuki Hama},
title = {A Light-Weight {P}rolog Garbage Collector},
booktitle = {Proceedings of the International Conference on Fifth Generation Computer Systems},
address = {Tokyo},
pages = {922--930},
year = 1988
}

@inproceedings{tull93,
title = "Limitations of Cache Prefetching on a Bus-Based Multiprocessor",
author = "Dean M. Tullsen and Susan J. Eggers",
crossref = "ISCA93",
pages = {278--288}
}

@article{turn79,
author = "David A. Turner",
title = "A New Implementation Technique for Applicative Languages",
journal = SPE,
publisher = Wiley,
volume = 9,
year = 1979,
comment = "The Turner combinators paper."
}

@incollection{turn81,
author = "David A. Turner",
title = "Recursion Equations as a Programming Language",
booktitle = "Functional Programming and its Applications",
editor = "John Darlington and Peter Henderson and David Turner",
month = jan,
pages = "1--28",
publisher = CUP,
year = 1981
}

@inproceedings{turn85,
author = "David A. Turner",
title = "Miranda --- a Non-Strict Functional Language with Polymorphic Types",
crossref = "FPCA85",
pages = "1--16",
}


@inproceedings{ueda90,
author = "K. Ueda and M. Morita",
title = "A New Implementation for Flat {GHC}",
crossref = "ICLP90",
pages = "3--17",
}



@incollection{unga83,
author = "David M. Ungar and David A. Patterson",
title = "Berkeley {S}malltalk: Who Knows Where the Time Goes?",
crossref = "Smalltalk-BHWA",
pages = "189--206",
}


@inproceedings{unga84,
title = "Generation Scavenging: A Non-Disruptive High Performance Storage 
Reclamation Algorithm",
author = "David  M. Ungar",
volume = "19(5)",
pages = "157--167",
month = Apr,
year = 1984,
comment = {One of the original papers (and suggested to be better to read than
Liebermann and Hewitt).
Uses only two generations.
Paging-out recently allocated data is expensive.
Doesn't pay to make heap area larger than the available main memory.
Avoids some of this problem.
Recursive freeing in reference counters: 5 percent Berkeley Smalltalk,
1.9 percent Dorado Smalltalk.  },
booktitle = "Proceedings of the {ACM/SIGSOFT/SIGPLAN} Software Engineering Symposium on 
Practical Software Development Environments"
}


@book{unga86,
title = "The Design and Evaluation of a High Performance {S}malltalk System",
author = "David M. Ungar",
publisher = MIT,
series = "{ACM} distinguished dissertation 1986",
year = 1986,
abstract = {This is a Ph.D. dissertation in book form. It is also the ACM Distinguished
Dissertation of 1986.
The research reported in this book is related to the design and performance
evaluation of a RISC (reduced instruction set computer) system designed to
run the Smalltalk-80 exploratory programming environment (EPE). EPE
provides a rapid program development cycle for programmers. Smalltalk
systems are object-oriented programming systems that provide program
abstraction and reduction in written code. Unfortunately, such systems so
far have been large, expensive (exceeding 80,000), and slow. The author
has taken Smalltalk-80 EPE and has tried to design a language-specific RISC
system that he calls SOAR (Smalltalk on a RISC). SOAR is a mix of VLSI
technology and intelligent software routines that gets a better performance
at a lower cost compared to existing systems. The author and his colleagues
have built VLSI implementations of SOAR and a Smalltalk interpreter and
have tested the design and performance of SOAR. The book presents all these
in amazing detail.
The book has seven chapters and a bibliography, followed by two appendices.
Chapter 5 describes a new garbage-collection method called ``generation
scavenging.'' The synopsis of past work is nicely done indeed. The new
algorithm and its code in pidgin C are described in detail. With appropriate
diagrams, the author explains how objects are created, saved, and removed from
the memory (memory-reclamation) and also compares the algorithm with some 
existing ones. The performance evaluation and advantages of the suggested 
algorithm are detailed in the text and tables. Some disadvantages are also
mentioned.
The above algorithm allocates a ``tenure'' status to objects surviving
garbage collection. What if such objects are not needed just after being
tenured? Moreover, at what point can an object be tenured? These issues are
the subject of chapter 6. This chapter describes the analysis and
evaluation of the issues mentioned. The experiments were done on Berkeley}
}


@article{unga88,
title = "Tenuring Policies for Generation-Based Storage Reclamation",
author = "David M. Ungar and Frank Jackson",
address = "Stanford Univ, Cis, Stanford, Ca, 94305 Parcpl Syst, Palo Alto, Ca, 
94303",
journal = SIGPLAN,
publisher = ACM,
year = 1988,
volume = 23,
number = 11,
pages = "1--17",
comment = "All 3 US commercial Smalltalks (DigiTalk, Tektronix and ParcPlace) use
generational GCs"
}

@inproceedings{unga91,
author = "David M. Ungar and Frank Jackson",
title = "Outwitting {GC} Devils: A Hybrid Incremental Garbage Collector",
crossref = "OOPSLA91-gc",
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/GC91/ungar.ps"
}

@article{unga92,
title = "An Adaptive Tenuring Policy for Generation Scavengers",
author = "David M. Ungar and Frank Jackson",
journal = TOPLAS,
publisher = ACM,
year = 1992,
volume = 14,
number = 1,
pages = "1--27",
comment = {The performance of generational scavenging schemes may be poor if many objects
are fairly long-lived. Performance may be improved by
(a) segregating large bitmaps and strings, and
(b) adapting the scavenger's tenuring policy according to demographic
feedback.
Copying collector but uses a separate large object area.
State-of-art Smalltalk uses less than 5 percent GC, better than 100ms pause-time.}
}

@inproceedings{ungu97,
title = {Formal Models of Distributed Memory Management},
author = {Christian Ungureanu and Benjamin Goldberg},
pages = {280--291},
crossref = {ICFP97},
URL = {http://www.acm.org/pubs/articles/proceedings/fp/258948/p280-ungureanu/p280-ungureanu.pdf}
}

@techreport{unni00,
title = {Automatic Accurate Stack Space and Heap Space Analysis for High-Level Languages},
author = {Leena Unnikrishnan and Scott D. Stoller and Yanhong A. Liu},
institution = {Indiana University},
number = 538,
month = apr,
year = 2000,
URL = {http://www.cs.sunysb.edu/~leena/papers/dar012.ps.gz},
abstract = {This paper describes a general approach for automatic and accurate space
and space-bound analyses for high-level languages, considering stack
space, heap allocation and live heap space usage of programs. The approach
is based on program analysis and transformations and is fully
automatic. The analyses produce accurate upper bounds in the presence of
partially known input structures. The analyses have been implemented, and
experimental results confirm the accuracy.}
}

@inproceedings{unni01,
title = {Automatic Accurate Live Memory Analysis for Garbage-Collected Languages},
author = {Leena Unnikrishnan and Scott D. Stoller and Yanhong A. Liu},
booktitle = {ACM SIGPLAN Workshop on Languages, Compilers, and Tools for Embedded Systems (LCTES)},
year = 2001,
URL = {http://www.cs.sunysb.edu/~leena/papers/LCTES2001.ps.gz},
abstract = {This paper describes a general approach for automatic and accurate live heap
space and live heap space-bound analyses for high-level languages.  The
approach is based on program analysis and transformations and is fully
automatic.  The space-bound analysis produces accurate (tight) upper bounds
in the presence of partially known input structures.  The analyses have been
implemented and experimental results confirm their accuracy.}
}

@techreport{unni01a,
author = {Leena Unnikrishnan and Scott D. Stoller and Yanhong A. Liu},
title = {Optimized Live Heap Bound Analysis},
institution = {SUNY at Stony Brook},
number = {DAR 01-2},
month = oct,
year = 2001,
URL = {http://www.cs.sunysb.edu/~leena/papers/dar012.ps.gz},
abstract = {This paper describes a general approach for optimized live heap space and
live heap space-bound analyses for garbage-collected languages.  The approach
is based on program analysis and transformations and is fully automatic.  The
space-bound analysis produces accurate (tight) upper bounds in the presence
of partially known input structures.  The optimization drastically improve
the analysis efficiency.  The analyses have been implemented and experimental
results confirm their accuracy and efficiency.}
}

@inproceedings{vand03,
title = {A Typed Interface for Garbage Collection},
author = {Joseph C. Vanderwaart and Karl Crary},
pages = {109--122},
crossref = {TLDI03}
}

@inproceedings{vard02,
title = {Using Passive Object Garbage Collection Algorithms},
author = {Abhay Vardhan and Gul AGha},
crossref = {ISMM02},
pages = {106--113}
}

@article{varh97,
title = {Adapting {J}ava for Embedded Systems},
author = {Peter Varhol},
journal = {Computer Design},
month = oct,
year = 1997,
pages = 75,
comment = {NewMonics Inc real-time Java}
}

@inproceedings{vata84,
title = "Finding Temporary Terms in {PROLOG} Programs.",
author = "P. Vataja and E. Ukkonen",
institution = "University of Helsinki, Helsinki, Finland",
booktitle = "Fifth Generation Computer Systems 1984, Proceedings of the 
International Conference. {T}okyo, 1984 {N}ov 6--9",
publisher = "Ohmsha Ltd",
address = "Tokyo",
pages = "275--282",
year = 1984,
isbn = "4--274--07221--5",
abstract = {We consider the memory management in backtrack-based Prolog
implementations where the Prolog terms are represented as linked data
structures that may have shared substructures.  An approach called direct
garbage collection is examined.  The goal is to develop methods for locating at
any moment of the Prolog program execution the terms which are not needed any
more and which do not share substructures with terms that are still needed.
Two methods for these temporary terms are proposed.  The dynamic method is
applied together with the program execution.  The static method is applied
before the program is actually executed, but the outputs can be utilized in
organizing garbage collection of every subsequent execution of the 
program, as long as the program does not change.}
}


@inproceedings{vaug90,
author = "Francis Vaughan and T. Schunke and B. Koch and A. Dearle and C. Marlin
 and C. Barter",
title = "A Persistent Distributed Architecture Supported by the Mach Operating
System",
booktitle = "First USENIX Conference on the Mach Operating System",
publisher = UA,
year = 1990,
pages = {123--140}
}


@inproceedings{vaug92,
author = "Francis Vaughan and Alan Dearle",
title = "Supporting Large Persistent Stores Using Conventional Hardware",
crossref = "IWPOS92",
}

@inproceedings{vaug00,
author = {Francis A. Vaughan and William F. Brodie-Tyrrell and  Katrina E. Falkner and David S. Munro},
title = {Bounded Parallel Garbage Collection:Implementation and Adaptation},
booktitle = {Proceedings of 7th Australian Parallel and Real Time PART'2000},
address = {Sydney},
year = 2000,
URL = {http://www.cs.adelaide.edu.au/users/jacaranda/publications.html},
comment = {Implementation of \cite{blel99}}
}

@inproceedings{vegd89,
author = "Steve Vegsal and Uwe F. Pleban",
title = "The Runtime Environment of {S}creme, a {S}cheme Implementation for 
the 88000",
crossref = "ASPLOS89",
pages = "172--182",
}


@article{veil76,
author = "G. Veillon",
title = "Transformations de Programmes Recursifs",
journal = "R.A.I.R.O. Informatique",
volume = 10,
number = 9,
month = sep,
year = 1976,
pages = "7--20",
comments = {transforms the classical recursive marking algorithm into
Deutsch-Schorr-Waite pointer reversal algorithm},
}


@mastersthesis{venk91,
author = "Nalini Venkatasubramanian",
title = "Hierarchical Garbage Collection in Scalable Distributed Systems",
school = "University of Illinois, Urbana-Champaign",
year = 1991,
}

@techreport{venk92,
author = "Venkatasubramanian, Nalini and Agha, Gul and Talcott, Carolyn",
title = "Hierarchical Garbage Collection in Scalable Distributed Systems",
institution = "Department of Computer Science, University of Illinois at Urbana-Champaign",
year = 1992,     
number = "UIUCDCS-R-92-1740",
month = Apr
}

@inproceedings{venk92a,
title = "Scalable Distributed Garbage Collection for Systems of Active Objects",
author = "Nalini Venkatasubramanian and Gul Agha and Carolyn Talcott",
address = "HP Comp., USA",
crossref = "IWMM92",
pages = "134--147"
}

@book{venn98,
title = {Inside the {J}ava {V}irtual {M}achine},
series = {The {J}ava Masters Series},
author = {Bill Venners},
publisher = {Computing McGraw-Hill},
ISBN = {0-07-913248-0},
month = feb,
year = 1998,
pages = 579,
note = {Chapter 9: Garbage Collection},
URL = {http://www.artima.com/insidejvm/ed2/gc.html}
}

@misc{venn98a,
author = {Bill Venners},
title = {Object Finalization and Cleanup},
month = jun,
year = 1998,
howpublished = {http://www.javaworld.com/javaworld/jw-06-1998/jw-06-techniques.html},
URL = {http://www.javaworld.com/javaworld/jw-06-1998/jw-06-techniques.html},
abstract = {This installment of the Design Techniques column discusses
the design guidelines that pertain to the end of an object's life. Columnist
Bill Venners gives an overview of the rules of garbage collection, discusses
finalizers, and suggests ways to design objects such that finite resources
aren't monopolized. [all Java related] }
}

@phdthesis{vest87,
title = "Garbage Collection:  An Exercise in Distributed, Fault-Tolerant 
Programming",
author = "Stephen C. Vestal",
school = "University of Washington, Seattle, WA",
year = "1987",
comment = "Looks very similar to Jones  Lins Cyclic Weighted Reference Counting"
}

@inproceedings{vija01,
title = {Energy Behavior of {J}ava Applications from the Memory Perspective},
author = {N. Vijaykrishnan and M. Kandemir and S. Kim and S. Tomar and A. Sivasubramaniam and M. J. Irwin},
crossref= {JVM01},
URL = {http://www.usenix.org/events/jvm01/vijaykrishnan.html}
}

@inproceedings{vird95,
title = "A Garbage Collector for the Concurrent Real-Time Language {E}rlang",
author = "Robert Virding",
address = "Computer Science Laboratory, Ellemtel Telecommunications Systems Labo
ratories, Alvsjo, Sweden",
crossref = "IWMM95",
}

@article{vo95,
author = "Kiem-Phong Vo",
title = "Vmalloc: A General and Efficient Memory Allocator",
journal = SPE,
publisher = Wiley,
year = 1996,
volume = 26,
number = 3,
pages = {357--374},
URL = {URL:http://www.research.att.com/sw/tools/vmalloc/}
}

@article{vold83,
author = "J. Voldman and B. Mandelbrot and L. W. Hoevel and J. Knight and
P. Rosenfeld",
title = "Fractal Nature of Software-Cache Interaction",
journal = "IBM Journal of Research and Development",
volume = 27,
number = 2,
month = mar,
year = 1983,
pages = "164--170"
}


@article{wadl76,
author = "Philip L. Wadler",
title = "Analysis of an Algorithm for Real-Time Garbage Collection",
journal = CACM, 
publisher = ACM,
volume = 19,
number = 9,
month = Sep,
year = 1976, 
pages = "491--500",
comments = {Presents analytical analysis of on-the-fly garbage collection algorithm
in \cite{dijk76b}.}
}


@inproceedings{wadl84,
title = "Listlessness is Better than Laziness: Lazy Evaluation and Garbage 
Collection at Compile Time",
author = "Philip L. Wadler",
pages = "45--52",
crossref = "LFP84",
}


@article{wadl87,
author = "Philip L. Wadler",
title = "Fixing Some Space Leaks with a Garbage Collector",
journal = SPE,
publisher = Wiley,
volume = 17,
number = 9,
pages = "595--609",
month = sep,
year = "1987",
URL = "ftp://ftp.dcs.gla.ac.uk/pub/glasgow-fp/authors/Philip_Wadler/leak.dvi",
abstract = "Some functional programs may use more space than would be expected.
A modification to the garbage collector is suggested which solves this problem 
in some cases. Related work is discussed.",
}

@book{wait73,
author = "W. M. Waite",
title = "Implementing Software for Nonnumeric Applications",
publisher = PH,
year = 1973,
comments = {algorithm for compacting varisized cells},
}

@phdthesis{wake90,
author = "David Wakeling",
title = "Linearity and Laziness",
school = "University of York",
month = nov,
year = 1990,
comment = "Uses Wadler's linear logic to optimise heap usage.
Disappointing results."
}

@inproceedings{wake91,
author = "David Wakeling and Colin Runciman",
title = "Linearity and Laziness",
crossref = "FPCA91",
pages = "215--240",
}

@article{wald72,
author = "O. C. Walden",
title = "A Note on {C}heney's Non-Recursive List-Compacting Algorithm",
journal = CACM, 
publisher = ACM,
volume = 15,
number = 4,
month = apr,
year = 1972,
page = 275,  
comments = {Optimization to the copying algorithm (feni69) based on (chen70)},
}

@book{wall91,
author = "Larry Wall and Randal L. Schwartz",
title = "Programming Perl",
publisher = "O'Reilly and Associates, Inc.",
year = 1991
}

@inproceedings{wall93,
title = "An Incremental Garbage Collector for Embedded Real-Time Systems",
author = "Malcolm Wallace and Colin Runciman",
booktitle = "Proceedings of the Chalmers Winter Meeting",
address = "Tanum Strand, Sweden",
year = 1993,
pages = "273--288",
note = "Published as Programming Methodology Group, Chalmers University of Technology, Technical Report 73",
URL = "ftp://ftp.cs.york.ac.uk/pub/malcolm/rtgc.html",
comment = "Based on Yuasa and also Quenniac's Mark-during-sweep"
}

@techreport{wang99,
title = {Safe Garbage Collection = Regions + Intensional Type Analysis},
author = {Daniel C. Wang and Andrew W. Appel},
institution = {Princeton},
month = jul,
year = 1999,
URL = {http://ncstrl.cs.Princeton.EDU/expand.php?id=TR-609-99},
abstract = {We present a technique to implement type-safe garbage collectors by combining existing type systems used for compiling type-safe languages. We adapt
the type systems used in region inference (Tofte, Talpin 1994) and intensional type analysis (Harper, Morrisett 1995) to construct a safe stop-and-copy
garbage collector for higher-order polymorphic languages. Rather than using region inference as the primary method of storage management, we show
how it can be used to implement a garbage collector which is provably safe. We also introduce a new region calculus with non-nested object life-times
which is significantly simpler than previous calculi. Our approach also formalizes more of the interface between garbage collectors and code generators.
The efficiency of our safe collectors are algorithmically competitive with unsafe collectors. }
}

@techreport{wang00,
title = {Type-Preserving Garbage Collectors (Extended Version)},
author = {Daniel C. Wang and Andrew W. Appel},
institution = princeton,
month = dec,
year = 2000,
URL = {http://ncstrl.cs.Princeton.EDU/expand.php?id=TR-624-00}
}

@inproceedings{wang01,
title = {Type-Preserving Garbage Collectors},
author = {Daniel C. Wang and Andrew W. Appel},
crossref = {PLDI01},
URL = {http://www.cs.princeton.edu/faculty/appel/papers/typegc.pdf}
}

@mastersthesis{wang89,
author = "Thomas Wang",
title = "The {MM} Garbage Collector for {C++}",
school = "California State Polytechnic University",
year = 1989,
month = oct
}

@article{wang94a,
author = "Thomas Wang",
address = "wang@cup.hp.com, Hewlett-Packard, Cupertino, ca.",
title = "Better {C}: An Object-Oriented {C} Language with Automatic Memory Manager Suitable for Interactive Applications",
journal = SIGPLAN,
publisher = ACM,
volume = 29,
number = 11,
month = dec,
pages = "104--111",
year = 1994
}

@article{wang94b,
author = "Thomas Wang",
address = "wang@cup.hp.com, Hewlett-Packard, Cupertino, ca.",
title = "Eliminate Memory Fragmentation through Holes in the Heap",
journal = SIGPLAN,
publisher = ACM,
volume = 29,
number = 11,
month = dec,
pages = "112--113",
year = 1994,
comment = "Use a lightweight version of AIX's disclaim to indicate that a 
copying collector is no longer interested in Fromspace pages. Lightweight
means unmap the page but do not clear it."
}

@article{wang95,
author = {Y. Wang and P. Chung and I. Lin and W.K.Fuchs},
title = {Checkpoint Space Reclamation for Uncoordinated Checkpointing in Message-Passing Systems},
journal = {IEEE Transactions on Parallel and Distributed Systems},
volume = 6,
number = 5,
month = may, 
year = 1995,
pages = {546--554}
}

@techreport{warr77,
author = "David H. D. Warren",
title = "Implementing {P}rolog --- Compiling Logic Programs",
volume = "1 and 2",
type = "D.A.I. Research Report",
number = "39, 40",
institution = "University of Edinburgh",
year = 1977,
comment = "Edinburgh Prolog divides memory into local stack (control part) and 
global stack (data part).
Uses a mark and compact collector.",
}


@inproceedings{warr80,
author = "David H. D. Warren",
title = "An Improved {P}rolog Implementation which Optimises Tail-Recursion",
booktitle = "Workshop on Logic Programming, Debrecen, Hungary",
year = 1980,
comment = "Structure copying:simplifies gc algorithms (bruy82)." ,
}


@article{warr82,
author = "David H. D. Warren",
title = "Perpetual Processes --- an Unexploited {P}rolog Technique",
journal = "Logic Programming Newsletter",
volume = 3,
year = 1982,
comment = "Infinite loops which do not consume space.",
}


@techreport{warr83,
author = "David H. D. Warren",
title = "An Abstract {P}rolog Instruction Set",
type = "Technical Note",
number = 309,
institution = "SRI International",
year = 1983,
comment = "The WAM.",
}



@inproceedings{warr84,
author = "David A. Warren",
title = "Efficient {P}rolog Memory Management for Flexible Control Strategies",
booktitle = "International Symposium on Logic Programming",
year = 1984,
publisher = IEEE,
}

%check year
@mastersthesis{wash89,
author = "Washabaugh, Douglas Markham",
title = "Real-Time Garbage Collection of Actors in a Distributed System",
year = 1989,
school = "Virginia Polytechnic Institute and State University"
}

@inproceedings{wash90,
author = "Washabaugh, Douglas Markham and Dennis Kafura",
title = "Real-Time Garbage Collection of Actors",
booktitle = "Proceedings of the 11th Real-Time Systems Symposium",
pages = "21--30",
month = dec,
year = 1990,
}

@inproceedings{wash91,
author = "Douglas M. Washabaugh and D. Kafura",
title = "Distributed Garbage Collection of Active Objects",
booktitle = "icdcs11",
pages = "369--276",
month = may,
year = 1991,
}



@article{wats76,
title = {Tuning {G}arwick's algorithm for repacking sequential storage},
author = {Watson and David Wise},
journal = {BIT},
month = dec,
year = 1976,
volume = 16,
number = 4,
pages = {442--450}
}

@techreport{wats86,
author = "Ian Watson",
title = "An Analysis of Garbage Collection for Distributed Systems",
institution = "Department of Computer Science, University of  Manchester",
year = 1986
}



@inproceedings{wats87,
author = "Paul Watson and Ian Watson",
title = "An Efficient Garbage Collection Scheme for Parallel Computer Architectures",
crossref = "PARLE87",
pages = "432--443"
}


@inproceedings{wats87a,
author = "Paul Watson and Ian Watson",
title = "Graph Reduction in a Parallel Virtual Memory Environment",
booktitle = "Graph Reduction: Proceedings of a Workshop at {S}anta {F}e, {N}ew {M}exico",
publisher = SV,
series = LNCS,
volume = 279,
editor = "J. H. Fasel and R. M. Keller",
year = "1987",
pages = "265--274",
abstract = "This paper examines the area of memory organization and the 
mechanism
which are required to ensure thet the full benefits of this implementation
strategy are maintained whilst achieving an efficient physical structure. 
The major areas of interest are the maintenance of locality and the use of
storage management techniques which minimize communication."}


@inproceedings{weem90,
author = "P. Weemeeuw and B. Demoen",
title = {A la Recherche de la M\'{e}moire Perdue, or: Memory Compaction for 
Shared Memory Multiprocessors --- Design and Specification},
booktitle = "2nd North American Conference on Logic Programming",
editor = "S. Debray and M. Hermenegildo",
pages = "306--320",
year = 1990,
}



@inproceedings{weem92,
title = "Garbage Collection in {A}urora: An Overview",
author = "P. Weemeeuw",
address = "K. U. Leuven, Belgium",
crossref = "IWMM92",
}


@article{wegb72a,
author = "B. Wegbreit",
title = "A Generalised Compactifying Garbage Collector",
journal = CompJ,
publisher = BCS,
volume = 15,
number = 3,
month = Aug, 
year = 1972,
pages = "204--208",
comments = {algorithm for compacting varisized cells with no break table.
Divides the memory into a fixed number of equal segments},
}


@article{wegb72b,
author = "B. Wegbreit",
title = "A Space Efficient List Structure  Tracing  Algorithm",
journal = IEEETransComp,
publisher = IEEE,
month = sep,
year = 1972,
pages = "1098--1010",
comments = {presents a modification of Deutsch-Schorr-Waite algorithm which
uses a bit stack instead of a bit per cell},
}

@manual{wein81,
author = {Daniel Weinreb and David Moon},
title = {{LISP} Machine Manual},
edition = {Fourth edition},
organization = MITAI,
month = jul,
year = 1981
}

@phdthesis{wein76,
author = "Charles B. Weinstock",
title = "Dynamic Storage Allocation Techniques",
school = "Carnegie-Mellon University",
address = "Pittsburgh, Pennsylvania",
month = apr,
year = 1976
}

@article{wein88,
author = "Charles B. Weinstock and William A. Wulf",
title = "Quickfit: An Efficient Algorithm for Heap Storage Allocation",
journal = SIGPLAN,
volume = 23,
number = 10,
pages = "141--144",
year = 1988
}


@inproceedings{weis89,
title = "The {P}ortable {C}ommon {R}untime Approach to Interoperability",
author = "Mark Weiser and Alan Demers and Carl Hauser",
booktitle = "Twelfth {ACM} Symposium on Operating Systems Principles",
publisher = ACM,
month = Dec,
year = 1989
}

@book{weis67,
author = "C. Weissman",
title = "{L}isp 1.5 Primer",
publisher = "Dickenson Publ.",
address = "Belmont, CA", 
year = 1967,  
}


@article{weiz62,
author = "J. Weizenbaum",
title = "Knotted List Structures",
journal = CACM, 
publisher = ACM,
volume = 5,
number = 3,
year = 1962,
pages = "161--165",
comments = "Pointed by Steele (stee75) as one of the first uses of reference counting",
}


@article{weiz63,
author = "J. Weizenbaum",
title = "Symmetric List Processor",
journal = CACM, 
publisher = ACM,
volume = 6,
number = 9,
month = sep,
year = 1963,
pages = "524--544",
comment = "A smoother reference counting method. 
Pointers are deleted lazily."
}

@article{weiz64,
author = "J. Weizenbaum",
title = "More on the Reference Counter Method",
journal = CACM,
publisher = ACM,
volume = 7,
number = 1,
pages = 38,
year = 1964
}


@article{weiz69,
author = "J. Weizenbaum",
title = "Recovery of Reentrant List Structures in {SLIP}",
journal = CACM, 
publisher = ACM,
volume = 12,
number = 7,
month = jul,
year = 1969,
pages = "370--372",
comment = "Suggested combining reference counting with mark-scan."
}


@techreport{weng79,
author = "K.-S. Weng",
title = "An Abstract Implementation for a Generalised Dataflow Language",
institution = MITLCS,
number = "MIT/LCS/TR228",
year = 1979
}

@phdthesis{went88,
author = "E. P. Wentworth",
title = "An Environment for Investigating Functional Languages and
Implementations",
school = "University of Port Elizabeth, South Africa",
year = 1988
}

@article{went90,
title = "Pitfalls of Conservative Garbage Collection",
author = "E. P. Wentworth",
journal = SPE,
publisher = Wiley,
volume = 20,
number = 7,
pages = "719--727",
year = 1990,
abstract = {Researchers have recently proposed conservative garbage collection
as a technique which allows smooth integration of automatic memory management
into existing high-level languages.  Conservative techniques carry the cost of
some leakage --- they fail to reclaim all the available garbage.  This paper
reports on a conservative collector and measurements of its leakage.  The
results indicate that the loss depends critically on the application = "a Lisp
interpreter shows very small leakage (typically less than 5 per cent of the
total heap space for classroom examples), whereas the garbage collector
collapses completely when used with a KRC interpreter.  Uncovering the reasons
reveals that it is possible to write Lisp programs that also fail.  Previous
work has used very sparsely populated address spaces where the probability for
leakage was minimized.  This work considers small, densely populated address
spaces, and probably represents a worst-case scenario.  Although the
conservative technique appears to be a cost-effective and clean way of
integrating automatic memory management into an off-the-shelf host 
language, we are led to conclude that it is not reliable in all situations.}
}

@inproceedings{whal99,
title = {Compositional Pointer and Escape Analysis for {J}ava Programs},
author = {John Whaley and Martin Rinard},
pages = {187--206},
URL = {http://citeseer.nj.nec.com/whaley99compositional.html},
crossref = {OOPSLA99},
note = {By analysing which objects escape methods/threads, we can allocate on
the stack / avoid synchronisations.}
}

@inproceedings{whil92,
title = "Incremental Garbage Collection for the {S}pineless {T}agless {G}-Machine",
author = "R. Lyndon While and Tony Field",
booktitle = "Proceedings of the Massey Functional Programming Workshop 1992",
editor = "Evan Ireland and Nigel Perry",
publisher = "Department of Computer Science, Massey University",
year = 1992
}

@techreport{whil92a,
author = "R. Lyndon While",
title = "A Viable Software Read-Barrier",
institution = "Imperial College, London",
type = "Departmental Report",
number = "DoC 92/12",
year = 1992
}

@techreport{whit98,
title = {The {GC} interface in the {EVM}},
author = {Derek White and Alex Garthwaite},
institution = {Sun Microsystems Laboratories},
number = {SML TR--98--67},
month = dec,
year = 1998,
URL = {http://www.sunlabs.com/research/java-topics/pubs/98-gc-interface.ps}
}

@inproceedings{whit80,
author = "Jon L. White",
title = "Address/Memory Management for a Gigantic {L}isp Environment,
or, {GC} {C}onsidered {H}armful",
booktitle = "Conference Record of the 1980 {L}isp Conference",
address = "Redwood Estates, CA",
pages = "119--127",
month = aug,
year = 1980
}

@inproceedings{whit90,
author = "Jon L. White",
title = "Three Issues in Objected-Oriented Garbage Collection",
crossref = "OOPSLA90-gc",
}

@article{whit97,
title = {Deferred Garbage Collection},
author = {Marc White},
journal = {MacTech magazine},
volume = 13,
number = 12,
year = 1997,
URL = {http://www.mactech.com/articles/mactech/Vol.13/13.12/DeferredGarbageCollection/}
}

@inproceedings{whit92,
author = "Seth J. White and David J. Dewitt",
title = "A Performance Study of Alternative Object Faulting and Pointer Swizzlin
g Strategies",
booktitle = "18th International Conference on Very Large Data Bases",
year = 1992,
month = oct,
address = "Vancouver, British Columbia, Canada",
}

@inproceedings{whit94,
author = "Seth J. White and David J. Dewitt",
title = "QuickStore: A High Performance Mapped Object Store",
booktitle = "SIGMOD94",
pages = "395--406",
year = 1994
}

@inproceedings{whol84,
author = "Skef Wholey and Scott E. Fahlman",
title = "The Design of an Instruction set for {C}ommon {L}isp",
crossref = "LFP84",
pages = "150--158",
}

@techreport{whol85,
author = "Skef Wholey and Scott E. Fahlman and Joseph Ginder",
title = "Revised Internal Design of {S}pice {L}isp",
institution = CMU,
month = jan,
year = 1985
}



@inproceedings{wild91,
author = "J. Wild and Hugh Glaser and Pieter Hartel",
title = "Statistics on Storage Management in a Lazy Functional Language 
Implementation",
booktitle = "Proceedings of Third Workshop on Parallel and Distributed 
Processing",
address = "Sofia",
editor = "Sendov",
URL = "http://www-ala.doc.ic.ac.uk/papers/A.Bennett/fast_works/1.4.bulg91.ps.gz",
year = 1991,
publisher = ENH,
month = apr,
note = "Also appears in
Proceedings of 4th International Workshop on Parallel Implementation of Functional Languages, Aachen, September 1992,
ed. H. Kuchen and R. Loogen,
Aachener Informatik-Berichte 92--16"
}


@article{wile89,   
title = "Pgraphite:  An Experiment in Persistent Typed Object Management",
author = "J. C. Wileden and A. L. Wolf and C. D. Fisher and P. L. Tarr",
pages = "130--142",
journal = SIGPLAN,
month = feb,
year = 1989,
volume = 24,
number = 2,
issn = "0362--1340",
abstract = {The paper describes PGRAPHITE, a prototype tool in an Arcadia environment
for managing persistent typed objects. A typed object is a datum whose type,
in the sense of Ada's strong type system, is known to all programs that
use it. The way the program accesses the object is determined by its
internal structure as specified by its type. A persistent object is a datum
which exists longer than any activation of any program that may access it;
the datum is usually stored on a disk medium. The usual program data that
are allocated and deallocated during one activation of the program are
nonpersistent.
It is desirable that persistence of an object be orthogonal to all other
aspects of the object. That is, the code which uses an object based on its
type structure should be the same for persistent and nonpersistent objects.
The paper correctly observes that for persistence to be truly orthogonal in
this sense, it is essential that an object be deallocated only after it has
ceased to be accessible to all potential users. Therefore implicit
persistence, called retention elsewhere, is followed. The paper also
observes that such implicit persistence is expensive in general because it
can require garbage collection. Thus, most systems abandon implicit
persistence in favor of program-ordered deallocation, which can cause
references that are still available to point to nothing. By deciding on a
particular set of object and persistent store manipulation operations,
however, it should be possible to limit the complexity of determining when
an object is inaccessible and thus deallocatable. PGRAPHITE implements
these operations.
Rather than get bogged down in the already well-understood details of
implementing a complete typing system, the authors decided to build the
tool as an extension of the existing system GRAPHITE, which handles
nonpersistent graph objects, that is, data whose types are arcs, nodes,
collections of nodes, etc. The object and persistent store manipulation
operations mentioned in the previous paragraph are added to GRAPHITE to get
PGRAPHITE. The rapidly developed prototype tool has allowed experimentation
and exploration of alternative models and implementations of persistence.
I found the paper clear, lively, and informative. It showed me a new way to
view my old work on retention and got me all excited. A proof of the
liveliness of the paper and my excitement is the abundance of argumentative
comments that the paper provoked me to write in the margin of my copy. 
The paper was fun to read.}
}

@article{wilk64,
author = "Maurice V. Wilkes",
title = "An Experiment with a Self-Compiling Compiler for a Simple
List-Processing Language",
journal = "Annual Review in Automatic Programming",
volume = 4,
publisher = "Pergamon Press",
pages = "1--48",
year = 1964,
comment = "WISP --- the language that Schorr-Waite used"
}

@inproceedings{wilk64a,
author = "Maurice V. Wilkes",
title = "Lists and Why They Are Useful",
booktitle = "Proceedings of the ACM 19th National Conference",
publisher = ACM,
month = aug,
year = 1964,
comment = "WISP --- the language that Schorr-Waite used"
}

@article{will00,
title = {Autonomous Garbage Collection: Resolving Memory Leaks in Long-Running
Server Applications},
author = {B. Willard and O. Frieder},
pages = {887--900},
journal = {Computer Communications},
volume = 23,
number = 10,
month = may,
year = 2000
}

@inproceedings{will87,
title = "Dynamic Grouping in an Object-Oriented Virtual Memory Hierarchy",
author = "Ifor W. Williams and Mario I. Wolczko and Trevor P. Hopkins",
institution = "University of  Manchester, Department of Computer Science, Manchester, UK",
crossref = "ECOOP87",
pages = "79--88"
}


@inproceedings{will87a,
author = "Ifor W. Williams and Mario I. Wolczko and T. P. Hopkins",
title = "Realisation of a Dynamic Grouped Object-Oriented Virtual Memory
Hierarchy",
pages = "298--308",
crossref = "IWPOS87",
note = "Persistent Programming Research Report, Universities of
Glasgow and St Andrews, number PPRR--44--87"
}

@techreport{will90,
author = "Williams, Ifor and Mario I. Wolczko and Trevor Hopkins",
title = "Realization of a Dynamically Grouped Object-Oriented Memory Hierarchy",
type = "Technical Report",
institution = "University of Manchester Department of Computer Science",
address = "Manchester",
year = 1990
}


@inproceedings{will91,
author = "Ifor W. Williams and Mario I. Wolczko",
title = "An Object-Based Memory Architecture",
pages = "114--130",
crossref = "IWPOS90"
}

@article{wils88,
title = "Opportunistic Garbage Collection",
author = "Paul R. Wilson",
pages = "98--102",
journal = SIGPLAN,
month = dec,
year = 1988,
volume = 23,
number = 12
}


@mastersthesis{wils88b,
author = "Paul R. Wilson",
title = "Two Comprehensive Virtual Copy Mechanisms",
school = "University of Illinois at Chicago, Electrical Engineering and Computer
Science Department",
address = "Chicago, Illinois",
year = 1988 
}


@article{wils89,
title = "A Card-Marking Scheme for Controlling Intergenerational 
References in Generation-Based Garbage Collection on Stock Hardware",
author = "Paul R. Wilson and Thomas G. Moher",
address = "University of Illinois, Dept Elect Engn  Comp Sci, Chicago",
journal = SIGPLAN,
year = 1989,
volume = 24,
number = 5,
pages = "87--92",
abstract = {Like D. Moon's Ephemeral Garbage Collector ours does not actually
record which individual locations hold intergenerational pointers.
Ours uses a software analogue to pages, called cards.
Since individual locations are not remembered, whole cards must be scanned
at scavenge time to find pointers into younger generations.
This lowered-resolution recording has two benefits, the
space required for recording is greatly reduced, and the base cost of 
examining this information (at scavenge time) is similarly decreased.
To minimize the continual run-time overhead,
we record only whether a location is modified.
These benefits may be significant in large heaps, especially if locality is
poor or the page size is large.}
}


@article{wils89a,
title = "A Simple Bucket-Brigade Advancement Mechanism for Generation-Based Garbage Collection",
author = "Paul R. Wilson",
pages = "38--46",
journal = SIGPLAN,
month = may,
year = 1989,
volume = 24,
number = 5
}


@inproceedings{wils89b, 
title = "Design of the Opportunistic Garbage Collector",
author = "Paul R. Wilson and Thomas G. Moher",
crossref = "OOPSLA89",
pages = "23--35",
comment = "Avoids some of the locality problems of simpler copying GCs."
}


@inproceedings{wils90,
author = "Paul R. Wilson",
title = "Some Issues and Strategies in Heap Management and Memory Hierarchies",
crossref = "OOPSLA90-gc",
note = "Also in SIGPLAN Notices 23(1):45--52, January 1991",
}


@techreport{wils90a,
title = "Pointer Swizzling at Page Fault Time: Efficiently Supporting Huge Address Spaces on Standard Hardware",
author = "Paul R. Wilson",
number = "UIC--EECS--90--6",
institution = "University of Illinois at Chicago, Electrical Engineering and Computer Science Department",
address = "Chicago, Illinois",
month = Dec,
year = 1990,
note = "Also in Computer Architecture News, 19(4):6--13, June 1991"
}


@techreport{wils90b,
title = "Caching Consideration for Generational Garbage Collection: A
Case Study of Large and Set-Associative Caches",
author = "Paul R. Wilson and Michael S. Lam and Thomas G. Moher",
institution = "University of Illinois at Chicago EECS Department",
number = "UIC--EECS--90--5",
address = "Chicago, Illinois",
month = Dec,
year = 1990,
note = "Improved version appears in \cite{LFP92}",
comment = "Careful attention improves locality.
More recently, Eliot Moss and his students at UMass (currently visiting
at CMU) have done some experiments with Standard ML of NJ that suggest that
the miss penalties may be lower than expected from the sheer number of
misses, at least on the architecture they experimented with;  this
may be sensitive to details of the cache design.  (See also Koopman
and Lee's paper, cited in this paper.)"
}


@article{wils91,
title = "Effective Static-Graph Reorganization to Improve Locality in
Garbage Collected Systems",
author = "Paul R. Wilson and Michael S. Lam and Thomas G. Moher",
address = "University of Illinois, Dept Elect Engn  Comp Sci, Chicago",
journal = Sigplan,
publisher = ACM,
year = 1991,
volume = 26,
number = 6,
pages = "177--191",
comment = "As it doesn't pay to make heap larger than main memory,
equally locality within cache memory is important."
}


@inproceedings{wils91a,
author = "Wilson, Paul R. and Barry Hayes",
title = "Report on the 1991 Workshop on Garbage Collection in Object-Oriented Systems",
note = "Addendum. Also distributed as a special issue of ACM SIGPLAN Notices, and OOPS Messenger 3(4), October 1992.",
crossref = "OOPSLA91",
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/GCreport91.ps",
}


@inproceedings{wils91b,
author = "Paul R. Wilson",
title = "Operating System Support for Small Objects",
crossref = "IWOOOS92",
}


@phdthesis{wils91c,
author = "Paul R. Wilson",
title = "Heap Management and Memory Hierarchies",
school = "University of Illinois at Chicago",
month = Dec,
year = 1991  
}



@inproceedings{wils92,
author = "Paul R. Wilson and Michael S. Lam and Thomas G. Moher",
title = "Caching Considerations for Generational Garbage Collection",
crossref = "LFP92",
pages = "32--42",
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/cache.ps",
comment = "Generational techniques can recapture some of the locality
characteristics of reference counting.",
comment = "Garbage collection is not the problem; heap allocation is. 
Heap allocation (particularly in functional languages) does not
meet the assumptions upon which the memory heirarchy is based.
Analysis on some real programs shows that 2 or 4 way set associative
caches are better than direct mapped caches, and that relatively small
tuning factors can change cache misses fairly significantly.
Cyclic memory reuse patterns can fare poorly in hierarchical memories because
of LRU replacement policies."
}
 

@inproceedings{wils92a,
title = "Pointer Swizzling at Page Fault Time: Efficiently and Compatibly
Supporting Huge Addresses on Standard Hardware",
author = "Paul R. Wilson and Sheetal V. Kakkad",
crossref = "IWOOOS92",
pages = {364--377},
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/swizz.ps",
}


@article{wils92b,
author = "Wilson, Paul R. and Shubhendu S. Mukherjee and Sheetal V. Kakkad",
title = "Anomalies and Adaptation in the Analysis and Development of Prepaging P
olicies",
journal = "Journal of Systems and Software",
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/prefetchsim.ps",
year = 1992
}


@inproceedings{wils92c,
title = "Uniprocessor Garbage Collection Techniques",
author = "Paul R. Wilson",
booktitle = "Proceedings of the International Workshop on Memory Management",
address = "St Malo, France",
publisher = SV,
series = LNCS,
volume = 637,
month = "16--18~" # sep,
year = 1992,
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/gcsurvey.ps",
}


@inproceedings{wils92d,
title = "Garbage Collection and Memory Hierarchy",
author = "Paul R. Wilson",
address = "University of Texas, USA",
crossref = "IWMM92",
}

@unpublished{wils92e,
title = "Efficient Tracing Using Virtual Memory Address Protection",
author = "Paul R. Wilson and Atif Chaudrhy",
note = "In preparation",
year = 1992
}

@inproceedings{wils93,
author = "Paul R. Wilson and Mark S. Johnstone",
title = "Truly Real-Time Non-Copying Garbage Collection",
crossref = "OOPSLA93-gc",
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/GC93/wilson.ps"
}


@unpublished{wils93a,
author = "Paul R. Wilson and Mark Johnstone",
title = "Truly Real-Time Non-Moving Implicit-Reclamation Garbage Collection",
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/rtgc",
year = 1993,
month = mar,
note = "Rough Draft"
}


@techreport{wils94,
title = "Uniprocessor Garbage Collection Techniques",
author = "Paul R. Wilson",
institution = "University of Texas",
month = jan,
year = 1994,
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/bigsurv.ps",
note = "Expanded version of the IWMM92 paper"
}

@article{wils94a,
author = "Wilson, Paul R. and Shubhendu S. Mukherjee and Sheetal V. Kakkad",
title = "Anomalies and Adaptation in the Analysis and Development of Prepaging P
olicies",
journal = "Journal of Systems and Software",
note = "Technical Communication",
year = 1994
}

@inproceedings{wils95,
title = "Dynamic Storage Allocation: A Survey and Critical Review",
author = "Paul R. Wilson and Mark S. Johnstone and Michael Neely and David Boles",
booktitle = "Proceedings of the International Workshop on Memory Management",
address = "Kinross, Scotland",
publisher = SV,
series = LNCS,
volume = 986,
month = sep,
year = 1995,
pages =        "1--116",
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/allocsrv.ps",
}

@techreport{wils95a,
title = "Memory Allocation Policies Reconsidered",
author = "Paul R. Wilson and Mark S. Johnstone and Michael Neely and David Boles
",
institution = "University of Texas at Austin Department of Computer Sciences",
year = 1995
}

@inproceedings{wins89,
author = "William Winsborough",
title = "Path-Dependent Reachability Analysis for Multiple Specialization",
booktitle = "North American Conference on Logic Programming",
editor = "E. Lusk and R. Overbeek",
pages = "113--153",
publisher = MIT,
year = 1989
}

@article{wise76,
title = {Tuning {G}arwick's algorithm for repacking sequential storage},
author = {David S. Wise and Daniel C. Watson},
journal = {BIT},
volume = 16,
number = 4,
year = 1976,
month = dec,
pages = {442--450}
}

@article{wise77,
author = "David S. Wise and Daniel P. Friedman",
title = "The One-Bit Reference Count",
journal = "BIT",
volume = 17,
number = 3,
pages = "351--9",
year = "1977",
abstract= {Deutsch and Bobrow propose a storage reclamation scheme
for a heap which is a hybrid of garbage collection and reference
counting.  The point of the hybrid scheme is to keep track of very low
reference counts between necessary invocation of garbage collection so
that nodes which are allocated and rather quickly abandoned can be
returned to available space, delaying necessity for garbage
collection.  We show how such a scheme may be implemented using the
mark bit already required in every node by the garbage collector.
Between garbage collections that bit is used to distinguish nodes with
a reference count known to be one.  A significant feature of our
scheme is a small cache of references to nodes whose implemented
counts ``ought to be higher'' which prevents the loss of logical count
information in simple manipulations of uniquely referenced structures.},
comments = {Uses only one bit for reference counting and relies on
mark-scan to recycle cell with multiple references and cycles}
}

@techreport{wise78,
title = "The Double Buddy-System",
author = "David S. Wise",
number = 79,
institution = "Computer Science Department, Indiana University",
address = "Bloomington, Indiana",
month = dec,
year = 1978
}


@article{wise79,
author = "David S. Wise",
title = "Morris' Garbage Compaction Algorithm Restores Reference Counts",
journal = TOPLAS,
publisher = ACM,
volume = 1,
numnber = 1,
month = jul,
year = 1979,
pages = "115--120",
URL = {http://doi.acm.org/10.1145/357062.357070}
}


@inproceedings{wise85, 
author = "David S. Wise",
title = "Design for a Multiprocessing Heap with On-board Reference 
Counting",
crossref = "FPCA85",
pages = "289--304",
abstract = {In this short paper, the author describes an architecture for a memory
system that implements cell reference counting in a way that would be
useful for LISP-like languages. He argues that reference counting has a
useful place in heap management along with garbage collection because
reference counting can be done in a decentralized way, while garbage
collection is centralized. In a multiprocessor system, reference-counted
memory could increase the time between garbage collections and thus
decrease the fraction of the time when processors have to wait for a
centralized garbage collector to run.
The author's system implements LISP CONS cells. Each cell consists roughly
of a pair of 32-bit pointers and, for each pointer, an 11-bit reference
count and some status bits. Each time a pointer is written, it increments
the count in the newly pointed-to cell and decrements the count in the
formerly pointed-to cell, using a ``back door'' that does not require the
processor to wait. Free space is just a list of cells with zero reference
counts. Since the reference-count field is of finite size, counts can
occasionally overflow; at this point, a cell's count is marked infinite and
it will not be reclaimed until the next garbage collection.
The author refines this scheme with some ``sting'' bits, which let each
cell act as a test and set interlock, and a ``don't count'' bit, which lets
circular lists be counted and reclaimed in the common case where the cell
that closes the cycle is known when the cycle is created. The memory can
also run in a garbage collection mode in which the same hardware that fixed
up the reference counts turns out to be useful in implementing the standard
pointer reversing garbage collection scheme. Finally, the author describes
his efforts at hardware chip implementation, which he admits haven't 
gotten very far yet.
This approach seems plausible, and it is indeed likely that most of the
lists created by a LISP program are amenable to reclamation by this 
scheme.
Nonetheless, I cannot help but wonder whether one would do better to use
more conventional hardware and better software. His proposed chips store
about 64K bits apiece; garbage collection is delayed by a factor of 4
compared to that for a memory made of regular 64K chips. I could do the
same by using regular 256K chips and quadrupling the size of the memory.
Reports of real or simulated performance of Wise's system would make his
case much more persuasive.}
}

@techreport{wise93,
author = "Wise, David S. ",
title = "Stop-and-copy and One-Bit Reference Counting.",
institution = "Indiana University, Computer Science Department",
number = 360,
URL = "ftp://ftp.cs.indiana.edu/pub/techreports/TR360.ps.Z",
month = mar,
year = 1993
}

@article{wise93a,
author = "Wise, David S. ",
title = "Stop-and-copy and One-Bit Reference Counting.",
journal = IPL,
volume = 46,
number = 5,
month = jul,
pages = {243--249},
year = 1993,
comment = {TR \cite{wise93} is ther better version of this work.}
}

@techreport{wise94,
author = "Wise, David S.  and Heck, Brian  and Hess, Caleb  and Hunt, Willie  and Ost, Eric ",
institution = "Indiana University, Computer Science Department",
title = "Uniprocessor Performance of a Reference-Counting Hardware Heap",
year = 1994,
URL = "ftp://ftp.cs.indiana.edu/pub/techreports/TR401.ps.Z",
month = may,
number = "{TR}-401",
}

@inproceedings{wise96,
author = {Wise, David S. and J. Walgenbach},
title = {Static and Dynamic partitioning of Pointers as Links and Threads},
booktitle = {Proceedings of 1996 ACM SIGPLAN International Conference on Functional Programming},
publisher = ACM,
series = SIGPLAN,
volume = "31(6)",
month = jun,
pages = {42--49},
year = 1996,
URL = {http://doi.acm.org/10.1145/232627.232634}
}


@article{wise97,
author = "Wise, David S. and Hess, Caleb and Hunt, Willie  and Ost, Eric ",
title = "Research Demonstration of a Hardware Reference-Counting Heap",
journal = LSC,
volume = 10,
number = 2,
pages = {151--181},
year = 1997,
month = jul,
URL = {http://www.wkap.nl/oasis.htm/136324},
comment = {This is the same paper as \cite{wise94}.}
}

@inproceedings{wise66,
author = "N. E. Wiseman",
title = "A Simple List Processing Package for the {PDP--7}",
booktitle = "DECUS Second European Seminar, Aachen",
month = oct,
pages = "37--42",
year = 1966
}

@techreport{wise85a,
author = "Wiseman, Simon R.",
title = "A Garbage Collector for a Large Distributed Address Space",
number = "85009",
institution = "Royal Signals and Radar Establishment",
address = "Malvern, UK",
year = 1985
}

@phdthesis{wise88,
author = "Wiseman, Simon R.",
title = "Garbage Collection in Distributed Systems",
year = 1988,
school = "University of Newcastle upon Tyne"
}

@inproceedings{with91,
title = "How Real is ``Real Time'' Garbage Collection?",
author = "P. Tucker Withington",
crossref = "OOPSLA91-gc",
URL = "ftp://ftp.cs.utexas.edu/pub/garbage/GC91/withington.ps"
}


@article{wodo69,
author = "P. L. Wodon",
title = "Data Structure and Storage Allocation",
journal = "BIT",
volume = 9,
number = 3,
year = 1969,
pages = "270--282",
}


@incollection{wodo71,
author = "P. L. Wodon",
title = "Methods of Garbage Collection for {A}lgol--68",
crossref = "Algol68",
pages = "245--262",
comments = {variant of Deutsch-Schorr-Waite algorithm for varisized cells.},
}


@inproceedings{wolc90,
author = "Mario I. Wolczko and Ifor Williams",
title = "Garbage Collection in High Performance System",
crossref = "OOPSLA90-gc",
}


@incollection{wolc90a,
author = "Mario I. Wolczko",
title =	"Garbage Collection",
booktitle = "Case Studies in Systematic Software Development",
publisher = PH,
year = 1990,
editor = "Cliff B. Jones and Roger C. F. Shaw",
chapter = 8,
pages =	"211-233"
}

@inproceedings{wolc92,
author = "Wolczko, Mario I. and Williams, Ifor",
title = "Multi-Level {GC} in a High-Performance Persistent Object System",
comment = "large (512K) SW-controlled cache, accessed by SW-generated obj ID; in-cache GC",
crossref = "IWPOS92",
}

@inproceedings{wolc93,
author = "Mario I. Wolczko and Ifor Williams",
title = "An Alternative Architecture for Objects: Lessons from the {MUSHROOM} Project",
crossref = "OOPSLA93-gc",
}

@article{wolf89,
title = "Practical Comparison of Two Object-Oriented Languages",
author = "W. Wolf",
journal = "IEEE Software",
publisher = IEEE,
volume = 6,
number = 5,
pages = "61--68",
year = "1989",
abstract = { The author compares two very different object-oriented programming
languages, Flavors and C++ , with respect to their merits and how
design decisions in each language influence various aspects of 
programming.
The fundamental difference between the two languages is that C++ is
strongly typed while Flavors is weakly typed.  The comparison follows the
completion of two very similar programming projects, one using Flavors 
and the other C++ , allowing direct comparison of software implementation
methods in these languages.  The projects involved the design of two systems
for describing and generating electronic hardware.  Differences in implementing
all three object-oriented language mechanisms--data abstraction, inheritance,
and runtime method determination--are discussed.  Typing, memory management,
syntax aids, and the programming environment are examined.  It is concluded
that the choice of a language can have a profound influence on program 
design.}
}


@article{wong87,
title = "Garbage Collection Coprocessor System",
author = "K. F. Wong",
journal = "Electronics Letters",
volume = 23,
number = 15,
pages = "798--800",
year = "1987",
abstract = {The intelligent cell memory system is coprocessor system to achieve
on-the-fly garbage collection.  Analyses on its experimental results reveal 
its advantages over conventional garbage collection approaches.}
}


@article{wood81,
author = "M. C. Woodward",
title = "Multiprocessor Garbage Collection --- a New Solution",
journal = "Computer Studies",
volume = 115,
year = 1981
}

@inproceedings{wrig93,
author = "D. A. Wright and C. A. Baker-Finch",
title = "Usage Analysis with Natural Reduction Types",
booktitle = "Third International Workshop on Static Analysis",
year = 1993
}


@mastersthesis{wu89,
author = "Wu, Meizhen",
title = "A Parallel Garbage Collection Algorithm for Virtual Memory",
year = 1989,
school = "Auburn University"
}

@techreport{wu89a,
author = "Wu, Zhibo",
title = "A Real Time Distributed Garbage Collection Method",
institution = "University of Exeter. Department of Computer Science",
year = 1989,
note = "Year maybe 1992",
type = "Research report",
number = "R 181"
}

@inproceedings{yama98,
author = {Hirotaka Yamamoto and Kenjiro Taura and Akinori Yonezawa},
title = {Comparing Reference Counting and Global Mark-and-Sweep on Parallel Computers},
booktitle = {Proceedings of Languages, Compilers, and Run-time Systems (LCR98)},
series = LNCS,
month = may,
year = 1998,
URL = {ftp://ftp.yl.is.s.u-tokyo.ac.jp/pub/papers/lcr98-gc-a4.ps.gz}
}

@inproceedings{yama98a,
author = {Hirotaka Yamamoto and Kenjiro Taura and Akinori Yonezawa},
title = {Performance Comparison between Reference Counting and Global {GC} on Distributed-Memory Parallel Computers},
booktitle = {Proceedings of Joint Symposium on Parallel Processing (JSPP)},
month = jun,
year = 1998,
URL = {ftp://ftp.yl.is.s.u-tokyo.ac.jp/pub/papers-japanese/jspp98-gc.ps.gz},
note = {In Japanese}
}

@inproceedings{yian02,
author = {Qian Yang and Witawas Srisa-an and Therapon Skotiniotis and J. MOrris Chang},
title = {Java Virtual Machine Probes --- a Study of Object Life Span and {GC}},
booktitle = {Proceedings of 21st {IEEE} International Performance, Computing and Communications Conference ({IPCCC}},
address = {Phoenix, AZ},
month = apr,
year = 2002
}

@inproceedings{yasu91,
author = "Masahiro Yasugi and Akinori Yonezawa",
title = "Towards User (Application) Language-Level Garbage Collection in Object-Oriented Concurrent Languages",
crossref = "OOPSLA91-gc",
}

@inproceedings{ye97,
author = {Xinfeng Ye and John Keane},
title = {Collecting Cyclic Garbage in Distributed Systems},
booktitle = {International Symposium on Parallel Architectures, Algorithms and Networks ({ISPAN} '97)},
address = {Taipei, Taiwan},
month = dec,
year = 1997,
URL = {http://csdl.computer.org/dl/proceedings/ispan/1997/8259/00/82590227.pdf},
abstract = {The proposed garbage collection scheme identifies and
collects cycles of garbage scattered across several machines. The
scheme identifies a garbage cycle by investigating: (a) whether the
transitive closure of a given object form a cycle, and (b) whether
objects in the transitive closure are referenced by objects outside the
closure. The algorithm only traces objects in the transitive closure of
the object suspected to be in a garbage cycle. Thus, compared to normal
mark-sweep, the algorithm here has better scalability. In contrast to
partly-mark-sweep, which marks objects in two rounds, this algorithm
identifies garbage in one round. Thus, the algorithm here is more
efficient in terms of speed. This algorithm does not interfere with the
mutators' operations. Unlike many other schemes, the algorithm here
does not require an object to reserve any memory to hold the
information for running the algorithm. Thus, a large amount of memory
can be saved.}
}

@inproceedings{yeat97,
author = "Stuart A. Yeates and Michel de Champlain",
title = "Design Patterns in Garbage Collection",
booktitle = "Proceedings of the 4th Annual Conference on the Pattern Languages of Programs",
year = 1997,
editor = "Robert S. Hanmer and Don Roberts",
address = "Monticello, IL",
month =	 "2-5 September",
note =	 "Published as technical report \# WUCS-97-34 of Washington University (not peer reviewed)",
comment = "Not a peer reviewed publication but a 'shepparded' one.",
volume = "6 ``General Techniques''",
abstract = "This paper describes several design patterns found
	  in garbage collectors. The patterns we present are
	  divided into two groups. The first group are two new
	  design patterns: {\it Rootset\/} and {\it
	  TriColour\/} that have been  used in the garbage
	  collection domain for up to 20 years. The second
	  group of patterns are reported in the GoF book, such
	  as {\it Adapter\/}, {\it Facade\/}, {\it Iterator\/}
	  and {\it Proxy\/},but we examine their use in the
	  garbage collection domain. By applying these
	  patterns, their solutions provide a less efficient,
	  but simpler and more flexible way of implementing
	  and reusing garbage collectors in programming
	  languages than current low-level methods.", 
URL = {http://www.cs.waikato.ac.nz/~syeates/pubs/plop2.ps.gz}
}

@mastersthesis{yeat97a,
author = "Stuart Yeates",
title = "Design Patterns in Garbage Collection",
school = "University of Canterbury",
year = 1997,
address = "Christchurch, New Zealand",
month =	 jun,
URL = {http://www.cs.waikato.ac.nz/~syeates/pubs/thesis.ps.gz}
}

@inproceedings{yeat97b,
author = "Stuart A. Yeates  and Michel de Champlain",
title = "Design of a Garbage Collector Using Design Patterns",
booktitle = "Proceedings of the twenty-fifth conference of (TOOLS) Pacific.", 
year = 1997,
editor = "Christine Mingins and Roger Duke and Bertrand Meyer",
organization = "ISE (Interactive Software Engineering)",
address = "Melbourne",
pages =	"77-92",
annote = {We present six design patterns---Adapter, 
	  Facade, Iterator, Proxy, RootSet and
	  TriColour---found during a review of four different
	  garbage collectors. We also capture the design
	  decisions and trade-offs behind the low-level
	  implementation that characterises most garbage
	  collectors. A garbage collector for real-time
	  applications is then designed using the design
	  patterns. We discuss the selected algorithm and
	  various implementation techniques. Finally the
	  performance of the collector is examined using
	  formal methods. This paper presents a novel attempt
	  to "mine" and capture the essential design decisions
	  and trade-offs in garbage collectors. } ,
URL = {http://www.cs.waikato.ac.nz/~syeates/pubs/tools2.ps.gz}
}

@article{yelo77,
author = "L. Yelowitz and  A. G. Duncan",
title = "Abstractions, Instantiations and Proofs of Marking Algorithms",
journal = Sigplan,
publisher = ACM,
volume = 12,
number = 8,
month = Aug,
year = 1977,
comments = {proves the correctness of several marking algorithms},
pages = "13--21"
}

@techreport{yi92,
author = {Kwangkeun Yi and Harrison III, Williams Ludwell},
title = {Interprocedural Data Flow Analysis for Compile-time Memory
Management},
number = 1244,
institution = {Center for Supercomputing Research and Development,
University of Illinois},
month = aug,
year = 1992
}

@techreport{yip91,
author = "Yip, G. May",
title = "Incremental, Generational Mostly-Copying Garbage Collection in Uncooperative Environments",
institution = "Digital, Western Research Laboratory",
year = 1991,
number = "91/8",
month = jun,
URL = "ftp://ftp.digital.com/pub/DEC/WRL/research-reports/WRL-TR-91.8.ps",
note = "Masters Thesis --- MIT, Cambridge, MA, 1991",
abstract = "The thesis of this project is that incremental 
collection can be done feasibly and efficiently in an 
architecture and compiler independent manner.  The design and 
implementation of an incremental, generational mostly-copying
garbage collector for C++ is presented.  The collector achieves, 
simultaneously, real-time performance (from incremental 
collection), low total garbage collection delay (from 
generational collection), and the ability to function without 
hardware and compiler support (from mostly-copying collection).  
The incremental collector runs on commercially-available 
uniprocessors, such as the DECstation 3100, without any special 
hardware support.
It uses UNIX's user controllable page protection facility 
(mprotect) to synchronize between the scanner (of the collector) 
and the mutator (of the application program).  Its implementation 
does not require any modification to the C++ compiler.  The 
maximum garbage collection pause  is well within the 100-
millisecond limit imposed by real-time applications  executing on 
interactive workstations.  Compared to its non-incremental 
version, the total execution time of the incremental collector is 
not adversely affected."
}

@inproceedings{yong94,
author = "V.-F. Yong and J. Naughton amd J.-B. Yu",
title = "Storage Reclamation and Reorganization in Client--Server Persistent Object Stores",
booktitle = "International Conference on Data Engineering",
address = "Houston, TX",
pages = "120--133",
month = feb,
year = 1994
}

@inproceedings{yu03,
author = {Dachuan Yu and Nadeem A. Hamid and Zhong Shao},
title = {Building Certified Libraries for {PCC}: Dynamic Storage Allocation},
crossref = {ESOP03},
pages = {101--127}
}

@inproceedings{yu96,
author = {W. Yu and A. Cox},
title = {Conservative Garbage Collection on Distributed Shared Memory System},
booktitle = {Sixth International Conference on Distributed Computing Systems ICDCS96},
pages = {402--410},
year = 1996
}

@techreport{yuas85,
author = "Taiichi Yuasa and Masumi Hagiya",
title = "Kyoto {C}ommon {L}isp Report",
institution = "Teikoku Insatsu Publishing, Kyoto",
year = 1985
}

@article{yuas90,
author = "Taichi Yuasa",
address = "Kyoto Univ, Math Sci Research Inst., Kyoto 606, Japan",
title = "Real-Time Garbage Collection on General-Purpose Machines",
journal = "Journal of Software and Systems",
volume = 11,
number = 3,
pages = "181--198",
year = 1990,
comment = "Snapshot-at-beginning algorithm.
When a location is written to, previous contents saved onto a stack.
Thus all objects live at the beginning of a GC will be reached.
Large advantage of Baker on stock hardware is that only heap pointer writes
must be treated specially to preserve the invariants."
}


@inproceedings{yuas92,
title = "Memory Management and Garbage Collection of an Extended {Common} {L}isp System for Massively Parallel {SIMD} Architecture",
author = "Taichi Yuasa",
address = "Toyohashi University of Technology, Japan",
crossref = "IWMM92",
}


@inproceedings{yuha86,
title = "Evaluation of the {Facom} {Alpha} {L}isp Machine.",
author = "M. Yuhara and A. Hattori and M. Niwa and M. Kishimoto and H. Hayashi",
booktitle = "13th Annual International Symposium on Computer 
Architecture --- Conference Proceedings. {T}okyo, 1986 {J}une 2--5",
publisher = IEEE,
year = 1986,
abstract = {The FACOM ALPHA is the first and only commercially dedicated
processor for Lisp and Prolog manufactured in Japan.  The authors discuss 
the evaluation of the FACOM ALPHA for Lisp execution when compared with a 
general-purpose computer.  The CPU use rate for machine instructions and the
utilization ratio of the hardware resources are discussed.  The interaction
between the garbage collector and the virtual memory system, which 
improves system response time, is explained.}
}

@article{zave75,
author = "Derek A. Zave",
title = "A Fast Compacting Garbage Collector",
journal = IPL,
publisher = NH,
volume = 3,
number = 6,
month = Jul,
year = 1975,
pages = "167--169",
comments = {algorithm for compacting varisized cells},
}

@article{zee02,
title = {Write Barrier Removal by Static Analysis},
author = {Karen Zee and Martin Rinard},
journal = SIGPLAN,
volume = 37,
number = 4,
month = apr,
year = 2002
}

@inproceedings{zee02a,
title = {Write Barrier Removal by Static Analysis},
author = {Karen Zee and Martin Rinard},
pages = {191--210},
crossref = {OOPSLA02}
}

@inproceedings{zhan98,
title = {Experiments with Combined Analysis for Pointer Aliasing},
author = {Sean Zhang and Barbara G. Ryder and William A. Landi},
crossref = {PASTE98}
}

@article{zhao87,
author = "W. Zhao and K. Ramamritham and J. A. Stankovic",
title = "Scheduling Tasks with Resource Requirements in Hard Real-Time Systems",
journal = TransSWE,
publisher = ACM,
volume = 5,
number = 13,
pages = "564--577",
month = may,
year = 1987
}

@article{zhou92,
author = "Songnian Zhou and Michael Stumm and Kai Li and David Wortman",
title = "Heterogeneous Distributed Shared Memory",
journal = "IEEE Transactions on Parallel and Distributed Systems",
publisher = IEEE,
volume = 3,
number = 5,
pages = "540--554",
month = Sep,
year = 1992
}

@inproceedings{zhou00,
author = {Neng-Fa Zhou},
title = {Garbage Collection in {B}-{P}rolog},
booktitle = {First Workshop on Memory Management in Logic Programming Implementations},
month = jul,
year = 2000,
URL = {http://www.sci.brooklyn.cuny.edu/~zhou/#PUB},
}

@inproceedings{zigm00,
author = {John Zigman and Stephen M. Blackburn and J. Eliot B. Moss},
title = {{TMOS}: a Transactional Garbage Collector},
pages = {116--135},
crossref = {IWPOS00}
}

@techreport{zorn87,
author = "Benjamin Zorn and Paul Hilfinger and Kinson Ho and James R. Larus",
title = "{SPUR} {Lisp}: Design and implementation",
number = "UCB/CSD 87/373",
institution = UCB,
month = oct,
year = 1987
}

@inproceedings{zorn88,
title = {A Memory Allocation Profiler for {C} and {L}isp Programs},
author = "Benjamin Zorn and Paul Hilfinger and Kinson Ho and James R. Larus",
booktitle = {Proceedings for the Summer 1988 USENIX Conference},
pages = {223--237},
month = jun,
year = 1998,
URL = {ftp://ftp.digital.com/pub/misc/mprof-3.0.tar},
ABSTRACT = {This paper describes inprof, a tool used to study the memory
allocation behavior of programs.  mprof records the amount of memory
each function allocates, breaks down allocation information by type
and size, and displays a program's dynamic cal graph so that functions
indirectly responsible for memory allocation are easy to identify.
mprof is a two-phase tool.  The monitor phase is linked into executing
programs and records information each time memory is allocated.  The
display phase reduces the data generated by the monitor and displays
the information to the user in several tables. mprof has been
implemented for C and Kyoto Common Lisp.  Measurements of these
implementations are presented.}
}

@phdthesis{zorn89,
author = "Zorn, Benjamin G.",
title = "Comparative Performance Evaluation of Garbage Collection Algorithms",
school = "University of California at Berkeley",
note = "Technical Report UCB/CSD 89/544",
URL = "ftp://tr-ftp.cs.berkeley.edu/pub/tech-reports/csd/csd-89-544/",
month = mar,
year = 1989,
comment = "Reduces read barrier overhead by using knowledge of special
cases. Overheads of the order of 20 percent.",
abstract = "This thesis shows that object-level, trace-driven 
simulation can facilitate evaluation of language runtime systems 
and reaches new conclusions about the relative performance of 
important garbage collection algorithms. In particular, I reach 
the unexpected conclusion that mark-and-sweep garbage collection, 
when augmented with generations, shows comparable CPU performance 
and much better reference locality than the more widely used 
copying algorithms. In the past, evaluation of garbage collection 
algorithms has been limited by the high cost of implementing the 
algorithms. Substantially different algorithms have rarely been 
compared in a systematic way.
With the availability of high-performance, low-cost workstations, 
trace-driven performance evaluation of these algorithms is now 
economical. This thesis describes MARS, a runtime system 
simulator that is driven by operations on program objects, and 
not memory addresses. MARS has been attached to a commercial 
Common Lisp system and eight large Lisp applications are used in 
the thesis as test programs. To illustrate the advantages of the 
object-level tracing technique used by MARS, this thesis compares 
the relative performance of stop-and-copy, incremental, and mark-
and-sweep collection algorithms, all organized with multiple 
generations. The comparative evaluation is based on several 
metrics: CPU overhead, reference locality, and interactive 
availability.
Mark-and-sweep collection shows slightly higher CPU overhead than 
stop-and-copy ability (5 percent), but requires significantly less 
physical memory to achieve the same page fault rate (30-40 percent). 
Incremental collection has very good interactive availability, 
but implementing the read barrier on stock hardware incurs a 
substantial CPU overhead (30-60 percent). In the future, I will use MARS 
to investigate other performance aspects of sophisticated runtime 
systems."
}


@inproceedings{zorn90,
author = "Benjamin Zorn",
title = "Comparing Mark-and-Sweep and Stop-and-Copy Garbage Collection",
crossref = "LFP90",
abstract = {Stop-and-copy garbage collection has been preferred to
mark-and-sweep collection in the last decade because its collection time
is proportional to the size of reachable data and not the memory size.
This paper compares the CPU overhead and the memory requirements of the
two collection algorithms extended with generations, and finds that
mark-and-sweep collection requires at most a small amount of additional
CPU overhead (3--6 percent) but requires an average of 20 percent (and up to 40 percent) less
memory to achieve the same page fault rate. The comparison is based on
results obtained using trace-driven simulation with large Common Lisp
programs.
Many recent papers on copying gc algorithms have mentioned mark-and-sweep
collection only in passing, noting that because the cost is proportional to
the size of memory, mark-and-sweep collection is less efficient that copying
collection [....]. Appel, Ellis, and Li note that the cost of mark-and-sweep
collection is probably somewhat higher than the cost of copying collection,
but concede that other costs (allocation, barriers, vm overhead) effect
performance enough that copying collectors may not necessarily be the most
effective.
I note that the cost of sweeping is just an extension of the cost of
allocation, and quantify that cost to be up to 5 percent in allocation intensive
programs.  },
}


@inproceedings{zorn90a,
author = "B. Zorn",
title = "Designing Systems for Evaluation: A Case Study of Garbage Collection",
crossref = "OOPSLA90-gc",
}


@techreport{zorn90b,
author = "Zorn, Benjamin",
title = "Barrier Methods for Garbage Collection",
institution = "University of Colorado, Boulder",
year = 1990,
number = "CU-CS-494-90",
URL = "ftp://ftp.cs.colorado.edu/pub/cs/techreports/zorn/CU-CS-494-90.ps.Z",
month = Nov,
abstract = "Garbage collection algorithms have been enhanced in 
recent years with two methods: generation-based collection and 
Baker incremental copying collection.  Generation-based 
collection requires special actions during certain store 
operations to implement the 'write barrier.'  Incremental 
collection requires special actions on certain load operations to 
implement the 'read barrier.'  This paper evaluates the 
performance of different implementations of the read and write 
barriers and reaches several important conclusions.  First, the 
inlining of barrier checks results in surprisingly low overheads, 
both for the write barrier (2-6 percent) and the read barrier (< 20 percent).
Contrary to previous belief, these results suggest that a Baker- 
style read barrier can be implemented efficiently without 
hardware support. Second, the use of operating system traps to 
implement garbage collection methods results in extremely high 
overheads because the cost of trap handling is so high.  Since 
this large overhead is completely unnecessary, operating system 
memory protection traps should be reimplemented to be as fast as 
possible.  Finally, the performance of these approaches on 
several machine architectures is compared to show that the 
results are generally applicable."
}

@techreport{zorn91,
author = "Benjamin Zorn",
title = "The Effect of Garbage Collection on Cache Performance",
number = "CU--CS--528--91",
URL = "ftp://ftp.cs.colorado.edu/pub/cs/techreports/zorn/CU-CS-528-91.ps.Z",
institution = "University of Colorado at Boulder",
month = May,
comment = "compares mark-sweep and generational GC with various cache sizes;
says mark-sweep is significantly better with direct-mapped cache",
year = 1991
}


@techreport{zorn92,
author = "Benjamin Zorn",
title = "The Measured Cost of Garbage Collection",
number = "CU--CS--573--92",
month = apr,
year = 1992,
URL = "ftp://ftp.cs.umd.edu/pub/papers/TRs/3370.ps.Z",
institution = "University of Colorado at Boulder",
abstract = "Dynamic storage allocation is an important part of 
many computer programs and will be increasingly important as 
object- oriented programming styles become more widely used.  
Experience indicates that for many programs, dynamic storage 
allocation is so important that programmers feel compelled to 
provide their own optimized implementations to avoid the overhead 
of system libraries.  Conservative garbage collection   has been 
suggested as an important algorithm for dynamic storage 
management in C programs.  In this paper, I evaluate the costs of 
different  dynamic storage management algorithms, including 
programmer optimized algorithms; standard, widely-used library 
routines; and a publicly available conservative garbage 
collection algorithm.
Surprisingly, I find that programmer optimization has little or 
no effect on program performance.  I also find that the true cost 
of conservative garbage collection is not the CPU overhead, but 
the memory system overhead of the algorithm.  I conclude that 
conservative garbage collection is a promising alternative to 
explicit storage management and that the performance of 
conservative collection is likely to be improved in the future.  
C programmers should now seriously consider using conservative 
garbage collection instead of malloc/free in programs they 
write.",
address = "Department of Computer Science, Boulder, Colorado",
comment = "measures Boehm 1.6 (non-generational) against various mallocs;
cache misses, page fault measurements.  Overall result: pretty
comparable (but ignores optimization problem)"
}


@techreport{zorn92a,
author = "Benjamin Zorn and Dirk Grunwald",
title = "Evaluating Models of Memory Allocation",
institution = "University of Colorado",
type = "Computer Science Technical Report",
number = "CU-CS-603-92",
month = jul,
URL = {ftp://ftp.cs.colorado.edu/pub/cs/techreports/zorn/CU-CS-603-92.ps.Z},
year = 1992,
}

@techreport{zorn92b,
author = "Benjamin Zorn and Dirk Grunwald",
title = "Empirical Measurements of Six Allocation-Intensive {C} Programs",
institution = "University of Colorado",
type = "Computer Science Technical Report",
number = "CU-CS-604-92",
month = jul,
year = 1992,
URL = {ftp://ftp.cs.colorado.edu/pub/cs/techreports/zorn/CU-CS-604-92.ps.Z},
}

@article{zorn92c,
author = "Benjamin Zorn and Dirk Grunwald",
title = "Empirical Measurements of Six Allocation-Intensive {C} Programs",
journal = SIGPLAN,
volume = 27,
number = 12,
pages = {71--80},
year = 1992,
}

@article{zorn93,
author = "Benjamin Zorn",
title = "The Measured Cost of Conservative Garbage Collection",
journal = SPE,
publisher = Wiley,
volume = 23,
pages = "733--756",
abstract = "Because dynamic memory management is an important part of a large
class of computer programs, high-performance algorithms for dynamic
memory management have been, and will continue to be, of considerable
interest.  Experience indicates that for many programs, dynamic
storage allocation is so important that programmers feel compelled to
write and use their own domain-specific allocators to avoid the
overhead of system libraries.  Conservative garbage collection has
been suggested as an important algorithm for dynamic storage
management in C programs.  In this paper, I evaluate the costs of
different dynamic storage management algorithms, including
domain-specific allocators; widely-used general-purpose allocators;
and a publicly available conservative garbage collection algorithm.
Surprisingly, I find that programmer enhancements often have little
effect on program performance.  I also find that the true cost of
conservative garbage collection is not the CPU overhead, but the
memory system overhead of the algorithm.  I conclude that conservative
garbage collection is a promising alternative to explicit storage
management and that the performance of conservative collection is
likely to be improved in the future.  C programmers should now
seriously consider using conservative garbage collection instead of
malloc/free in programs they write.",
year = 1993
}


@article{zorn94,
author = "Benjamin Zorn and Dirk Grunwald",
title = "Evaluating Models of Memory Allocation",
journal = "ACM Transactions on Modelling and Computer Simulation",
publisher = ACM,
volume = 4,
number = 1,
year = 1994
}

@inproceedings{zorn98,
title = {Segregating Heap Objects by Reference Behavior and Lifetime},
author = {Benjamin Zorn and M. Seidl},
crossref = {ASPLOS98},
URL = {http://www.cs.colorado.edu/~seidl/papers/ASPLOS8.ps}
}



% CROSS REFERENCES

% BOOKS

@book{Algol68,
booktitle = "Algol--68 Implementation",
title = "Algol--68 implementation",
editor = "J. E. L. Peck",
publisher = "North-Holland",
address = "Amsterdam",
year = 1971,
pages = "198--238",
}

% First edition 1964
@book{berk64,
editor = "E. C. Berkeley and Daniel G. Bobrow",
title = "The Programming Language {LISP}: Its Operation and Applications",
booktitle = "The Programming Language {LISP}: Its Operation and Applications",
publisher = "Information International, Inc.",
address = "Cambridge, MA",
year = 1974,
edition = "Fourth"
}

@inproceedings{berl00,
author = {Alexandru Berlea and Sorin Cotofana and Irina Athanasiu and John Glossner and Stamatis Vassiliadis},
title = {Garbage Collection for the {D}elft {J}ava Processor},
booktitle = {Proceedings of 18th {IASTED} International Conference, Applied Informatics},
address = {Innsbruck},
year = 2000 ,
URL = {http://www.informatik.uni-trier.de/~aberlea/publications/ai2000/GCforDJP.doc.gz}
}

@book{Smalltalk-BHWA,
editor = "Glenn Krasner",
booktitle = "Smalltalk-80: Bits of History, Words of Advice",
title = "Smalltalk-80: Bits of History, Words of Advice",
publisher = AW,
year = 1983,
comment = "Early implementations spent 20-70 percent of time in GC"
}

% CONFERENCES

@proceedings{ASPLOS82, key = "ASPLOS",
title = "Proceedings of the Symposium on Architectural Support for
Programming Languages and Operating Systems (ASPLOS)", 
booktitle = "Second International Conference on Architectural Support for
Programming Languages and Operating Systems (ASPLOS)", 
year = 1982, 
publisher = ACM,
series = SIGPLAN,
volume = "12(4)"
}

@proceedings{ASPLOS87, key = "ASPLOS",
title = "Second International Conference on Architectural Support for
Programming Languages and Operating Systems (ASPLOS II)", 
booktitle = "Second International Conference on Architectural Support for
Programming Languages and Operating Systems (ASPLOS II)", 
address = "Palo Alto, CA",
year = 1987, 
month = oct
}

@proceedings{ASPLOS89, key = "ASPLOS",
title = "Third International Conference on Architectural Support for
Programming Languages and Operating Systems (ASPLOS III)", 
booktitle = "Third International Conference on Architectural Support for
Programming Languages and Operating Systems (ASPLOS III)", 
address = "Boston",
year = 1989, 
month = apr
}

@proceedings{ASPLOS91, key = "ASPLOS",
booktitle = "Fourth International Conference on Architectural Support for
Programming Languages and Operating Systems (ASPLOS IV)", 
title = "Fourth International Conference on Architectural Support for
Programming Languages and Operating Systems (ASPLOS IV)",
address = "Santa Clara, CA",
year = 1991,
month = apr
}

@proceedings{ASPLOS92, key = "ASPLOS",
booktitle = "Fifth International Conference on Architectural Support for
Programming Languages and Operating Systems (ASPLOS V)", 
title = "Fifth International Conference on Architectural Support for
Programming Languages and Operating Systems (ASPLOS V)",
address = "Boston",
year = 1992,
month = sep
}

@proceedings{ASPLOS94, key = "ASPLOS",
booktitle = "International Conference on Architectural Support for
Programming Languages and Operating Systems", 
title = "International Conference on Architectural Support for
Programming Languages and Operating Systems",
year = 1994,
month = oct
}

@proceedings{ASPLOS96, key = "ASPLOS",
booktitle = "International Conference on Architectural Support for
Programming Languages and Operating Systems", 
title = "International Conference on Architectural Support for
Programming Languages and Operating Systems",
year = 1996,
month = sep,
note = {SIGLAN Notices 31(9)}
}

@proceedings{ASPLOS98, key = "ASPLOS",
booktitle = "Eighth International Conference on Architectural Support for
Programming Languages and Operating Systems", 
title = "Eighth International Conference on Architectural Support for
Programming Languages and Operating Systems",
address = "San Jose, CA",
year = 1998,
month = oct
}

@proceedings{CC79, key = "CC",
booktitle = "Proceedings of the ACM SIGPLAN '79 Symposium on Compiler Construction",
title = "Proceedings of the ACM SIGPLAN '79 Symposium on Compiler Construction",
month = aug,
year = 1979,
address = "Palo Alto, CA",
publisher = ACM,
series = SIGPLAN,
volume = "14(8)",
}

@proceedings{CC86, key = "CC",
booktitle = "Proceedings of the ACM SIGPLAN '86 Symposium on Compiler Construction",
title = "Proceedings of the ACM SIGPLAN '86 Symposium on Compiler Construction",
year = 1986,
month = jun,
address = "Palo Alto, CA",
publisher = ACM,
series = SIGPLAN,
volume = "21(7)",
}

@proceedings{ECOOP84, key = "ECOOP",
booktitle = "Proceedings of 1984 European Conference on Object-Oriented Programming",
title = "Proceedings of 1984 European Conference on Object-Oriented Programming",
year = 1984
}

@proceedings{ECOOP87, key = "ECOOP",
booktitle = "Proceedings of 1987 European Conference on Object-Oriented Programming",
title = "Proceedings of 1987 European Conference on Object-Oriented Programming",
editor = {J. B\'{e}zivin and J.-M. Hullot and P. Cointe and Henry Lieberman},
series = LNCS,
publisher = SV,
month = jun,
year = 1987,
volume = 276,
}

@proceedings{ECOOP93, key = "ECOOP",
booktitle = "Proceedings of 1993 European Conference on Object-Oriented Programming",
title = "Proceedings of 1993 European Conference on Object-Oriented Programming",
editor = "O. Nierstras",
series = LNCS,
publisher = SV,
month = jul,
year = 1993,
volume = 707,
address = "Kaiserslautern, Germany"
}

@proceedings{ECOOP94, key = "ECOOP",
booktitle = "Proceedings of the Eighth European Conference on Object-Oriented Programming",
title = "Proceedings of the Eighth European Conference on Object-Oriented Programming",
editor = "M. Tokoro and R. Pareschi",
series = LNCS,
publisher = SV,
volume = 821,
year = 1994,
}

@proceedings{ECOOP95, key = "ECOOP",
booktitle = "Proceedings of 1995 European Conference on Object-Oriented Programming",
title = "Proceedings of 1995 European Conference on Object-Oriented Programming",
editor = "O. Nierstras",
series = LNCS,
publisher = SV,
month = aug,
year = 1995,
}

@proceedings{ECOOP98, key = "ECOOP",
title = "Proceedings of 12th European Conference on Object-Oriented Programming, ECOOP98",
booktitle = "Proceedings of 12th European Conference on Object-Oriented Programming, ECOOP98",
address = {Brussels},
editor = {Eric Jul},
series = LNCS,
volume = 1445,
publisher = SV,
month = jul,
year = 1998,
}

@proceedings{ECOOP99, key = "ECOOP",
title = "Proceedings of 13th European Conference on Object-Oriented Programming, ECOOP99",
booktitle = "Proceedings of 13th European Conference on Object-Oriented Programming, ECOOP99",
address = {Lisbon},
month = jul,
year = 1999,
}

@proceedings{ECOOP01, key = "ECOOP",
title = "Proceedings of 15th European Conference on Object-Oriented Programming, ECOOP 2001",
booktitle = "Proceedings of 15th European Conference on Object-Oriented Programming, ECOOP 2001",
editor = {J{\o}rgen Lindskov Knudsen},
address = {Budapest},
month = jun,
year = 2001,
series = SV,
volume = 2072,
publisher = SV
}

@proceedings{EMSOFT01, key = "EMSOFT",
title = {First International Workshop on Embedded Software (EMSOFT)},
booktitle = {First International Workshop on Embedded Software (EMSOFT)},
address = {Tahoe City, CA},
editor = {T.A. Henzinger and C.M. Kirsch},
publisher = {Springer},
series = LNCS,
volume = 2211,
year = 2001
}

@proceedings{ESOP03, key = "ESOP",
title = {12th European Symposium on Programming (ESOP 2003)},
booktitle = {12th European Symposium on Programming (ESOP 2003)},
publisher = {Elsevier},
year = 2003,
note = {Also published in Science of Computer Programming, 50(1--3), March 2004}
}

@proceedings{FPCA85, key = "FPCA",
booktitle = "Record of the 1985 Conference on Functional Programming and Computer Architecture",
title = "Record of the 1985 Conference on Functional Programming and Computer Architecture",
editor = "Jean-Pierre Jouannaud",
series = LNCS,
publisher = SV,
volume = 201,
month = sep,
year = 1985,
address = "Nancy, France",
}

@proceedings{FPCA87, key = "FPCA",
booktitle = "Record of the 1987 Conference on Functional Programming and Computer Architecture",
title = "Record of the 1987 Conference on Functional Programming and Computer Architecture",
editor = "Gilles Kahn",
series = LNCS,
publisher = SV,
volume = 274,
month = sep,
year = 1987,
address = "Portland, Oregon"
}

@proceedings{FPCA89, key = "FPCA",
booktitle = "Record of the 1989 Conference on Functional Programming and Computer Architecture",
title = "Record of the 1989 Conference on Functional Programming and Computer Architecture",
publisher = ACM,
month = aug,
year = 1989,
address = "Imperial College, London"
}

@proceedings{FPCA91, key = "FPCA",
booktitle = "Record of the 1991 Conference on Functional Programming and Computer Architecture",
title = "Record of the 1991 Conference on Functional Programming and Computer Architecture",
editor = "R. John M. Hughes",
publisher = SV,
series = LNCS,
volume = 523,
month = aug,
year = 1991,
address = "Cambridge, MA"
}

@proceedings{FPCA93, key = "FPCA",
booktitle = "Record of the 1993 Conference on Functional Programming and Computer Architecture",
title = "Record of the 1993 Conference on Functional Programming and Computer Architecture",
editor = "R. John M. Hughes",
publisher = ACM,
month = jun,
year = 1993,
address = "Copenhagen"
}

@proceedings{FPCA95, key = "FPCA",
booktitle = "Record of the 1995 Conference on Functional Programming and Computer Architecture",
title = "Record of the 1995 Conference on Functional Programming and Computer Architecture",
month = jun,
year = 1995,
}

@proceedings{glasgow88, key = "GWFP",
booktitle = "Glasgow Workshop on Functional Programming",
title = "Glasgow Workshop on Functional Programming",
year = 1988,
editor = "Cordelia Hall and R. John M. Hughes and John T. O'Donnell",
publisher = "Glasgow University Computer Science Report 89/R4",
month = feb,
}

@proceedings{glasgow90, key = "GWFP",
booktitle = "Third Annual Glasgow Workshop on Functional Programming",
title = "Third Annual Glasgow Workshop on Functional Programming",
year = 1991,
editor = "Simon L. {Peyton Jones} and G. Hutton and C. K. Hols",
publisher = SV,
}

@proceedings{glasgow91, key = "GWFP",
booktitle = "Fourth Annual Glasgow Workshop on Functional Programming",
title = "Fourth Annual Glasgow Workshop on Functional Programming",
year = 1992,
editor = "Simon L. {Peyton Jones} and G. Hutton and C. K. Hols",
publisher = SV,
series = "Workshops in Computer Science",
}

@proceedings{glasgow93, key = "GWFP",
booktitle = "Sixth Annual Glasgow Workshop on Functional Programming",
title = "Sixth Annual Glasgow Workshop on Functional Programming",
year = 1993,
publisher = SV,
series = "Workshops in Computer Science",
}

@proceedings{ICFP96, key = "ICFP",
booktitle = "Proceedings of First International Conference on Functional Programming",
title = "Proceedings of First International Conference on Functional Programming",
address = {Philadelphia, PA},
publisher = ACM,
month = may,
year = 1996,
}

@proceedings{ICFP97, key = "ICFP",
booktitle = "Proceedings of Second International Conference on Functional Programming",
title = "Proceedings of Second International Conference on Functional Programming",
address= {Amsterdam},
publisher = ACM,
month = jun,
year = 1997,
}

@proceedings{ICFP98, key = "ICFP",
booktitle = "Proceedings of International Conference on Functional Programming",
title = "Proceedings of International Conference on Functional Programming",
address = {Baltimore, MA},
publisher = ACM,
month = sep,
year = 1998,
}

@proceedings{ICFP99, key = "ICFP",
booktitle = "Proceedings of International Conference on Functional Programming",
title = "Proceedings of International Conference on Functional Programming",
address = {Paris},
publisher = ACM,
month = sep,
year = 1999,
}

@proceedings{ICFP2000, key = "ICFP",
booktitle = "Proceedings of International Conference on Functional Programming",
title = "Proceedings of International Conference on Functional Programming",
address = {Montreal},
publisher = ACM,
month = sep,
year = 2000,
}

@proceedings{ICLP82, key = "ICLP",
booktitle = "Proceedings of First International Conference on Logic Programming",
title = "Proceedings of First International Conference on Logic Programming",
year = 1982,
}

@proceedings{ICLP84, key = "ICLP",
booktitle = "Proceedings of Second International Conference on Logic Programming",
title = "Proceedings of Second International Conference on Logic Programming",
year = 1984,
editor = {S.-A. T\"{a}rnlund},
address = "Uppsala, Finland"
}

@proceedings{ICLP86, key = "ICLP",
booktitle = "Proceedings of Third International Conference on Logic Programming",
title = "Proceedings of Third International Conference on Logic Programming",
year = 1986,
editor = "E. Schapiro",
address = "London",
publisher = SV,
sweries = LNCS,
volume = 225
}

@proceedings{ICLP87, key = "ICLP",
booktitle = "Proceedings of Fourth International Conference on Logic Programming",
title = "Proceedings of Fourth International Conference on Logic Programming",
year = 1987,
editor = "J. L. Lassez",
address = "Melbourne",
}

@proceedings{ICLP88, key = "ICLP",
booktitle = "Proceedings of Fifth International Conference on Logic Programming",
title = "Proceedings of Fifth International Conference on Logic Programming",
year = 1988,
}

@proceedings{ICLP90, key = "ICLP",
booktitle = "Proceedings of Seventh International Conference on Logic Programming",
title = "Proceedings of Seventh International Conference on Logic Programming",
editor = "D. H. D. Warren and P. Szeredi",
year = 1990,
address = "Jerusalem"
}

@proceedings{ICLP02, key = "ICLP",
booktitle = "Proceedings of Eighteenth International Conference on Logic Programming",
title = "Proceedings of Seventh International Conference on Logic Programming",
editor = {P.J. Stuckey},
year = 2002,
publisher = SV,
series = LNCS,
volume = 2401,
URL = {http://link.springer.de/link/service/series/0558/tocs/t2401.htm}
}

@proceedings{ICSE04, key = "ICSE04",
title = {ICSE 2004, 26th International Conference on Software Engineering},
booktitle = {ICSE 2004, 26th International Conference on Software Engineering},
address = {Edinburgh},
month = may,
year = 2004,
}

@proceedings{ISCA85, key = "ISCA",
title = "12th Annual International Symposium on Computer Architecture",
booktitle = "12th Annual International Symposium on Computer Architecture",
month = jun,
year = 1985,
publisher = IEEE,
}

@proceedings{ISCA90, key = "ISCA",
title = "17th Annual International Symposium on Computer Architecture",
booktitle = "17th Annual International Symposium on Computer Architecture",
address = "Seattle, Washington", 
month = may,
year = 1990,
publisher = IEEE
}

@proceedings{ISCA91, key = "ISCA",
title = "18th Annual International Symposium on Computer Architecture",
booktitle = "18th Annual International Symposium on Computer Architecture",
address = "Toronto, Canada", 
month = may,
year = 1991,
publisher = ACM
}

@proceedings{ISCA92, key = "ISCA",
title = "19th Annual International Symposium on Computer Architecture",
booktitle = "19th Annual International Symposium on Computer Architecture",
address = "Gold Coast, Australia", 
month = may,
year = 1992,
publisher = ACM
}

@proceedings{ISCA93, key = "ISCA",
title = "20th Annual International Symposium on Computer Architecture",
booktitle = "20th Annual International Symposium on Computer Architecture",
address = "San Diego, CA", 
month = may,
year = 1993,
publisher = IEEE
}

@proceedings{ISCA94, key = "ISCA",
title = "21st Annual International Symposium on Computer Architecture",
booktitle = "21st Annual International Symposium on Computer Architecture",
address = "Chicago, Illinois", 
month = apr,
year = 1994,
publisher = IEEE
}

@proceedings{ISMM98, key = "ISMM",
booktitle = {{ISMM'98} Proceedings of the First International Symposium on Memory Management},
title = {{ISMM'98} Proceedings of the First International Symposium on Memory Management},
editor = {Richard Jones},
address = {Vancouver},
series = SIGPLAN,
volume = "34(3)",
publisher = ACM,
month = oct,
year = 1998,
ISBN = {1-58113-114-3},
comment = {ISMM is the successor to the IWMM series of workshops},
URL = {http://portal.acm.org/toc.cfm?id=SERIES858&idx=SERIES858&type=series&coll=portal&dl=ACM&part=series&WantType=Proceedings&title=International\%20Symposium\%20on\%20Memory\%20Management&CFID=1212196&CFTOKEN=89486318}
}

@proceedings{ISMM2000, key = "ISMM",
booktitle = {{ISMM 2000} Proceedings of the Second International Symposium on Memory Management},
title = {{ISMM 2000} Proceedings of the Second International Symposium on Memory Management},
editor = {Tony Hosking},
address = {Minneapolis, MN},
series = SIGPLAN,
volume = "36(1)",
publisher = ACM,
month = oct,
year = 2000,
ISBN = {1-58113-263-8},
URL = {http://portal.acm.org/toc.cfm?id=362422&idx=SERIES858&type=proceeding&coll=portal&dl=ACM&part=series&WantType=Proceedings&title=International\%20Symposium\%20on\%20Memory\%20Management&CFID=1212196&CFTOKEN=89486318}
}

@proceedings{ISMM02, key = "ISMM",
booktitle = {{ISMM'02} Proceedings of the Third International Symposium on Memory Management},
title = {{ISMM'02} Proceedings of the Third International Symposium on Memory Management},
editor = {David Detlefs},
address = {Berlin},
series = SIGPLAN,
publisher = ACM,
month = jun,
year = 2002,
URL = {http://www.hpl.hp.com/personal/Hans_Boehm/ismm/}
}


@proceedings{ISMM04, key = "ISMM",
booktitle = {{ISMM'04} Proceedings of the Third International Symposium on Memory Management},
title = {{ISMM'04} Proceedings of the Third International Symposium on Memory Management},
editor = {Amer Diwan},
address = {Vancouver},
series = SIGPLAN,
publisher = ACM,
month = oct,
year = 2004,
URL = {http://www.research.ibm.com/ismm04/program.html}
}

@proceedings{IWMM92, 
key = "IWMM",
booktitle = "Proceedings of International Workshop on Memory Management",
title = "Proceedings of International Workshop on Memory Management",
editor = "Yves Bekkers and Jacques Cohen",
address = "St Malo, France",
publisher = SV,
series = LNCS,
volume = 637,
month = "16--18~" # sep,
year = 1992
}


@proceedings{IWMM95, key = "IWMM",
booktitle = "Proceedings of International Workshop on Memory Management",
title = "Proceedings of International Workshop on Memory Management",
address = "Kinross, Scotland",
editor = "Henry Baker",
publisher = SV,
series = LNCS,
volume = 986,
month = sep,
year = 1995
}

@proceedings{IWOOOS91, key = "IWOOOS",
booktitle = "International Workshop on Object Orientation in Operating Systems",
title = "International Workshop on Object Orientation in Operating Systems",
editor = "Luis-Felipe Cabrera and Vincent Russo and Marc Shapiro",
address = "Palo Alto, CA",
month = oct,
publisher = IEEE,
year = 1991,
ISBN = "0-8186-2267-9"
}

@proceedings{IWOOOS92, key = "IWOOOS",
booktitle = "International Workshop on Object Orientation in Operating Systems",
title = "International Workshop on Object Orientation in Operating Systems",
editor = "Luis-Felipe Cabrera and Vince Russo and Marc Shapiro",
address = "Paris",
month = sep,
publisher = IEEE,
year = 1992,
}

@proceedings{IWOOOS93, key = "IWOOOS",
booktitle = "International Workshop on Object Orientation in Operating Systems",
title = "International Workshop on Object Orientation in Operating Systems",
year = 1993,
}

@proceedings{IWPOS87, key = "IWPOS87",
title = "Second International Workshop on Persistent Object Systems",
booktitle = "Second International Workshop on Persistent Object Systems",
address = "Appin, Scotland",
month = aug,
year = 1987
}

%was dear90
%some contradictions over the date: 90 or 91?
@proceedings{IWPOS90, key = "IWPOS90",
title = "Implementing Persistent Object Bases:  Principles and Practice
(Proceedings of the Fourth International Workshop on Persistent Object Systems)",
booktitle = "Implementing Persistent Object Bases:  Principles and Practice
(Proceedings of the Fourth International Workshop on Persistent Object Systems)",
editor = "Alan Dearle and Gail M. Shaw and Stanley B. Zdonik",
address = "Martha's Vineyard, MA",
publisher = "Morgan Kaufman",
year = 1990,
month = sep
}

@proceedings{IWPOS92, key = "IWPOS92",
title = "Fifth International Workshop on Persistent Object Systems",
booktitle = "Fifth International Workshop on Persistent Object Systems",
year = 1992,
month = sep,
address = "Pisa, Italy",
publisher = "Springer-Verlag"
}

@proceedings{IWPOS94, key = "IWPOS94",
title =  "Proceedings of the Sixth International Workshop on Persistent Object Systems",
booktitle =  "Proceedings of the Sixth International Workshop on Persistent Object Systems",
year = 1994,
publisher = SV,
address = "Tarascon (France)",
month = sep
}

@proceedings{IWPOS96, key = "IWPOS96",
title = {Proceedings of the Seventh International Workshop on Persistent Object Systems},
booktitle = {Proceedings of the Seventh International Workshop on Persistent Object Systems},
publisher = {Morgan Kaufmann},
month = jun,
year = 1996
}

@proceedings{IWPOS98, key = "IWPOS98",
title = {Proceedings of the Eighth International Workshop on Persistent Object Systems},
booktitle = {Proceedings of the Eighth International Workshop on Persistent Object Systems},
address = {Tiburon, CA},
month = aug,
year = 1998
}

@proceedings{IWPOS00, key = "IWPOS00",
title = "{POS9} Ninth International Workshop on Persistent Object Systems",
booktitle = "{POS9} Ninth International Workshop on Persistent Object Systems",
editor = "Alan Dearle and Graham Kirby and Dag Sjoberg",
address = "Lillehammer, Norway",
publisher = "",
month = sep,
year = 2000
}

@proceedings{JVM01, key = "JVM",
title = {Usenix Java Virtual Machine Research and Technology Symposium (JVM '01)},
booktitle = {Usenix Java Virtual Machine Research and Technology Symposium (JVM '01)},
address = {Monterey, CA},
month = apr,
year = 2001,
}

@proceedings{JVM02, key = "JVM",
title = {Usenix Java Virtual Machine Research and Technology Symposium (JVM '02)},
booktitle = {Usenix Java Virtual Machine Research and Technology Symposium (JVM '02)},
address = {San Francisco, CA},
month = aug,
year = 2002,
}

@proceedings{LCTES99, key = "LCTES",
booktitle = {{ACM} {SIGPLAN} 1999 Workshop on Languages, Compilers, and Tools for Embedded Systems ({LCTES'99})},
title = {{ACM} {SIGPLAN} 1999 Workshop on Languages, Compilers, and Tools for Embedded Systems ({LCTES'99})},
address = {Atlanta, GA},
publisher = ACM,
month = may,
year = 1999
}

@proceedings{LCTES03, key = "LCTES",
booktitle = {{ACM} {SIGPLAN} 2003 Conference on Languages, Compilers, and Tools for Embedded Systems ({LCTES'2003})},
title = {{ACM} {SIGPLAN} 2003 Conference on Languages, Compilers, and Tools for Embedded Systems ({LCTES'2003})},
address = {San Diego, CA},
publisher = ACM,
month = jun,
year = 2003
}

@proceedings{LFP82, key = "LFP",
booktitle = "Conference Record of the 1982 {ACM} Symposium on Lisp and Functional Programming",
title = "Conference Record of the 1982 {ACM} Symposium on Lisp and Functional Programming",
address = "Pittsburgh, PA",
publisher = ACM,
month = aug,
year = 1982
}

@proceedings{LFP84, key = "LFP",
booktitle = "Conference Record of the 1984 {ACM} Symposium on Lisp and Functional Programming",
title = "Conference Record of the 1984 {ACM} Symposium on Lisp and Functional Programming",
editor = "Steele, Guy L.",
publisher = ACM,
address = "Austin, TX",
month = aug,
year = 1984
}

@proceedings{LFP86, key = "LFP",
booktitle = "Conference Record of the 1986 {ACM} Symposium on Lisp and Functional Programming",
title = "Conference Record of the 1986 {ACM} Symposium on Lisp and Functional Programming",
publisher = ACM,
series = SIGPLAN,
address = "Cambridge, MA",
month = aug,
year = 1986
}

@proceedings{LFP88, key = "LFP",
booktitle = "Conference Record of the 1988 {ACM} Symposium on Lisp and Functional Programming",
title = "Conference Record of the 1988 {ACM} Symposium on Lisp and Functional Programming",
publisher = ACM,
address = "Snowbird, Utah",
month = jul,
year = 1988
}

@proceedings{LFP90, key = "LFP",
booktitle = "Conference Record of the 1990 {ACM} Symposium on Lisp and Functional Programming",
title = "Conference Record of the 1990 {ACM} Symposium on Lisp and Functional Programming",
address = "Nice, France",
publisher = ACM,
month = jun,
year = 1990
}

@proceedings{LFP92, key = "LFP",
booktitle = "Conference Record of the 1992 {ACM} Symposium on Lisp and Functional Programming",
title = "Conference Record of the 1992 {ACM} Symposium on Lisp and Functional Programming",
address = "San Francisco, CA",
publisher = ACM,
month = jun,
year = 1992
}

@proceedings{LFP94, key = "LFP",
booktitle = "Conference Record of the 1994 {ACM} Symposium on Lisp and Functional Programming",
title = "Conference Record of the 1994 {ACM} Symposium on Lisp and Functional Programming",
publisher = ACM,
month = jun,
year = 1994
}

@proceedings{OOPSLA86, key = "OOPSLA",
booktitle = "{OOPSLA'86} {ACM} Conference on Object-Oriented Systems, Languages and Applications",
title = "{OOPSLA'86} {ACM} Conference on Object-Oriented Systems, Languages and Applications",
editor = "Norman Meyrowitz",
publisher = ACM,
series = SIGPLAN,
volume = "21(11)",
month = oct,
year = 1986
}

@proceedings{OOPSLA87, key = "OOPSLA",
booktitle = "{OOPSLA'87} {ACM} Conference on Object-Oriented Systems, Languages and Applications",
title = "{OOPSLA'87} {ACM} Conference on Object-Oriented Systems, Languages and Applications",
publisher = ACM,
series = SIGPLAN,
volume = "22(12)",
year = 1987
}

@proceedings{OOPSLA89, key = "OOPSLA",
booktitle = "{OOPSLA'89} {ACM} Conference on Object-Oriented Systems, Languages and Applications",
title = "{OOPSLA'89} {ACM} Conference on Object-Oriented Systems, Languages and Applications",
address = "New Orleans, LA",
month = oct,
publisher = ACM,
series = SIGPLAN,
volume = "24(10)",
year = 1989
}

@proceedings{OOPSLA90, key = "OOPSLA",
booktitle = "{OOPSLA'90} {ACM} Conference on Object-Oriented Systems, Languages and Applications",
title = "{OOPSLA'90} {ACM} Conference on Object-Oriented Systems, Languages and Applications",
editor = "Norman Meyrowitz",
month = oct,
address = "Ottawa, Ontario",
publisher = ACM,
series = SIGPLAN,
volume = "25(10)",
year = 1990
}

@proceedings{OOPSLA91, key = "OOPSLA",
booktitle = "{OOPSLA'91} {ACM} Conference on Object-Oriented Systems, Languages and Applications",
title = "{OOPSLA'91} {ACM} Conference on Object-Oriented Systems, Languages and Applications",
editor = "Andreas Paepcke",
month = oct,
address = "Phoenix, Arizona",
publisher = ACM,
series = SIGPLAN,
volume = "26(11)",
year = 1991
}

@proceedings{OOPSLA92, key = "OOPSLA",
booktitle = "{OOPSLA'92} {ACM} Conference on Object-Oriented Systems, Languages and Applications",
title = "{OOPSLA'92} {ACM} Conference on Object-Oriented Systems, Languages and Applications",
editor = "Andreas Paepcke",
month = oct,
address = "Vancouver, British Columbia",
publisher = ACM,
series = SIGPLAN,
volume = "27(10)",
year = 1992
}

@proceedings{OOPSLA93, key = "OOPSLA",
booktitle = "{OOPSLA'93} {ACM} Conference on Object-Oriented Systems, Languages and Applications",
title = "{OOPSLA'93} {ACM} Conference on Object-Oriented Systems, Languages and Applications",
editor = "Andreas Paepcke",
month = sep,
address = "Washington, D.C.",
publisher = ACM,
series = SIGPLAN,
volume = "28(10)",
year = 1993
}

@proceedings{OOPSLA94, key = "OOPSLA",
booktitle = "{OOPSLA'94} {ACM} Conference on Object-Oriented Systems, Languages and Applications",
title = "{OOPSLA'94} {ACM} Conference on Object-Oriented Systems, Languages and Applications",
publisher = ACM,
series = SIGPLAN,
volume = "29",
month = oct,
year = 1994
}

@proceedings{OOPSLA97, key = "OOPSLA",
booktitle = "{OOPSLA'97} {ACM} Conference on Object-Oriented Systems, Languages and Applications --- Twelth Annual Conference",
title = "{OOPSLA'97} {ACM} Conference on Object-Oriented Systems, Languages and Applications --- Twelth Annual Conference",
address = {Atlanta, GA},
publisher = ACM,
series = SIGPLAN,
volume = "32(10)",
month = oct,
year = 1997
}

@proceedings{OOPSLA98, key = "OOPSLA",
booktitle = "{OOPSLA'98} {ACM} Conference on Object-Oriented Systems, Languages and Applications",
title = "{OOPSLA'98} {ACM} Conference on Object-Oriented Systems, Languages and Applications",
address = {Vancouver},
publisher = ACM,
series = SIGPLAN,
month = oct,
year = 1998
}

@proceedings{OOPSLA99, key = "OOPSLA",
booktitle = "{OOPSLA'99} {ACM} Conference on Object-Oriented Systems, Languages and Applications",
title = "{OOPSLA'99} {ACM} Conference on Object-Oriented Systems, Languages and Applications",
address = {Denver, CO},
publisher = ACM,
series = SIGPLAN,
volume = "34(10)",
month = oct,
year = 1999
}

@proceedings{OOPSLA01, key = "OOPSLA",
booktitle = "{OOPSLA'01} {ACM} Conference on Object-Oriented Systems, Languages and Applications",
title = "{OOPSLA'01} {ACM} Conference on Object-Oriented Systems, Languages and Applications",
address = {Tampa, FL},
publisher = ACM,
series = SIGPLAN,
volume = {36(10)},
month = oct,
year = 2001,
}

@proceedings{OOPSLA02, key = "OOPSLA",
booktitle = "{OOPSLA'02} {ACM} Conference on Object-Oriented Systems, Languages and Applications",
title = "{OOPSLA'02} {ACM} Conference on Object-Oriented Systems, Languages and Applications",
address = {Seattle, WA},
publisher = ACM,
series = SIGPLAN,
month = nov,
year = 2002,
}

@proceedings{OOPSLA03, key = "OOPSLA",
booktitle = "{OOPSLA'03} {ACM} Conference on Object-Oriented Systems, Languages and Applications",
title = "{OOPSLA'03} {ACM} Conference on Object-Oriented Systems, Languages and Applications",
address = {Anaheim, CA},
publisher = ACM,
series = SIGPLAN,
month = nov,
year = 2003,
}

@proceedings{OOPSLA04, key = "OOPSLA",
booktitle = "{OOPSLA'04} {ACM} Conference on Object-Oriented Systems, Languages and Applications",
title = "{OOPSLA'04} {ACM} Conference on Object-Oriented Systems, Languages and Applications",
address = {Vancouver},
publisher = ACM,
series = SIGPLAN,
month = oct,
year = 2004,
}

@proceedings{OOPSLA90-gc, key ="OOPSLA-gc",
booktitle = "{OOPSLA/ECOOP} '90 Workshop on Garbage Collection in Object-Oriented Systems",
address = {Ottawa},
title = "{OOPSLA/ECOOP} '90 Workshop on Garbage Collection in Object-Oriented Systems",
editor = "Eric Jul and Niels-Christian Juul",
month = oct,
year = 1990,
URL = "ftp://ftp.diku.dk/pub/GC90",
}

@proceedings{OOPSLA91-gc, key ="OOPSLA-gc",
booktitle = "{OOPSLA/ECOOP} '91 Workshop on Garbage Collection in Object-Oriented Systems, Addendum to OOPSLA'91 Proceedings",
title = "{OOPSLA/ECOOP} '91 Workshop on Garbage Collection in Object-Oriented Systems, Addendum to OOPSLA'91 Proceedings",
editor = "Wilson, Paul R. and Barry Hayes",
month = oct,
year = 1991,
URL = "ftp://ftp.cs.utexas.edu//pub/garbage/GC91/",
}

@proceedings{OOPSLA93-gc, key ="OOPSLA-gc",
booktitle = "{OOPSLA/ECOOP} '93 Workshop on Garbage Collection in Object-Oriented Systems",
title = "{OOPSLA/ECOOP} '93 Workshop on Garbage Collection in Object-Oriented Systems",
month = oct,
editor = "Eliot Moss and Paul R. Wilson and Benjamin Zorn",
year = 1993,
URL = "ftp://ftp.cs.utexas.edu//pub/garbage/GC93/",
}

@proceedings{OOPSLA97-gc, key ="OOPSLA-gc",
booktitle = "{OOPSLA} '97 Workshop on Garbage Collection and Memory Management",
title = "{OOPSLA} '97 Workshop on Garbage Collection and Memory Management",
month = oct,
editor = "Peter Dickman and Paul R. Wilson",
year = 1997,
URL = "http://www.dcs.gla.ac.uk/~huw/oopsla97/gc/papers.html",
}

@proceedings{PARLE87, key = "PARLE",
booktitle = "{PARLE'87} Parallel Architectures and Languages Europe",
title = "{PARLE'87} Parallel Architectures and Languages Europe",
address = "Eindhoven, The Netherlands",
editor = "de Bakker, Jacobus W.  and L. Nijman and Philip C. Treleaven",
month = jun,
year = 1987,
publisher = SV,
series = LNCS,
volume = "258/259"
}

@proceedings{PARLE89, key = "PARLE",
booktitle = "{PARLE'89} Parallel Architectures and Languages Europe",
title = "{PARLE'89} Parallel Architectures and Languages Europe",
editor = "Eddy Odijik and M. Rem and Jean-Claude Sayr",
address = "Eindhoven, The Netherlands",
month = jun,
year = 1989,
publisher = SV,
series = LNCS,
volume = "265/366"
}

@proceedings{PARLE91, key = "PARLE",
booktitle = "{PARLE'91} Parallel Architectures and Languages Europe",
title = "{PARLE'91} Parallel Architectures and Languages Europe",
editor = "Aarts and others",
address = {Eindhoven, The Netherlands},
month = jun,
year = 1991,
publisher = SV,
series = LNCS,
volume = 505,
}

@proceedings{PARLE93, key = "PARLE",
booktitle = "{PARLE'93} Parallel Architectures and Languages Europe",
title = "{PARLE'93} Parallel Architectures and Languages Europe",
editor = "Arndt Bode and Mike Reeve and Gottfried Wolf",
address = {Munich},
month = jun,
year = 1993,
publisher = SV,
series = LNCS,
volume = 694
}

@proceedings{PARLE94, key = "PARLE",
booktitle = "{PARLE'94} Parallel Architectures and Languages Europe",
title = "{PARLE'94} Parallel Architectures and Languages Europe",
year = 1994,
publisher = SV,
series = LNCS,
}

@proceedings{PASTE98, key = "PASTE",
booktitle = "{ACM SUGPLAN-SIGSOFT} Workshop on Program Analysis for Software Tools and Engineering {PARLE'98}",
title = "{ACM SUGPLAN-SIGSOFT} Workshop on Program Analysis for Software Tools and Engineering {PARLE'98}",
year = 1998,
publisher = ACM,
}

@proceedings{PLILP92, key = "PLILP",
booktitle = "Fourth International Symposium on Programming Language Implementation and Logic Programming",
title = "Fourth International Symposium on Programming Language Implementation and Logic Programming",
month = aug,
year = 1992,
address = "Leuven, Belgium",
publisher = SV,
series = LNCS,
volume = 631
}

@proceedings{PLDI88, key = "PLDI",
booktitle = "Proceedings of {SIGPLAN'88} Conference on Programming Languages Design and Implementation",
title = "Proceedings of {SIGPLAN'88} Conference on Programming Languages Design and Implementation",
address = "Atlanta, Georgia",
month = jun,
year = 1988,
publisher = ACM,
series = SIGPLAN,
volume = "23(7)"
}

@proceedings{PLDI89, key = "PLDI",
booktitle = "Proceedings of {SIGPLAN'89} Conference on Programming Languages Design and Implementation",
title = "Proceedings of {SIGPLAN'89} Conference on Programming Languages Design and Implementation",
address = "Portland, Oregon",
month = jun,
year = 1989,
publisher = ACM,
series = SIGPLAN,
volume = "24(7)"
}

@proceedings{PLDI92, key = "PLDI",
booktitle = "Proceedings of {SIGPLAN'92} Conference on Programming Languages Design and Implementation",
title = "Proceedings of {SIGPLAN'92} Conference on Programming Languages Design and Implementation",
address = "San Francisco, CA",
month = jun,
year = 1992,
publisher = ACM,
series = SIGPLAN,
volume = "27"
}

@proceedings{PLDI93, key = "PLDI",
booktitle = "Proceedings of {SIGPLAN'93} Conference on Programming Languages Design and Implementation",
title = "Proceedings of {SIGPLAN'93} Conference on Programming Languages Design and Implementation",
address = "Albuquerque, NM",
month = jun,
year = 1993,
publisher = ACM,
series = SIGPLAN,
volume = "28(6)"
}

@proceedings{PLDI94, key = "PLDI",
booktitle = "Proceedings of {SIGPLAN'94} Conference on Programming Languages Design and Implementation",
title = "Proceedings of {SIGPLAN'94} Conference on Programming Languages Design and Implementation",
address = "Orlando, FL",
month = jun,
year = 1994,
publisher = ACM,
series = SIGPLAN,
volume = "29",
note = "Also Lisp Pointers VIII 3, July--September 1994"
}

@proceedings{PLDI95, key = "PLDI",
booktitle = "Proceedings of {SIGPLAN'95} Conference on Programming Languages Design and Implementation",
title = "Proceedings of {SIGPLAN'95} Conference on Programming Languages Design and Implementation",
address = "La Jolla, CA",
month = jun,
year = 1995,
publisher = ACM,
series = SIGPLAN,
volume = 30
}

@proceedings{PLDI96, key = "PLDI",
booktitle = "Proceedings of {SIGPLAN'96} Conference on Programming Languages Design and Implementation",
title = "Proceedings of {SIGPLAN'96} Conference on Programming Languages Design and Implementation",
year = 1996,
publisher = ACM,
series = SIGPLAN,
volume = 31
}

@proceedings{PLDI97, key = "PLDI",
booktitle = "Proceedings of {SIGPLAN'97} Conference on Programming Languages Design and Implementation",
title = "Proceedings of {SIGPLAN'97} Conference on Programming Languages Design and Implementation",
address = {Las Vegas, Nevada},
month = jun,
year = 1997,
publisher = ACM,
series = SIGPLAN,
}

@proceedings{PLDI98, key = "PLDI",
booktitle = "Proceedings of {SIGPLAN'98} Conference on Programming Languages Design and Implementation",
title = "Proceedings of {SIGPLAN'98} Conference on Programming Languages Design and Implementation",
address = {Montreal},
month = jun,
year = 1998,
publisher = ACM,
series = SIGPLAN,
}

@proceedings{PLDI99, key = "PLDI",
booktitle = "Proceedings of {SIGPLAN'99} Conference on Programming Languages Design and Implementation",
title = "Proceedings of {SIGPLAN'99} Conference on Programming Languages Design and Implementation",
address = {Atlanta},
month = may,
year = 1999,
publisher = ACM,
series = SIGPLAN,
}

@proceedings{PLDI00, key = "PLDI",
booktitle = "Proceedings of {SIGPLAN 2000} Conference on Programming Languages Design and Implementation",
title = "Proceedings of {SIGPLAN 2000} Conference on Programming Languages Design and Implementation",
address = {Vancouver},
month = jun,
year = 2000,
publisher = ACM,
series = SIGPLAN,
}

@proceedings{PLDI01, key = "PLDI",
booktitle = "Proceedings of {SIGPLAN 2001} Conference on Programming Languages Design and Implementation",
title = "Proceedings of {SIGPLAN 2001} Conference on Programming Languages Design and Implementation",
address = {Snowbird, Utah},
month = jun,
year = 2001,
publisher = ACM,
series = SIGPLAN,
}

@proceedings{PLDI02, key = "PLDI",
booktitle = "Proceedings of {SIGPLAN 2002} Conference on Programming Languages Design and Implementation",
title = "Proceedings of {SIGPLAN 2002} Conference on Programming Languages Design and Implementation",
address = {Berlin},
month = jun,
year = 2002,
publisher = ACM,
series = SIGPLAN,
}

@proceedings{PLDI03, key = "PLDI",
booktitle = "Proceedings of {SIGPLAN 2003} Conference on Programming Languages Design and Implementation",
title = "Proceedings of {SIGPLAN 2003} Conference on Programming Languages Design and Implementation",
address = {San Diego, CA},
month = jun,
year = 2003,
publisher = ACM,
series = SIGPLAN,
}

@proceedings{PLDI04, key = "PLDI",
booktitle = "Proceedings of {SIGPLAN 2004} Conference on Programming Languages Design and Implementation",
title = "Proceedings of {SIGPLAN 2004} Conference on Programming Languages Design and Implementation",
address = {Washington, DC},
month = jun,
year = 2004,
publisher = ACM,
series = SIGPLAN,
}


@proceedings{PPoPP90, key = "PPoPP",
booktitle = "ACM Symposium on Principles and Practice of Parallel Programming",
title = "ACM Symposium on Principles and Practice of Parallel Programming",
month = mar,
year = 1990,
publisher = ACM,
series = SIGPLAN,
volume = 30
}

@proceedings{PPoPP93, key = "PPoPP",
booktitle = "Fourth Annual ACM Symposium on Principles and Practice of Parallel Programming",
title = "Fourth Annual ACM Symposium on Principles and Practice of Parallel Programming",
address = "San Diego, CA",
month = may,
year = 1993,
publisher = ACM,
series = SIGPLAN,
volume = "28(7)"
}

@proceedings{PPoPP97, key = "PPoPP",
booktitle = "ACM Symposium on Principles and Practice of Parallel Programming",
title = "ACM Symposium on Principles and Practice of Parallel Programming",
address = "Las Vegas, NA",
month = jun,
year = 1997,
publisher = ACM,
series = SIGPLAN,
}

@proceedings{POPL81, key = "POPL",
booktitle = "Conference Record of the Eighth Annual ACM Symposium on Principles of Programming Languages",
title = "Conference Record of the Eighth Annual ACM Symposium on Principles of Programming Languages",
address = "Williamsburg",
month = jan,
year = 1981,
publisher = ACM,
series = SIGPLAN,
}

@proceedings{POPL83, key = "POPL",
title = "Conference Record of the Tenth Annual ACM Symposium on Principles of Programming Languages",
booktitle = "Conference Record of the Tenth Annual ACM Symposium on Principles of Programming Languages",
month = jan,
year = 1983,
publisher = ACM,
series = SIGPLAN,
}

@proceedings{POPL84, key = "POPL",
title = "Conference Record of the Eleventh Annual ACM Symposium on Principles of Programming Languages",
booktitle = "Conference Record of the Eleventh Annual ACM Symposium on Principles of Programming Languages",
address = "Salt Lake City, Utah",
publisher = ACM,
month = jan,
year = 1984,
series = SIGPLAN,
}

@proceedings{POPL87, key = "POPL",
booktitle = "Conference Record of the Fourteenth Annual ACM Symposium on Principles of Programming Languages",
title = "Conference Record of the Fourteenth Annual ACM Symposium on Principles of Programming Languages",
publisher = ACM,
month = jan,
year = 1987,
series = SIGPLAN,
}

@proceedings{POPL88, key = "POPL",
booktitle = "Conference Record of the Fifteenth Annual ACM Symposium on Principles of Programming Languages",
title = "Conference Record of the Fifteenth Annual ACM Symposium on Principles of Programming Languages",
publisher = ACM,
month = jan,
year = 1988,
series = SIGPLAN,
}

@proceedings{POPL90, key = "POPL",
booktitle = "Conference Record of the Seventeenth Annual ACM Symposium on Principles of Programming Languages",
title = "Conference Record of the Seventeenth Annual ACM Symposium on Principles of Programming Languages",
address = "San Francisco, CA",
publisher = ACM,
month = jan,
year = 1990,
series = SIGPLAN,
}

@proceedings{POPL92, key = "POPL",
booktitle = "Conference Record of the Nineteenth Annual ACM Symposium on Principles of Programming Languages",
title = "Conference Record of the Nineteenth Annual ACM Symposium on Principles of Programming Languages",
address = {Albuquerque, NM},
publisher = ACM,
month = jan,
year = 1992,
series = SIGPLAN,
}

@proceedings{POPL93, key = "POPL",
booktitle = "Conference Record of the Twentieth Annual ACM Symposium on Principles of Programming Languages",
title = "Conference Record of the Twentieth Annual ACM Symposium on Principles of Programming Languages",
publisher = ACM,
month = jan,
year = 1993,
series = SIGPLAN,
}

@proceedings{POPL94, key = "POPL",
booktitle = "Conference Record of the Twenty-first Annual ACM Symposium on Principles of Programming Languages",
title = "Conference Record of the Twenty-first Annual ACM Symposium on Principles of Programming Languages",
address = {Portland, OR},
publisher = ACM,
month = jan,
year = 1994,
series = SIGPLAN,
URL = {http://www.acm.org/sigplan/proceedings/popl94/homepage.html}
}

@proceedings{POPL96, key = "POPL",
booktitle = "Conference Record of the Twenty-third Annual ACM Symposium on Principles of Programming Languages",
title = "Conference Record of the Twenty-third Annual ACM Symposium on Principles of Programming Languages",
publisher = ACM,
year = 1996,
series = SIGPLAN,
URL = {http://www.acm.org/sigplan/proceedings/popl96/homepage.html}
}

@proceedings{POPL99, key = "POPL",
booktitle = "Conference Record of the Twenty-sixth Annual ACM Symposium on Principles of Programming Languages",
title = "Conference Record of the Twenty-sixth Annual ACM Symposium on Principles of Programming Languages",
publisher = ACM,
year = 1999,
series = SIGPLAN,
}

@proceedings{POPL01, key = "POPL",
booktitle = "Conference Record of the Twenty-eighth Annual ACM Symposium on Principles of Programming Languages",
title = "Conference Record of the Twenty-eighth Annual ACM Symposium on Principles of Programming Languages",
publisher = ACM,
month = jan,
year = 2001,
series = SIGPLAN,
}

@proceedings{POPL02, key = "POPL",
booktitle = "Conference Record of the Twenty-ninth Annual ACM Symposium on Principles of Programming Languages",
title = "Conference Record of the Twenty-ninth Annual ACM Symposium on Principles of Programming Languages",
publisher = ACM,
month = jan,
year = 2002,
series = SIGPLAN,
}

@proceedings{POPL03, key = "POPL",
booktitle = "Conference Record of the Thirtieth Annual ACM Symposium on Principles of Programming Languages",
title = "Conference Record of the Thirtieth Annual ACM Symposium on Principles of Programming Languages",
address = {New Orleans, LA},
publisher = ACM,
month = jan,
year = 2003,
series = SIGPLAN,
}

@proceedings{SIGMOD89, key = "SIGMOD",
booktitle = "Proceedings of {ACM} {SIGMOD} International Conference
on Management of Data",
title = "Proceedings of {ACM} {SIGMOD} International Conference
on Management of Data",
publisher = ACM,
address = "Snowbird, Utah",
month = jun,
year = 1989
}

@proceedings{SIIT87, key = "SIIT",
booktitle = "SIGPLAN'87 Symposium on Interpreters and Interpretive Techniques",
title = "SIGPLAN'87 Symposium on Interpreters and Interpretive Techniques",
year = 1987,
publisher = ACM,
series = SIGPLAN,
volume = "22(7)"
}

@proceedings{SOSP93, key = "SOSP",
booktitle = "Proceedings of the Fourteenth Symposium on Operating Systems Principles",
title = "Proceedings of the Fourteenth Symposium on Operating Systems Principles",
address = "Asheville, North Carolina",
publisher = ACM,
series = "Operating Systems Review",
volume = "27(5)",
month = dec,
year = 1993,
}

@proceedings{TLDI03, key = "TLDI",
booktitle = "Proceedings of the 2003 ACM SIGPLAN Workshop on Types in Language Design and Implementation",
title = "Proceedings of the 2003 ACM SIGPLAN Workshop on Types in Language Design and Implementation",
editor = {Peter Lee},
address = "New Orleans, LA",
publisher = ACM,
series = SIGPLAN,
volume = {38(3)},
month = jan,
year = 2003,
}

@proceedings{WDAG96, key = "WDAG",
title = "Tenth International Workshop on Distributed Algorithms WDAG'96",
booktitle = "Tenth International Workshop on Distributed Algorithms WDAG'96",
editor = "Ozalp Babaoglu and Keith Marzullo",
address = "Bologna",
series = LNCS, 
volume = 1151,
publisher = SV,
month = oct,
year = 1996
}

@misc{GCpage,
author = {Richard Jones},
title = {The Garbage Collection Page},
URL = {http://www.cs.ukc.ac.uk/people/staff/rej/gc.html},
note = {The definitive on-line resource for garbage collection material}
}

@misc{GCbib,
author = {Richard Jones},
title = {The Garbage Collection Bibliography},
URL = {http://www.cs.ukc.ac.uk/people/staff/rej/gcbib/gcbib.html},
}

@inproceedings{eeck03,
 author = {Lieven Eeckhout and Andy Georges and Koen De Bosschere},
 title = {How {Java} programs interact with virtual machines at the microarchitectural level},
 crossref = {OOPSLA03},
 pages = {169--186}
}


@inproceedings{dhurjati06,
 author = {Dinakar Dhurjati and Vikram Adve},
 title = {Efficiently Detecting All Dangling Pointer Uses in Production Servers},
 booktitle = {DSN '06: Proceedings of the International Conference on Dependable Systems and Networks (DSN'06)},
 year = {2006},
 isbn = {0-7695-2607-1},
 pages = {269--280},
 doi = {http://dx.doi.org/10.1109/DSN.2006.31},
 publisher = {IEEE Computer Society},
 address = {Washington, DC, USA},
 }

@InProceedings{yarvin93usenix,
  author =             "Curtis Yarvin and Richard Bukowski and Thomas
                               Anderson",
  title =   "Anonymous {RPC}: Low-latency Protection in a 64-Bit
                               Address Space",
  booktitle =        "Proceedings of the 1993 Summer USENIX Conference",
  year = "1993",
  pages =              "175--186",
}

@TechReport{Druschel92hiding,
  author =             "Peter Druschel and Larry L. Peterson",
  title =   "High-Performance Cross-Domain Data Transfer",
  institution =  "Dept. Comp. of Sc., U. of Arizona",
  number =           "TR 92-11",
  address =           "Tucson, AZ (USA)",
  month =             mar,
  year = "1992",
}

@Article{chase94opal,
  author =             "Jeffrey S. Chase and Henry M. Levy and Michael J.
                               Feeley and Edward D. Lazowska",
  title =   "Sharing and Protection in a Single-Address-Space
                               Operating System",
  journal =            "ACM Transactions on Computer Systems",
  volume =           "12",
  number =           "4",
  pages =              "271--307",
  month =             nov,
  year = "1994",
  CODEN =           "ACSYEC",
  ISSN = "0734-2071",
  bibdate =           "Wed Jan 13 18:36:53 MST 1999",
  bibsource =       "http://www.acm.org/pubs/contents/journals/tocs/",
  URL =                 "http://www.acm.org:80/pubs/citations/journals/tocs/1994-12-4/p271-chase/",
  
}

@inproceedings{huck93isca,
 author = {Jerry Huck and Jim Hays},
 title = {Architectural support for translation table management in large address space machines},
 booktitle = {ISCA '93: Proceedings of the 20th annual international symposium on Computer architecture},
 year = {1993},
 isbn = {0-8186-3810-9},
 pages = {39--50},
 location = {San Diego, California, United States},
 doi = {http://doi.acm.org/10.1145/165123.165128},
 publisher = {ACM Press},
 address = {New York, NY, USA},
 }

@inproceedings{novark07exterminator,
 author = {Gene Novark and Emery D. Berger and Benjamin G. Zorn},
 title = {Exterminator: automatically correcting memory errors with high probability},
 booktitle = {PLDI '07: Proceedings of the 2007 ACM SIGPLAN conference on Programming language design and implementation},
 year = {2007},
 isbn = {978-1-59593-633-2},
 pages = {1--11},
 location = {San Diego, California, USA},
 doi = {http://doi.acm.org/10.1145/1250734.1250736},
 publisher = {ACM Press},
 address = {New York, NY, USA},
 }



%END
